{"title": "64. 最小路径和", "level": "中等", "description": "<p>给定一个包含非负整数的 <em>m</em>&nbsp;x&nbsp;<em>n</em>&nbsp;网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n\n<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\n[\n&nbsp; [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n<strong>输出:</strong> 7\n<strong>解释:</strong> 因为路径 1→3→1→1→1 的总和最小。\n</pre>\n", "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n            }\n};"}