{"title": "911. 在线选举", "level": "中等", "description": "<p>在选举中，第&nbsp;<code>i</code>&nbsp;张票是在时间为&nbsp;<code>times[i]</code>&nbsp;时投给&nbsp;<code>persons[i]</code>&nbsp;的。</p>\n\n<p>现在，我们想要实现下面的查询函数： <code>TopVotedCandidate.q(int t)</code> 将返回在&nbsp;<code>t</code> 时刻主导选举的候选人的编号。</p>\n\n<p>在&nbsp;<code>t</code> 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[\"TopVotedCandidate\",\"q\",\"q\",\"q\",\"q\",\"q\",\"q\"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]\n<strong>输出：</strong>[null,0,1,1,0,0,1]\n<strong>解释：</strong>\n时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。\n时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。\n时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。\n在时间 15、24 和 8 处继续执行 3 个查询。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= persons.length = times.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= persons[i] &lt;= persons.length</code></li>\n\t<li><code>times</code>&nbsp;是严格递增的数组，所有元素都在&nbsp;<code>[0, 10^9]</code>&nbsp;范围中。</li>\n\t<li>每个测试用例最多调用&nbsp;<code>10000</code>&nbsp;次&nbsp;<code>TopVotedCandidate.q</code>。</li>\n\t<li><code>TopVotedCandidate.q(int t)</code>&nbsp;被调用时总是满足&nbsp;<code>t &gt;= times[0]</code>。</li>\n</ol>\n", "code": "class TopVotedCandidate {\npublic:\n    TopVotedCandidate(vector<int>& persons, vector<int>& times) {\n            }\n        int q(int t) {\n            }\n};\n /**\n * Your TopVotedCandidate object will be instantiated and called as such:\n * TopVotedCandidate* obj = new TopVotedCandidate(persons, times);\n * int param_1 = obj->q(t);\n */"}