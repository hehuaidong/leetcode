{"title": "25. K 个一组翻转链表", "level": "困难", "description": "<p>给你一个链表，每&nbsp;<em>k&nbsp;</em>个节点一组进行翻转，请你返回翻转后的链表。</p>\n\n<p><em>k&nbsp;</em>是一个正整数，它的值小于或等于链表的长度。</p>\n\n<p>如果节点总数不是&nbsp;<em>k&nbsp;</em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n\n<p><strong>示例 :</strong></p>\n\n<p>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>\n\n<p>当&nbsp;<em>k&nbsp;</em>= 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>\n\n<p>当&nbsp;<em>k&nbsp;</em>= 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>\n\n<p><strong>说明 :</strong></p>\n\n<ul>\n\t<li>你的算法只能使用常数的额外空间。</li>\n\t<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li>\n</ul>\n", "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n            }\n};"}