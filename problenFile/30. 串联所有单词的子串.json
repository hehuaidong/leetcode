{"title": "30. 串联所有单词的子串", "level": "困难", "description": "<p>给定一个字符串&nbsp;<strong>s&nbsp;</strong>和一些长度相同的单词&nbsp;<strong>words。</strong>找出 <strong>s </strong>中恰好可以由&nbsp;<strong>words </strong>中所有单词串联形成的子串的起始位置。</p>\n\n<p>注意子串要与&nbsp;<strong>words </strong>中的单词完全匹配，中间不能有其他字符，但不需要考虑&nbsp;<strong>words&nbsp;</strong>中单词串联的顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：\n  s =</strong> \"barfoothefoobarman\",\n<strong>  words = </strong>[\"foo\",\"bar\"]\n<strong>输出：</strong><code>[0,9]</code>\n<strong>解释：</strong>\n从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：\n  s =</strong> \"wordgoodgoodgoodbestword\",\n<strong>  words = </strong>[\"word\",\"good\",\"best\",\"word\"]\n<code><strong>输出：</strong>[]</code>\n</pre>\n", "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n            }\n};"}