{"url": "https://leetcode-cn.com/problems/two-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/add-two-numbers", "source": [{"lang": "Java", "code": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummyHead;\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        carry = sum / 10;\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry > 0) {\n        curr.next = new ListNode(carry);\n    }\n    return dummyHead.next;\n}"}]}
{"url": "https://leetcode-cn.com/problems/longest-substring-without-repeating-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/median-of-two-sorted-arrays", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-palindromic-substring", "source": []}
{"url": "https://leetcode-cn.com/problems/zigzag-conversion", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-integer", "source": [{"lang": "C++", "code": "//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;"}, {"lang": "Java", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/string-to-integer-atoi", "source": []}
{"url": "https://leetcode-cn.com/problems/palindrome-number", "source": [{"lang": "C#", "code": "public class Solution {\n    public bool IsPalindrome(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if(x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while(x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/regular-expression-matching", "source": [{"lang": "Python", "code": "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])"}, {"lang": "Java", "code": "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isMatch(self, text, pattern):\n        if not pattern:\n            return not text\n\n        first_match = bool(text) and pattern[0] in {text[0], '.'}\n\n        if len(pattern) >= 2 and pattern[1] == '*':\n            return (self.isMatch(text, pattern[2:]) or\n                    first_match and self.isMatch(text[1:], pattern))\n        else:\n            return first_match and self.isMatch(text[1:], pattern[1:])"}, {"lang": "Java", "code": "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isMatch(self, text, pattern):\n        memo = {}\n        def dp(i, j):\n            if (i, j) not in memo:\n                if j == len(pattern):\n                    ans = i == len(text)\n                else:\n                    first_match = i < len(text) and pattern[j] in {text[i], '.'}\n                    if j+1 < len(pattern) and pattern[j+1] == '*':\n                        ans = dp(i, j+2) or first_match and dp(i+1, j)\n                    else:\n                        ans = first_match and dp(i+1, j+1)\n\n                memo[i, j] = ans\n            return memo[i, j]\n\n        return dp(0, 0)"}, {"lang": "Java", "code": "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isMatch(self, text, pattern):\n        dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)]\n\n        dp[-1][-1] = True\n        for i in range(len(text), -1, -1):\n            for j in range(len(pattern) - 1, -1, -1):\n                first_match = i < len(text) and pattern[j] in {text[i], '.'}\n                if j+1 < len(pattern) and pattern[j+1] == '*':\n                    dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]\n                else:\n                    dp[i][j] = first_match and dp[i+1][j+1]\n\n        return dp[0][0]"}]}
{"url": "https://leetcode-cn.com/problems/container-with-most-water", "source": [{"lang": "Java", "code": "public class Solution {\n    public int maxArea(int[] height) {\n        int maxarea = 0;\n        for (int i = 0; i < height.length; i++)\n            for (int j = i + 1; j < height.length; j++)\n                maxarea = Math.max(maxarea, Math.min(height[i], height[j]) * (j - i));\n        return maxarea;\n    }\n}"}, {"lang": "Java", "code": "1 8 6 2 5 4 8 3 7"}]}
{"url": "https://leetcode-cn.com/problems/integer-to-roman", "source": []}
{"url": "https://leetcode-cn.com/problems/roman-to-integer", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-common-prefix", "source": []}
{"url": "https://leetcode-cn.com/problems/3sum", "source": []}
{"url": "https://leetcode-cn.com/problems/3sum-closest", "source": []}
{"url": "https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number", "source": [{"lang": "Java", "code": "class Solution {\n  Map<String, String> phone = new HashMap<String, String>() {{\n    put(\"2\", \"abc\");\n    put(\"3\", \"def\");\n    put(\"4\", \"ghi\");\n    put(\"5\", \"jkl\");\n    put(\"6\", \"mno\");\n    put(\"7\", \"pqrs\");\n    put(\"8\", \"tuv\");\n    put(\"9\", \"wxyz\");\n  }};\n\n  List<String> output = new ArrayList<String>();\n\n  public void backtrack(String combination, String next_digits) {\n    // if there is no more digits to check\n    if (next_digits.length() == 0) {\n      // the combination is done\n      output.add(combination);\n    }\n    // if there are still digits to check\n    else {\n      // iterate over all letters which map \n      // the next available digit\n      String digit = next_digits.substring(0, 1);\n      String letters = phone.get(digit);\n      for (int i = 0; i < letters.length(); i++) {\n        String letter = phone.get(digit).substring(i, i + 1);\n        // append the current letter to the combination\n        // and proceed to the next digits\n        backtrack(combination + letter, next_digits.substring(1));\n      }\n    }\n  }\n\n  public List<String> letterCombinations(String digits) {\n    if (digits.length() != 0)\n      backtrack(\"\", digits);\n    return output;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        phone = {'2': ['a', 'b', 'c'],\n                 '3': ['d', 'e', 'f'],\n                 '4': ['g', 'h', 'i'],\n                 '5': ['j', 'k', 'l'],\n                 '6': ['m', 'n', 'o'],\n                 '7': ['p', 'q', 'r', 's'],\n                 '8': ['t', 'u', 'v'],\n                 '9': ['w', 'x', 'y', 'z']}\n                \n        def backtrack(combination, next_digits):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map \n                # the next available digit\n                for letter in phone[next_digits[0]]:\n                    # append the current letter to the combination\n                    # and proceed to the next digits\n                    backtrack(combination + letter, next_digits[1:])\n                    \n        output = []\n        if digits:\n            backtrack(\"\", digits)\n        return output"}]}
{"url": "https://leetcode-cn.com/problems/4sum", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/merge-two-sorted-lists", "source": [{"lang": "Java", "code": "class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        else if (l2 == null) {\n            return l1;\n        }\n        else if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def mergeTwoLists(self, l1, l2):\n        if l1 is None:\n            return l2\n        elif l2 is None:\n            return l1\n        elif l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}, {"lang": "Java", "code": "class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        // maintain an unchanging reference to node ahead of the return node.\n        ListNode prehead = new ListNode(-1);\n\n        ListNode prev = prehead;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n\n        // exactly one of l1 and l2 can be non-null at this point, so connect\n        // the non-null list to the end of the merged list.\n        prev.next = l1 == null ? l2 : l1;\n\n        return prehead.next;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def mergeTwoLists(self, l1, l2):\n        # maintain an unchanging reference to node ahead of the return node.\n        prehead = ListNode(-1)\n\n        prev = prehead\n        while l1 and l2:\n            if l1.val <= l2.val:\n                prev.next = l1\n                l1 = l1.next\n            else:\n                prev.next = l2\n                l2 = l2.next            \n            prev = prev.next\n\n        # exactly one of l1 and l2 can be non-null at this point, so connect\n        # the non-null list to the end of the merged list.\n        prev.next = l1 if l1 is not None else l2\n\n        return prehead.next"}]}
{"url": "https://leetcode-cn.com/problems/generate-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/merge-k-sorted-lists", "source": []}
{"url": "https://leetcode-cn.com/problems/swap-nodes-in-pairs", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-nodes-in-k-group", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-element", "source": [{"lang": "Java", "code": "public int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}"}, {"lang": "Java", "code": "public int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}"}]}
{"url": "https://leetcode-cn.com/problems/implement-strstr", "source": []}
{"url": "https://leetcode-cn.com/problems/divide-two-integers", "source": []}
{"url": "https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words", "source": []}
{"url": "https://leetcode-cn.com/problems/next-permutation", "source": [{"lang": "Java", "code": "[9, 5, 4, 3, 1]"}]}
{"url": "https://leetcode-cn.com/problems/longest-valid-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/search-in-rotated-sorted-array", "source": [{"lang": "Java", "code": "class Solution {\n  int [] nums;\n  int target;\n\n  public int find_rotate_index(int left, int right) {\n    if (nums[left] < nums[right])\n      return 0;\n\n    while (left <= right) {\n      int pivot = (left + right) / 2;\n      if (nums[pivot] > nums[pivot + 1])\n        return pivot + 1;\n      else {\n        if (nums[pivot] < nums[left])\n          right = pivot - 1;\n        else\n          left = pivot + 1;\n      }\n    }\n    return 0;\n  }\n\n  public int search(int left, int right) {\n    /*\n    Binary search\n    */\n    while (left <= right) {\n      int pivot = (left + right) / 2;\n      if (nums[pivot] == target)\n        return pivot;\n      else {\n        if (target < nums[pivot])\n          right = pivot - 1;\n        else\n          left = pivot + 1;\n      }\n    }\n    return -1;\n  }\n\n  public int search(int[] nums, int target) {\n    this.nums = nums;\n    this.target = target;\n\n    int n = nums.length;\n\n    if (n == 0)\n      return -1;\n    if (n == 1)\n      return this.nums[0] == target ? 0 : -1;\n\n    int rotate_index = find_rotate_index(0, n - 1);\n\n    // if target is the smallest element\n    if (nums[rotate_index] == target)\n      return rotate_index;\n    // if array is not rotated, search in the entire array\n    if (rotate_index == 0)\n      return search(0, n - 1);\n    if (target < nums[0])\n      // search in the right side\n      return search(rotate_index, n - 1);\n    // search in the left side\n    return search(0, rotate_index);\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def find_rotate_index(left, right):\n            if nums[left] < nums[right]:\n                return 0\n            \n            while left <= right:\n                pivot = (left + right) // 2\n                if nums[pivot] > nums[pivot + 1]:\n                    return pivot + 1\n                else:\n                    if nums[pivot] < nums[left]:\n                        right = pivot - 1\n                    else:\n                        left = pivot + 1\n                \n        def search(left, right):\n            \"\"\"\n            Binary search\n            \"\"\"\n            while left <= right:\n                pivot = (left + right) // 2\n                if nums[pivot] == target:\n                    return pivot\n                else:\n                    if target < nums[pivot]:\n                        right = pivot - 1\n                    else:\n                        left = pivot + 1\n            return -1\n        \n        n = len(nums)\n        \n        if n == 0:\n            return -1\n        if n == 1:\n            return 0 if nums[0] == target else -1 \n        \n        rotate_index = find_rotate_index(0, n - 1)\n        \n        # if target is the smallest element\n        if nums[rotate_index] == target:\n            return rotate_index\n        # if array is not rotated, search in the entire array\n        if rotate_index == 0:\n            return search(0, n - 1)\n        if target < nums[0]:\n            # search on the right side\n            return search(rotate_index, n - 1)\n        # search on the left side\n        return search(0, rotate_index)"}]}
{"url": "https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array", "source": []}
{"url": "https://leetcode-cn.com/problems/search-insert-position", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-sudoku", "source": [{"lang": "Java", "code": "class Solution {\n  public boolean isValidSudoku(char[][] board) {\n    // init data\n    HashMap<Integer, Integer> [] rows = new HashMap[9];\n    HashMap<Integer, Integer> [] columns = new HashMap[9];\n    HashMap<Integer, Integer> [] boxes = new HashMap[9];\n    for (int i = 0; i < 9; i++) {\n      rows[i] = new HashMap<Integer, Integer>();\n      columns[i] = new HashMap<Integer, Integer>();\n      boxes[i] = new HashMap<Integer, Integer>();\n    }\n\n    // validate a board\n    for (int i = 0; i < 9; i++) {\n      for (int j = 0; j < 9; j++) {\n        char num = board[i][j];\n        if (num != '.') {\n          int n = (int)num;\n          int box_index = (i / 3 ) * 3 + j / 3;\n\n          // keep the current cell value\n          rows[i].put(n, rows[i].getOrDefault(n, 0) + 1);\n          columns[j].put(n, columns[j].getOrDefault(n, 0) + 1);\n          boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1);\n\n          // check if this value has been already seen before\n          if (rows[i].get(n) > 1 || columns[j].get(n) > 1 || boxes[box_index].get(n) > 1)\n            return false;\n        }\n      }\n    }\n\n    return true;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        # init data\n        rows = [{} for i in range(9)]\n        columns = [{} for i in range(9)]\n        boxes = [{} for i in range(9)]\n\n        # validate a board\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != '.':\n                    num = int(num)\n                    box_index = (i // 3 ) * 3 + j // 3\n                    \n                    # keep the current cell value\n                    rows[i][num] = rows[i].get(num, 0) + 1\n                    columns[j][num] = columns[j].get(num, 0) + 1\n                    boxes[box_index][num] = boxes[box_index].get(num, 0) + 1\n                    \n                    # check if this value has been already seen before\n                    if rows[i][num] > 1 or columns[j][num] > 1 or boxes[box_index][num] > 1:\n                        return False         \n        return True"}]}
{"url": "https://leetcode-cn.com/problems/sudoku-solver", "source": []}
{"url": "https://leetcode-cn.com/problems/count-and-say", "source": []}
{"url": "https://leetcode-cn.com/problems/combination-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/combination-sum-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/first-missing-positive", "source": [{"lang": "Java", "code": "class Solution {\n  public int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n\n    // 基本情况\n    int contains = 0;\n    for (int i = 0; i < n; i++)\n      if (nums[i] == 1) {\n        contains++;\n        break;\n      }\n\n    if (contains == 0)\n      return 1;\n\n    // nums = [1]\n    if (n == 1)\n      return 2;\n\n    // 用 1 替换负数，0，\n    // 和大于 n 的数\n    // 在转换以后，nums 只会包含\n    // 正数\n    for (int i = 0; i < n; i++)\n      if ((nums[i] <= 0) || (nums[i] > n))\n        nums[i] = 1;\n\n    // 使用索引和数字符号作为检查器\n    // 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`\n    // 如果 nums[2] 是正数 表示数字 2 没有出现\n    for (int i = 0; i < n; i++) {\n      int a = Math.abs(nums[i]);\n      // 如果发现了一个数字 a - 改变第 a 个元素的符号\n      // 注意重复元素只需操作一次\n      if (a == n)\n        nums[0] = - Math.abs(nums[0]);\n      else\n        nums[a] = - Math.abs(nums[a]);\n    }\n\n    // 现在第一个正数的下标\n    // 就是第一个缺失的数\n    for (int i = 1; i < n; i++) {\n      if (nums[i] > 0)\n        return i;\n    }\n\n    if (nums[0] > 0)\n      return n;\n\n    return n + 1;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        \n        # 基本情况\n        if 1 not in nums:\n            return 1\n        \n        # nums = [1]\n        if n == 1:\n            return 2\n        \n        # 用 1 替换负数，0，\n        # 和大于 n 的数\n        # 在转换以后，nums 只会包含\n        # 正数\n        for i in range(n):\n            if nums[i] <= 0 or nums[i] > n:\n                nums[i] = 1\n        \n        # 使用索引和数字符号作为检查器\n        # 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`\n        # 如果 nums[2] 是正数 表示数字 2 没有出现\n        for i in range(n): \n            a = abs(nums[i])\n            # 如果发现了一个数字 a - 改变第 a 个元素的符号\n            # 注意重复元素只需操作一次\n            if a == n:\n                nums[0] = - abs(nums[0])\n            else:\n                nums[a] = - abs(nums[a])\n            \n        # 现在第一个正数的下标\n        # 就是第一个缺失的数\n        for i in range(1, n):\n            if nums[i] > 0:\n                return i\n        \n        if nums[0] > 0:\n            return n\n            \n        return n + 1"}]}
{"url": "https://leetcode-cn.com/problems/trapping-rain-water", "source": [{"lang": "C++", "code": "int trap(vector<int>& height)\n{\n    int ans = 0;\n    int size = height.size();\n    for (int i = 1; i < size - 1; i++) {\n        int max_left = 0, max_right = 0;\n        for (int j = i; j >= 0; j--) { //Search the left part for max bar size\n            max_left = max(max_left, height[j]);\n        }\n        for (int j = i; j < size; j++) { //Search the right part for max bar size\n            max_right = max(max_right, height[j]);\n        }\n        ans += min(max_left, max_right) - height[i];\n    }\n    return ans;\n}"}, {"lang": "C++", "code": "int trap(vector<int>& height)\n{\n if(height == null)\n  return 0;\n    int ans = 0;\n    int size = height.size();\n    vector<int> left_max(size), right_max(size);\n    left_max[0] = height[0];\n    for (int i = 1; i < size; i++) {\n        left_max[i] = max(height[i], left_max[i - 1]);\n    }\n    right_max[size - 1] = height[size - 1];\n    for (int i = size - 2; i >= 0; i--) {\n        right_max[i] = max(height[i], right_max[i + 1]);\n    }\n    for (int i = 1; i < size - 1; i++) {\n        ans += min(left_max[i], right_max[i]) - height[i];\n    }\n    return ans;\n}"}, {"lang": "C++", "code": "int trap(vector<int>& height)\n{\n    int ans = 0, current = 0;\n    stack<int> st;\n    while (current < height.size()) {\n        while (!st.empty() && height[current] > height[st.top()]) {\n            int top = st.top();\n            st.pop();\n            if (st.empty())\n                break;\n            int distance = current - st.top() - 1;\n            int bounded_height = min(height[current], height[st.top()]) - height[top];\n            ans += distance * bounded_height;\n        }\n        st.push(current++);\n    }\n    return ans;\n}"}, {"lang": "C++", "code": "int trap(vector<int>& height)\n{\n    int left = 0, right = height.size() - 1;\n    int ans = 0;\n    int left_max = 0, right_max = 0;\n    while (left < right) {\n        if (height[left] < height[right]) {\n            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);\n            ++left;\n        }\n        else {\n            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);\n            --right;\n        }\n    }\n    return ans;\n}"}]}
{"url": "https://leetcode-cn.com/problems/multiply-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/wildcard-matching", "source": []}
{"url": "https://leetcode-cn.com/problems/jump-game-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/permutations", "source": [{"lang": "Java", "code": "class Solution {\n  public void backtrack(int n,\n                        ArrayList<Integer> nums,\n                        List<List<Integer>> output,\n                        int first) {\n    // if all integers are used up\n    if (first == n)\n      output.add(new ArrayList<Integer>(nums));\n    for (int i = first; i < n; i++) {\n      // place i-th integer first \n      // in the current permutation\n      Collections.swap(nums, first, i);\n      // use next integers to complete the permutations\n      backtrack(n, nums, output, first + 1);\n      // backtrack\n      Collections.swap(nums, first, i);\n    }\n  }\n\n  public List<List<Integer>> permute(int[] nums) {\n    // init output list\n    List<List<Integer>> output = new LinkedList();\n\n    // convert nums into list since the output is a list of lists\n    ArrayList<Integer> nums_lst = new ArrayList<Integer>();\n    for (int num : nums)\n      nums_lst.add(num);\n\n    int n = nums.length;\n    backtrack(n, nums_lst, output, 0);\n    return output;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}]}
{"url": "https://leetcode-cn.com/problems/permutations-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/rotate-image", "source": [{"lang": "Java", "code": "class Solution {\n  public void rotate(int[][] matrix) {\n    int n = matrix.length;\n\n    // transpose matrix\n    for (int i = 0; i < n; i++) {\n      for (int j = i; j < n; j++) {\n        int tmp = matrix[j][i];\n        matrix[j][i] = matrix[i][j];\n        matrix[i][j] = tmp;\n      }\n    }\n    // reverse each row\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n / 2; j++) {\n        int tmp = matrix[i][j];\n        matrix[i][j] = matrix[i][n - j - 1];\n        matrix[i][n - j - 1] = tmp;\n      }\n    }\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix[0])        \n        # transpose matrix\n        for i in range(n):\n            for j in range(i, n):\n                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i] \n        \n        # reverse each row\n        for i in range(n):\n            matrix[i].reverse()"}, {"lang": "Java", "code": "class Solution {\n  public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n / 2 + n % 2; i++) {\n      for (int j = 0; j < n / 2; j++) {\n        int[] tmp = new int[4];\n        int row = i;\n        int col = j;\n        for (int k = 0; k < 4; k++) {\n          tmp[k] = matrix[row][col];\n          int x = row;\n          row = col;\n          col = n - 1 - x;\n        }\n        for (int k = 0; k < 4; k++) {\n          matrix[row][col] = tmp[(k + 3) % 4];\n          int x = row;\n          row = col;\n          col = n - 1 - x;\n        }\n      }\n    }\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix[0])\n        for i in range(n // 2 + n % 2):\n            for j in range(n // 2):\n                tmp = [0] * 4\n                row, col = i, j\n                # store 4 elements in tmp\n                for k in range(4):\n                    tmp[k] = matrix[row][col]\n                    row, col = col, n - 1 - row\n                # rotate 4 elements   \n                for k in range(4):\n                    matrix[row][col] = tmp[(k - 1) % 4]\n                    row, col = col, n - 1 - row"}, {"lang": "Java", "code": "class Solution {\n  public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < (n + 1) / 2; i ++) {\n      for (int j = 0; j < n / 2; j++) {\n        int temp = matrix[n - 1 - j][i];\n        matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\n        matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\n        matrix[j][n - 1 - i] = matrix[i][j];\n        matrix[i][j] = temp;\n      }\n    }\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix[0])        \n        for i in range(n // 2 + n % 2):\n            for j in range(n // 2):\n                tmp = matrix[n - 1 - j][i]\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1]\n                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i]\n                matrix[j][n - 1 - i] = matrix[i][j]\n                matrix[i][j] = tmp"}]}
{"url": "https://leetcode-cn.com/problems/group-anagrams", "source": [{"lang": "Java", "code": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if (strs.length == 0) return new ArrayList();\n        Map<String, List> ans = new HashMap<String, List>();\n        for (String s : strs) {\n            char[] ca = s.toCharArray();\n            Arrays.sort(ca);\n            String key = String.valueOf(ca);\n            if (!ans.containsKey(key)) ans.put(key, new ArrayList());\n            ans.get(key).add(s);\n        }\n        return new ArrayList(ans.values());\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def groupAnagrams(self, strs):\n        ans = collections.defaultdict(list)\n        for s in strs:\n            ans[tuple(sorted(s))].append(s)\n        return ans.values()"}, {"lang": "Java", "code": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if (strs.length == 0) return new ArrayList();\n        Map<String, List> ans = new HashMap<String, List>();\n        int[] count = new int[26];\n        for (String s : strs) {\n            Arrays.fill(count, 0);\n            for (char c : s.toCharArray()) count[c - 'a']++;\n\n            StringBuilder sb = new StringBuilder(\"\");\n            for (int i = 0; i < 26; i++) {\n                sb.append('#');\n                sb.append(count[i]);\n            }\n            String key = sb.toString();\n            if (!ans.containsKey(key)) ans.put(key, new ArrayList());\n            ans.get(key).add(s);\n        }\n        return new ArrayList(ans.values());\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def groupAnagrams(strs):\n        ans = collections.defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            ans[tuple(count)].append(s)\n        return ans.values()"}]}
{"url": "https://leetcode-cn.com/problems/powx-n", "source": []}
{"url": "https://leetcode-cn.com/problems/n-queens", "source": []}
{"url": "https://leetcode-cn.com/problems/n-queens-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-subarray", "source": [{"lang": "Java", "code": "class Solution:\n    def cross_sum(self, nums, left, right, p): \n            if left == right:\n                return nums[left]\n\n            left_subsum = float('-inf')\n            curr_sum = 0\n            for i in range(p, left - 1, -1):\n                curr_sum += nums[i]\n                left_subsum = max(left_subsum, curr_sum)\n\n            right_subsum = float('-inf')\n            curr_sum = 0\n            for i in range(p + 1, right + 1):\n                curr_sum += nums[i]\n                right_subsum = max(right_subsum, curr_sum)\n\n            return left_subsum + right_subsum   \n    \n    def helper(self, nums, left, right): \n        if left == right:\n            return nums[left]\n        \n        p = (left + right) // 2\n            \n        left_sum = self.helper(nums, left, p)\n        right_sum = self.helper(nums, p + 1, right)\n        cross_sum = self.cross_sum(nums, left, right, p)\n        \n        return max(left_sum, right_sum, cross_sum)\n        \n    def maxSubArray(self, nums: 'List[int]') -> 'int':\n        return self.helper(nums, 0, len(nums) - 1)"}, {"lang": "python", "code": "class Solution {\n  public int crossSum(int[] nums, int left, int right, int p) {\n    if (left == right) return nums[left];\n\n    int leftSubsum = Integer.MIN_VALUE;\n    int currSum = 0;\n    for(int i = p; i > left - 1; --i) {\n      currSum += nums[i];\n      leftSubsum = Math.max(leftSubsum, currSum);\n    }\n\n    int rightSubsum = Integer.MIN_VALUE;\n    currSum = 0;\n    for(int i = p + 1; i < right + 1; ++i) {\n      currSum += nums[i];\n      rightSubsum = Math.max(rightSubsum, currSum);\n    }\n\n    return leftSubsum + rightSubsum;\n  }\n\n  public int helper(int[] nums, int left, int right) {\n    if (left == right) return nums[left];\n\n    int p = (left + right) / 2;\n\n    int leftSum = helper(nums, left, p);\n    int rightSum = helper(nums, p + 1, right);\n    int crossSum = crossSum(nums, left, right, p);\n\n    return Math.max(Math.max(leftSum, rightSum), crossSum);\n  }\n\n  public int maxSubArray(int[] nums) {\n    return helper(nums, 0, nums.length - 1);\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def maxSubArray(self, nums: 'List[int]') -> 'int':\n        n = len(nums)\n        curr_sum = max_sum = nums[0]\n\n        for i in range(1, n):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"lang": "Java", "code": "class Solution {\n  public int maxSubArray(int[] nums) {\n    int n = nums.length;\n    int currSum = nums[0], maxSum = nums[0];\n\n    for(int i = 1; i < n; ++i) {\n      currSum = Math.max(nums[i], currSum + nums[i]);\n      maxSum = Math.max(maxSum, currSum);\n    }\n    return maxSum;\n  }\n}"}, {"lang": "Java", "code": "class Solution:\n    def maxSubArray(self, nums: 'List[int]') -> 'int':\n        n = len(nums)\n        max_sum = nums[0]\n        for i in range(1, n):\n            if nums[i - 1] > 0:\n                nums[i] += nums[i - 1] \n            max_sum = max(nums[i], max_sum)\n\n        return max_sum"}, {"lang": "Python", "code": "class Solution {\n  public int maxSubArray(int[] nums) {\n    int n = nums.length, maxSum = nums[0];\n    for(int i = 1; i < n; ++i) {\n      if (nums[i - 1] > 0) nums[i] += nums[i - 1];\n      maxSum = Math.max(nums[i], maxSum);\n    }\n    return maxSum;\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/spiral-matrix", "source": [{"lang": "Java", "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List ans = new ArrayList();\n        if (matrix.length == 0) return ans;\n        int R = matrix.length, C = matrix[0].length;\n        boolean[][] seen = new boolean[R][C];\n        int[] dr = {0, 1, 0, -1};\n        int[] dc = {1, 0, -1, 0};\n        int r = 0, c = 0, di = 0;\n        for (int i = 0; i < R * C; i++) {\n            ans.add(matrix[r][c]);\n            seen[r][c] = true;\n            int cr = r + dr[di];\n            int cc = c + dc[di];\n            if (0 <= cr && cr < R && 0 <= cc && cc < C && !seen[cr][cc]){\n                r = cr;\n                c = cc;\n            } else {\n                di = (di + 1) % 4;\n                r += dr[di];\n                c += dc[di];\n            }\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        if not matrix: return []\n        R, C = len(matrix), len(matrix[0])\n        seen = [[False] * C for _ in matrix]\n        ans = []\n        dr = [0, 1, 0, -1]\n        dc = [1, 0, -1, 0]\n        r = c = di = 0\n        for _ in range(R * C):\n            ans.append(matrix[r][c])\n            seen[r][c] = True\n            cr, cc = r + dr[di], c + dc[di]\n            if 0 <= cr < R and 0 <= cc < C and not seen[cr][cc]:\n                r, c = cr, cc\n            else:\n                di = (di + 1) % 4\n                r, c = r + dr[di], c + dc[di]\n        return ans"}, {"lang": "Java", "code": "[[1, 1, 1, 1, 1, 1, 1],\n [1, 2, 2, 2, 2, 2, 1],\n [1, 2, 3, 3, 3, 2, 1],\n [1, 2, 2, 2, 2, 2, 1],\n [1, 1, 1, 1, 1, 1, 1]]"}, {"lang": "Python", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/jump-game", "source": [{"lang": "Java", "code": "public class Solution {\n    public boolean canJumpFromPosition(int position, int[] nums) {\n        if (position == nums.length - 1) {\n            return true;\n        }\n\n        int furthestJump = Math.min(position + nums[position], nums.length - 1);\n        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {\n            if (canJumpFromPosition(nextPosition, nums)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean canJump(int[] nums) {\n        return canJumpFromPosition(0, nums);\n    }\n}"}, {"lang": "Java", "code": "// Old\nfor (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++)\n// New\nfor (int nextPosition = furthestJump; nextPosition > position; nextPosition--)"}, {"lang": "Java", "code": "enum Index {\n    GOOD, BAD, UNKNOWN\n}\n\npublic class Solution {\n    Index[] memo;\n\n    public boolean canJumpFromPosition(int position, int[] nums) {\n        if (memo[position] != Index.UNKNOWN) {\n            return memo[position] == Index.GOOD ? true : false;\n        }\n\n        int furthestJump = Math.min(position + nums[position], nums.length - 1);\n        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {\n            if (canJumpFromPosition(nextPosition, nums)) {\n                memo[position] = Index.GOOD;\n                return true;\n            }\n        }\n\n        memo[position] = Index.BAD;\n        return false;\n    }\n\n    public boolean canJump(int[] nums) {\n        memo = new Index[nums.length];\n        for (int i = 0; i < memo.length; i++) {\n            memo[i] = Index.UNKNOWN;\n        }\n        memo[memo.length - 1] = Index.GOOD;\n        return canJumpFromPosition(0, nums);\n    }\n}"}, {"lang": "Java", "code": "enum Index {\n    GOOD, BAD, UNKNOWN\n}\n\npublic class Solution {\n    public boolean canJump(int[] nums) {\n        Index[] memo = new Index[nums.length];\n        for (int i = 0; i < memo.length; i++) {\n            memo[i] = Index.UNKNOWN;\n        }\n        memo[memo.length - 1] = Index.GOOD;\n\n        for (int i = nums.length - 2; i >= 0; i--) {\n            int furthestJump = Math.min(i + nums[i], nums.length - 1);\n            for (int j = i + 1; j <= furthestJump; j++) {\n                if (memo[j] == Index.GOOD) {\n                    memo[i] = Index.GOOD;\n                    break;\n                }\n            }\n        }\n\n        return memo[0] == Index.GOOD;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean canJump(int[] nums) {\n        int lastPos = nums.length - 1;\n        for (int i = nums.length - 1; i >= 0; i--) {\n            if (i + nums[i] >= lastPos) {\n                lastPos = i;\n            }\n        }\n        return lastPos == 0;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/merge-intervals", "source": [{"lang": "Java", "code": "class Solution {\n    private Map<Interval, List<Interval> > graph;\n    private Map<Integer, List<Interval> > nodesInComp;\n    private Set<Interval> visited;\n\n    // return whether two intervals overlap (inclusive)\n    private boolean overlap(Interval a, Interval b) {\n        return a.start <= b.end && b.start <= a.end;\n    }\n\n    // build a graph where an undirected edge between intervals u and v exists\n    // iff u and v overlap.\n    private void buildGraph(List<Interval> intervals) {\n        graph = new HashMap<>();\n        for (Interval interval : intervals) {\n            graph.put(interval, new LinkedList<>());\n        }\n\n        for (Interval interval1 : intervals) {\n            for (Interval interval2 : intervals) {\n                if (overlap(interval1, interval2)) {\n                    graph.get(interval1).add(interval2);\n                    graph.get(interval2).add(interval1);\n                }\n            }\n        }\n    }\n\n    // merges all of the nodes in this connected component into one interval.\n    private Interval mergeNodes(List<Interval> nodes) {\n        int minStart = nodes.get(0).start;\n        for (Interval node : nodes) {\n            minStart = Math.min(minStart, node.start);\n        }\n\n        int maxEnd = nodes.get(0).end;\n        for (Interval node : nodes) {\n            maxEnd= Math.max(maxEnd, node.end);\n        }\n\n        return new Interval(minStart, maxEnd);\n    }\n\n    // use depth-first search to mark all nodes in the same connected component\n    // with the same integer.\n    private void markComponentDFS(Interval start, int compNumber) {\n        Stack<Interval> stack = new Stack<>();\n        stack.add(start);\n\n        while (!stack.isEmpty()) {\n            Interval node = stack.pop();\n            if (!visited.contains(node)) {\n                visited.add(node);\n\n                if (nodesInComp.get(compNumber) == null) {\n                    nodesInComp.put(compNumber, new LinkedList<>());\n                }\n                nodesInComp.get(compNumber).add(node);\n\n                for (Interval child : graph.get(node)) {\n                    stack.add(child);\n                }\n            }\n        }\n    }\n\n    // gets the connected components of the interval overlap graph.\n    private void buildComponents(List<Interval> intervals) {\n        nodesInComp = new HashMap();\n        visited = new HashSet();\n        int compNumber = 0;\n\n        for (Interval interval : intervals) {\n            if (!visited.contains(interval)) {\n                markComponentDFS(interval, compNumber);\n                compNumber++;\n            }\n        }\n    }\n\n    public List<Interval> merge(List<Interval> intervals) {\n        buildGraph(intervals);\n        buildComponents(intervals);\n\n        // for each component, merge all intervals into one interval.\n        List<Interval> merged = new LinkedList<>();\n        for (int comp = 0; comp < nodesInComp.size(); comp++) {\n            merged.add(mergeNodes(nodesInComp.get(comp)));\n        }\n\n        return merged;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def overlap(self, a, b):\n        return a.start <= b.end and b.start <= a.end\n\n    # generate graph where there is an undirected edge between intervals u\n    # and v iff u and v overlap.\n    def build_graph(self, intervals):\n        graph = collections.defaultdict(list)\n\n        for i, interval_i in enumerate(intervals):\n            for j in range(i+1, len(intervals)):\n                if self.overlap(interval_i, intervals[j]):\n                    graph[interval_i].append(intervals[j])\n                    graph[intervals[j]].append(interval_i)\n\n        return graph\n\n    # merges all of the nodes in this connected component into one interval.\n    def merge_nodes(self, nodes):\n        min_start = min(node.start for node in nodes)\n        max_end = max(node.end for node in nodes)\n        return Interval(min_start, max_end)\n\n    # gets the connected components of the interval overlap graph.\n    def get_components(self, graph, intervals):\n        visited = set()\n        comp_number = 0\n        nodes_in_comp = collections.defaultdict(list)\n\n        def mark_component_dfs(start):\n            stack = [start]\n            while stack:\n                node = stack.pop()\n                if node not in visited:\n                    visited.add(node)\n                    nodes_in_comp[comp_number].append(node)\n                    stack.extend(graph[node])\n\n        # mark all nodes in the same connected component with the same integer.\n        for interval in intervals:\n            if interval not in visited:\n                mark_component_dfs(interval)\n                comp_number += 1\n\n        return nodes_in_comp, comp_number\n\n    def merge(self, intervals):\n        graph = self.build_graph(intervals)\n        nodes_in_comp, number_of_comps = self.get_components(graph, intervals)\n\n        # all intervals in each connected component must be merged.\n        return [self.merge_nodes(nodes_in_comp[comp]) for comp in range(number_of_comps)]"}, {"lang": "Java", "code": "class Solution {\n    private class IntervalComparator implements Comparator<Interval> {\n        @Override\n        public int compare(Interval a, Interval b) {\n            return a.start < b.start ? -1 : a.start == b.start ? 0 : 1;\n        }\n    }\n\n    public List<Interval> merge(List<Interval> intervals) {\n        Collections.sort(intervals, new IntervalComparator());\n\n        LinkedList<Interval> merged = new LinkedList<Interval>();\n        for (Interval interval : intervals) {\n            // if the list of merged intervals is empty or if the current\n            // interval does not overlap with the previous, simply append it.\n            if (merged.isEmpty() || merged.getLast().end < interval.start) {\n                merged.add(interval);\n            }\n            // otherwise, there is overlap, so we merge the current and previous\n            // intervals.\n            else {\n                merged.getLast().end = Math.max(merged.getLast().end, interval.end);\n            }\n        }\n\n        return merged;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def merge(self, intervals):\n        intervals.sort(key=lambda x: x.start)\n\n        merged = []\n        for interval in intervals:\n            # if the list of merged intervals is empty or if the current\n            # interval does not overlap with the previous, simply append it.\n            if not merged or merged[-1].end < interval.start:\n                merged.append(interval)\n            else:\n            # otherwise, there is overlap, so we merge the current and previous\n            # intervals.\n                merged[-1].end = max(merged[-1].end, interval.end)\n\n        return merged"}]}
{"url": "https://leetcode-cn.com/problems/insert-interval", "source": [{"lang": "Python", "code": "class Solution:\n    def insert(self, intervals: 'List[Interval]', newInterval: 'Interval') -> 'List[Interval]':\n        # init data\n        new_start, new_end = newInterval\n        idx, n = 0, len(intervals)\n        output = []\n        \n        # add all intervals starting before newInterval\n        while idx < n and new_start > intervals[idx][0]:\n            output.append(intervals[idx])\n            idx += 1\n            \n        # add newInterval\n        # if there is no overlap, just add the interval\n        if not output or output[-1][1] < new_start:\n            output.append(newInterval)\n        # if there is an overlap, merge with the last interval\n        else:\n            output[-1][1] = max(output[-1][1], new_end)\n        \n        # add next intervals, merge with newInterval if needed\n        while idx < n:\n            interval = intervals[idx]\n            start, end = interval\n            idx += 1\n            # if there is no overlap, just add an interval\n            if output[-1][1] < start:\n                output.append(interval)\n            # if there is an overlap, merge with the last interval\n            else:\n                output[-1][1] = max(output[-1][1], end)\n        return output"}, {"lang": "Java", "code": "class Solution {\n  public int[][] insert(int[][] intervals, int[] newInterval) {\n    // init data\n    int newStart = newInterval[0], newEnd = newInterval[1];\n    int idx = 0, n = intervals.length;\n    LinkedList<int[]> output = new LinkedList<int[]>();\n\n    // add all intervals starting before newInterval\n    while (idx < n && newStart > intervals[idx][0])\n      output.add(intervals[idx++]);\n\n    // add newInterval\n    int[] interval = new int[2];\n    // if there is no overlap, just add the interval\n    if (output.isEmpty() || output.getLast()[1] < newStart)\n      output.add(newInterval);\n    // if there is an overlap, merge with the last interval\n    else {\n      interval = output.removeLast();\n      interval[1] = Math.max(interval[1], newEnd);\n      output.add(interval);\n    }\n\n    // add next intervals, merge with newInterval if needed\n    while (idx < n) {\n      interval = intervals[idx++];\n      int start = interval[0], end = interval[1];\n      // if there is no overlap, just add an interval\n      if (output.getLast()[1] < start) output.add(interval);\n      // if there is an overlap, merge with the last interval\n      else {\n        interval = output.removeLast();\n        interval[1] = Math.max(interval[1], end);\n        output.add(interval);\n      }\n    }\n    return output.toArray(new int[output.size()][2]);\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/length-of-last-word", "source": []}
{"url": "https://leetcode-cn.com/problems/spiral-matrix-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/permutation-sequence", "source": []}
{"url": "https://leetcode-cn.com/problems/rotate-list", "source": [{"lang": "Java", "code": "class Solution {\n  public ListNode rotateRight(ListNode head, int k) {\n    // base cases\n    if (head == null) return null;\n    if (head.next == null) return head;\n\n    // close the linked list into the ring\n    ListNode old_tail = head;\n    int n;\n    for(n = 1; old_tail.next != null; n++)\n      old_tail = old_tail.next;\n    old_tail.next = head;\n\n    // find new tail : (n - k % n - 1)th node\n    // and new head : (n - k % n)th node\n    ListNode new_tail = head;\n    for (int i = 0; i < n - k % n - 1; i++)\n      new_tail = new_tail.next;\n    ListNode new_head = new_tail.next;\n\n    // break the ring\n    new_tail.next = null;\n\n    return new_head;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\n        # base cases\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        # close the linked list into the ring\n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n        \n        # find new tail : (n - k % n - 1)th node\n        # and new head : (n - k % n)th node\n        new_tail = head\n        for i in range(n - k % n - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n        # break the ring\n        new_tail.next = None\n        \n        return new_head"}]}
{"url": "https://leetcode-cn.com/problems/unique-paths", "source": []}
{"url": "https://leetcode-cn.com/problems/unique-paths-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-path-sum", "source": [{"lang": "Java", "code": "public class Solution {\n    public int calculate(int[][] grid, int i, int j) {\n        if (i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;\n        if (i == grid.length - 1 && j == grid[0].length - 1) return grid[i][j];\n        return grid[i][j] + Math.min(calculate(grid, i + 1, j), calculate(grid, i, j + 1));\n    }\n    public int minPathSum(int[][] grid) {\n        return calculate(grid, 0, 0);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int minPathSum(int[][] grid) {\n        int[][] dp = new int[grid.length][grid[0].length];\n        for (int i = grid.length - 1; i >= 0; i--) {\n            for (int j = grid[0].length - 1; j >= 0; j--) {\n                if(i == grid.length - 1 && j != grid[0].length - 1)\n                    dp[i][j] = grid[i][j] +  dp[i][j + 1];\n                else if(j == grid[0].length - 1 && i != grid.length - 1)\n                    dp[i][j] = grid[i][j] + dp[i + 1][j];\n                else if(j != grid[0].length - 1 && i != grid.length - 1)\n                    dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);\n                else\n                    dp[i][j] = grid[i][j];\n            }\n        }\n        return dp[0][0];\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n   public int minPathSum(int[][] grid) {\n       int[] dp = new int[grid[0].length];\n       for (int i = grid.length - 1; i >= 0; i--) {\n           for (int j = grid[0].length - 1; j >= 0; j--) {\n               if(i == grid.length - 1 && j != grid[0].length - 1)\n                   dp[j] = grid[i][j] +  dp[j + 1];\n               else if(j == grid[0].length - 1 && i != grid.length - 1)\n                   dp[j] = grid[i][j] + dp[j];\n               else if(j != grid[0].length - 1 && i != grid.length - 1)\n                   dp[j] = grid[i][j] + Math.min(dp[j], dp[j + 1]);\n               else\n                   dp[j] = grid[i][j];\n           }\n       }\n       return dp[0];\n   }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int minPathSum(int[][] grid) {\n        for (int i = grid.length - 1; i >= 0; i--) {\n            for (int j = grid[0].length - 1; j >= 0; j--) {\n                if(i == grid.length - 1 && j != grid[0].length - 1)\n                    grid[i][j] = grid[i][j] +  grid[i][j + 1];\n                else if(j == grid[0].length - 1 && i != grid.length - 1)\n                    grid[i][j] = grid[i][j] + grid[i + 1][j];\n                else if(j != grid[0].length - 1 && i != grid.length - 1)\n                    grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j],grid[i][j + 1]);\n            }\n        }\n        return grid[0][0];\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/valid-number", "source": []}
{"url": "https://leetcode-cn.com/problems/plus-one", "source": []}
{"url": "https://leetcode-cn.com/problems/add-binary", "source": []}
{"url": "https://leetcode-cn.com/problems/text-justification", "source": []}
{"url": "https://leetcode-cn.com/problems/sqrtx", "source": []}
{"url": "https://leetcode-cn.com/problems/climbing-stairs", "source": [{"lang": "Java", "code": "public class Solution {\n    public int climbStairs(int n) {\n        climb_Stairs(0, n);\n    }\n    public int climb_Stairs(int i, int n) {\n        if (i > n) {\n            return 0;\n        }\n        if (i == n) {\n            return 1;\n        }\n        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int climbStairs(int n) {\n        int memo[] = new int[n + 1];\n        return climb_Stairs(0, n, memo);\n    }\n    public int climb_Stairs(int i, int n, int memo[]) {\n        if (i > n) {\n            return 0;\n        }\n        if (i == n) {\n            return 1;\n        }\n        if (memo[i] > 0) {\n            return memo[i];\n        }\n        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);\n        return memo[i];\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int climbStairs(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int climbStairs(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        int first = 1;\n        int second = 2;\n        for (int i = 3; i <= n; i++) {\n            int third = first + second;\n            first = second;\n            second = third;\n        }\n        return second;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n   public int climbStairs(int n) {\n       int[][] q = {{1, 1}, {1, 0}};\n       int[][] res = pow(q, n);\n       return res[0][0];\n   }\n   public int[][] pow(int[][] a, int n) {\n       int[][] ret = {{1, 0}, {0, 1}};\n       while (n > 0) {\n           if ((n & 1) == 1) {\n               ret = multiply(ret, a);\n           }\n           n >>= 1;\n           a = multiply(a, a);\n       }\n       return ret;\n   }\n   public int[][] multiply(int[][] a, int[][] b) {\n       int[][] c = new int[2][2];\n       for (int i = 0; i < 2; i++) {\n           for (int j = 0; j < 2; j++) {\n               c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n           }\n       }\n       return c;\n   }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int climbStairs(int n) {\n        double sqrt5=Math.sqrt(5);\n        double fibn=Math.pow((1+sqrt5)/2,n+1)-Math.pow((1-sqrt5)/2,n+1);\n        return (int)(fibn/sqrt5);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/simplify-path", "source": []}
{"url": "https://leetcode-cn.com/problems/edit-distance", "source": []}
{"url": "https://leetcode-cn.com/problems/set-matrix-zeroes", "source": [{"lang": "Java", "code": "if cell[i][j] == 0 {\n    row_set.add(i)\n    column_set.add(j)\n}"}, {"lang": "Python", "code": "if r in row_set or c in column_set {\n    cell[r][c] = 0\n}"}, {"lang": "Java", "code": ""}, {"lang": "Python", "code": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        R = len(matrix)\n        C = len(matrix[0])\n        rows, cols = set(), set()\n\n        # Essentially, we mark the rows and columns that are to be made zero\n        for i in range(R):\n            for j in range(C):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n\n        # Iterate over the array once again and using the rows and cols sets, update the elements\n        for i in range(R):\n            for j in range(C):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0"}, {"lang": "Java", "code": ""}, {"lang": "Python", "code": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        MODIFIED = -1000000\n        R = len(matrix)\n        C = len(matrix[0])\n        for r in range(R):\n            for c in range(C):\n                if matrix[r][c] == 0:\n                    # We modify the elements in place. Note, we only change the non zeros to MODIFIED\n                    for k in range(C):\n                        matrix[r][k] = MODIFIED if matrix[r][k] != 0 else 0\n                    for k in range(R):\n                        matrix[k][c] = MODIFIED if matrix[k][c] != 0 else 0\n        for r in range(R):\n            for c in range(C):\n                # Make a second pass and change all MODIFIED elements to 0 \"\"\"\n                if matrix[r][c] == MODIFIED:\n                    matrix[r][c] = 0"}]}
{"url": "https://leetcode-cn.com/problems/search-a-2d-matrix", "source": [{"lang": "Java", "code": "class Solution {\n  public boolean searchMatrix(int[][] matrix, int target) {\n    int m = matrix.length;\n    if (m == 0) return false;\n    int n = matrix[0].length;\n\n    // 二分查找\n    int left = 0, right = m * n - 1;\n    int pivotIdx, pivotElement;\n    while (left <= right) {\n      pivotIdx = (left + right) / 2;\n      pivotElement = matrix[pivotIdx / n][pivotIdx % n];\n      if (target == pivotElement) return true;\n      else {\n        if (target < pivotElement) right = pivotIdx - 1;\n        else left = pivotIdx + 1;\n      }\n    }\n    return false;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m = len(matrix)\n        if m == 0:\n            return False\n        n = len(matrix[0])\n        \n        #二分查找\n        left, right = 0, m * n - 1\n        while left <= right:\n                pivot_idx = (left + right) // 2\n                pivot_element = matrix[pivot_idx // n][pivot_idx % n]\n                if target == pivot_element:\n                    return True\n                else:\n                    if target < pivot_element:\n                        right = pivot_idx - 1\n                    else:\n                        left = pivot_idx + 1\n        return False"}, {"lang": "C++", "code": "class Solution {\n  public:\n  bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int m = matrix.size();\n    if (m == 0) return false;\n    int n = matrix[0].size();\n\n    // 二分查找\n    int left = 0, right = m * n - 1;\n    int pivotIdx, pivotElement;\n    while (left <= right) {\n      pivotIdx = (left + right) / 2;\n      pivotElement = matrix[pivotIdx / n][pivotIdx % n];\n      if (target == pivotElement) return true;\n      else {\n        if (target < pivotElement) right = pivotIdx - 1;\n        else left = pivotIdx + 1;\n      }\n    }\n    return false;\n  }\n};"}]}
{"url": "https://leetcode-cn.com/problems/sort-colors", "source": [{"lang": "Java", "code": "class Solution {\n  /*\n  荷兰三色旗问题解\n  */\n  public void sortColors(int[] nums) {\n    // 对于所有 idx < i : nums[idx < i] = 0\n    // j是当前考虑元素的下标\n    int p0 = 0, curr = 0;\n    // 对于所有 idx > k : nums[idx > k] = 2\n    int p2 = nums.length - 1;\n\n    int tmp;\n    while (curr <= p2) {\n      if (nums[curr] == 0) {\n        // 交换第 p0个和第curr个元素\n        // i++，j++\n        tmp = nums[p0];\n        nums[p0++] = nums[curr];\n        nums[curr++] = tmp;\n      }\n      else if (nums[curr] == 2) {\n        // 交换第k个和第curr个元素\n        // p2--\n        tmp = nums[curr];\n        nums[curr] = nums[p2];\n        nums[p2--] = tmp;\n      }\n      else curr++;\n    }\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        '''\n        荷兰三色旗问题解\n        '''\n        # 对于所有 idx < p0 : nums[idx < p0] = 0\n        # curr是当前考虑元素的下标\n        p0 = curr = 0\n        # 对于所有 idx > p2 : nums[idx > p2] = 2\n        p2 = len(nums) - 1\n\n        while curr <= p2:\n            if nums[curr] == 0:\n                nums[p0], nums[curr] = nums[curr], nums[p0]\n                p0 += 1\n                curr += 1\n            elif nums[curr] == 2:\n                nums[curr], nums[p2] = nums[p2], nums[curr]\n                p2 -= 1\n            else:\n                curr += 1"}, {"lang": "C++", "code": "class Solution {\n  public:\n  /*\n  荷兰三色旗问题解\n  */\n  void sortColors(vector<int>& nums) {\n    // 对于所有 idx < p0 : nums[idx < p0] = 0\n    // curr 是当前考虑元素的下标\n    int p0 = 0, curr = 0;\n    // 对于所有 idx > p2 : nums[idx > p2] = 2\n    int p2 = nums.size() - 1;\n\n    while (curr <= p2) {\n      if (nums[curr] == 0) {\n        swap(nums[curr++], nums[p0++]);\n      }\n      else if (nums[curr] == 2) {\n        swap(nums[curr], nums[p2--]);\n      }\n      else curr++;\n    }\n  }\n};"}]}
{"url": "https://leetcode-cn.com/problems/minimum-window-substring", "source": []}
{"url": "https://leetcode-cn.com/problems/combinations", "source": [{"lang": "Python", "code": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        def backtrack(first = 1, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n            for i in range(first, n + 1):\n                # add i into the current combination\n                curr.append(i)\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        backtrack()\n        return output"}, {"lang": "Java", "code": "class Solution {\n  List<List<Integer>> output = new LinkedList();\n  int n;\n  int k;\n\n  public void backtrack(int first, LinkedList<Integer> curr) {\n    // if the combination is done\n    if (curr.size() == k)\n      output.add(new LinkedList(curr));\n\n    for (int i = first; i < n + 1; ++i) {\n      // add i into the current combination\n      curr.add(i);\n      // use next integers to complete the combination\n      backtrack(i + 1, curr);\n      // backtrack\n      curr.removeLast();\n    }\n  }\n\n  public List<List<Integer>> combine(int n, int k) {\n    this.n = n;\n    this.k = k;\n    backtrack(1, new LinkedList<Integer>());\n    return output;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        # init first combination\n        nums = list(range(1, k + 1)) + [n + 1]\n        \n        output, j = [], 0\n        while j < k:\n            # add current combination\n            output.append(nums[:k])\n            # increase first nums[j] by one\n            # if nums[j] + 1 != nums[j + 1]\n            j = 0\n            while j < k and nums[j + 1] == nums[j] + 1:\n                nums[j] = j + 1\n                j += 1\n            nums[j] += 1\n            \n        return output"}, {"lang": "Java", "code": "class Solution {\n  public List<List<Integer>> combine(int n, int k) {\n    // init first combination\n    LinkedList<Integer> nums = new LinkedList<Integer>();\n    for(int i = 1; i < k + 1; ++i)\n      nums.add(i);\n    nums.add(n + 1);\n\n    List<List<Integer>> output = new ArrayList<List<Integer>>();\n    int j = 0;\n    while (j < k) {\n      // add current combination\n      output.add(new LinkedList(nums.subList(0, k)));\n      // increase first nums[j] by one\n      // if nums[j] + 1 != nums[j + 1]\n      j = 0;\n      while ((j < k) && (nums.get(j + 1) == nums.get(j) + 1))\n        nums.set(j, j++ + 1);\n      nums.set(j, nums.get(j) + 1);\n    }\n    return output;\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/subsets", "source": []}
{"url": "https://leetcode-cn.com/problems/word-search", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list", "source": []}
{"url": "https://leetcode-cn.com/problems/largest-rectangle-in-histogram", "source": [{"lang": "Java", "code": "public class Solution {\n   public int largestRectangleArea(int[] heights) {\n       int maxarea = 0;\n       for (int i = 0; i < heights.length; i++) {\n           for (int j = i; j < heights.length; j++) {\n               int minheight = Integer.MAX_VALUE;\n               for (int k = i; k <= j; k++)\n                   minheight = Math.min(minheight, heights[k]);\n               maxarea = Math.max(maxarea, minheight * (j - i + 1));\n           }\n       }\n       return maxarea;\n   }\n}"}, {"lang": "Java", "code": "public class Solution {\n   public int largestRectangleArea(int[] heights) {\n       int maxarea = 0;\n       for (int i = 0; i < heights.length; i++) {\n           int minheight = Integer.MAX_VALUE;\n           for (int j = i; j < heights.length; j++) {\n               minheight = Math.min(minheight, heights[j]);\n               maxarea = Math.max(maxarea, minheight * (j - i + 1));\n           }\n       }\n       return maxarea;\n   }\n}"}, {"lang": "Java", "code": "[6, 4, 5, 2, 4, 3, 9]"}, {"lang": "Java", "code": "public class Solution {\n    public int calculateArea(int[] heights, int start, int end) {\n        if (start > end)\n            return 0;\n        int minindex = start;\n        for (int i = start; i <= end; i++)\n            if (heights[minindex] > heights[i])\n                minindex = i;\n        return Math.max(heights[minindex] * (end - start + 1), Math.max(calculateArea(heights, start, minindex - 1), calculateArea(heights, minindex + 1, end)));\n    }\n    public int largestRectangleArea(int[] heights) {\n        return calculateArea(heights, 0, heights.length - 1);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/maximal-rectangle", "source": [{"lang": "Python", "code": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        maxarea = 0\n\n        dp = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == '0': continue\n\n                # compute the maximum width and update dp with it\n                width = dp[i][j] = dp[i][j-1] + 1 if j else 1\n\n                # compute the maximum area rectangle with a lower right corner at [i, j]\n                for k in range(i, -1, -1):\n                    width = min(width, dp[k][j])\n                    maxarea = max(maxarea, width * (i-k+1))\n        return maxarea"}, {"lang": "Java", "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n\n        if (matrix.length == 0) return 0;\n        int maxarea = 0;\n        int[][] dp = new int[matrix.length][matrix[0].length];\n\n        for(int i = 0; i < matrix.length; i++){\n            for(int j = 0; j < matrix[0].length; j++){\n                if (matrix[i][j] == '1'){\n\n                    // compute the maximum width and update dp with it\n                    dp[i][j] = j == 0? 1 : dp[i][j-1] + 1;\n\n                    int width = dp[i][j];\n\n                    // compute the maximum area rectangle with a lower right corner at [i, j]\n                    for(int k = i; k >= 0; k--){\n                        width = Math.min(width, dp[k][j]);\n                        maxarea = Math.max(maxarea, width * (i - k + 1));\n                    }\n                }\n            }\n        } return maxarea;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n\n    # Get the maximum area in a histogram given its heights\n    def leetcode84(self, heights):\n        stack = [-1]\n\n        maxarea = 0\n        for i in range(len(heights)):\n\n            while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n                maxarea = max(maxarea, heights[stack.pop()] * (i - stack[-1] - 1))\n            stack.append(i)\n\n        while stack[-1] != -1:\n            maxarea = max(maxarea, heights[stack.pop()] * (len(heights) - stack[-1] - 1))\n        return maxarea\n\n\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n\n        if not matrix: return 0\n\n        maxarea = 0\n        dp = [0] * len(matrix[0])\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n\n                # update the state of this row's histogram using the last row's histogram\n                # by keeping track of the number of consecutive ones\n\n                dp[j] = dp[j] + 1 if matrix[i][j] == '1' else 0\n\n            # update maxarea with the maximum area from this row's histogram\n            maxarea = max(maxarea, self.leetcode84(dp))\n        return maxarea"}, {"lang": "Java", "code": "class Solution {\n\n    // Get the maximum area in a histogram given its heights\n    public int leetcode84(int[] heights) {\n        Stack < Integer > stack = new Stack < > ();\n        stack.push(-1);\n        int maxarea = 0;\n        for (int i = 0; i < heights.length; ++i) {\n            while (stack.peek() != -1 && heights[stack.peek()] >= heights[i])\n                maxarea = Math.max(maxarea, heights[stack.pop()] * (i - stack.peek() - 1));\n            stack.push(i);\n        }\n        while (stack.peek() != -1)\n            maxarea = Math.max(maxarea, heights[stack.pop()] * (heights.length - stack.peek() -1));\n        return maxarea;\n    }\n\n    public int maximalRectangle(char[][] matrix) {\n\n        if (matrix.length == 0) return 0;\n        int maxarea = 0;\n        int[] dp = new int[matrix[0].length];\n\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n\n                // update the state of this row's histogram using the last row's histogram\n                // by keeping track of the number of consecutive ones\n\n                dp[j] = matrix[i][j] == '1' ? dp[j] + 1 : 0;\n            }\n            // update maxarea with the maximum area from this row's histogram\n            maxarea = Math.max(maxarea, leetcode84(dp));\n        } return maxarea;\n    }\n}"}, {"lang": "Python", "code": "row[j] = row[j - 1] + 1 if row[j] == '1'"}, {"lang": "Java", "code": "new_height[j] = old_height[j] + 1 if row[j] == '1' else 0"}]}
{"url": "https://leetcode-cn.com/problems/partition-list", "source": [{"lang": "Java", "code": "*`注意:` 由于我们从左到右遍历了原有链表，故两个链表中元素的相对顺序不会发生变化。另外值得注意的是，在图中我们完好地保留了原有链表。事实上，在算法实现中，我们将节点从原有链表中移除，并将它们添加到别的链表中。我们没有使用任何额外的空间，只是将原有的链表元素进行移动。*"}, {"lang": "Python", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/scramble-string", "source": []}
{"url": "https://leetcode-cn.com/problems/merge-sorted-array", "source": [{"lang": "Java", "code": "class Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    System.arraycopy(nums2, 0, nums1, m, n);\n    Arrays.sort(nums1);\n  }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        nums1[:] = sorted(nums1[:m] + nums2)"}, {"lang": "Java", "code": "class Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    // Make a copy of nums1.\n    int [] nums1_copy = new int[m];\n    System.arraycopy(nums1, 0, nums1_copy, 0, m);\n\n    // Two get pointers for nums1_copy and nums2.\n    int p1 = 0;\n    int p2 = 0;\n\n    // Set pointer for nums1\n    int p = 0;\n\n    // Compare elements from nums1_copy and nums2\n    // and add the smallest one into nums1.\n    while ((p1 < m) && (p2 < n))\n      nums1[p++] = (nums1_copy[p1] < nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];\n\n    // if there are still elements to add\n    if (p1 < m)\n      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);\n    if (p2 < n)\n      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);\n  }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        # Make a copy of nums1.\n        nums1_copy = nums1[:m] \n        nums1[:] = []\n\n        # Two get pointers for nums1_copy and nums2.\n        p1 = 0 \n        p2 = 0\n        \n        # Compare elements from nums1_copy and nums2\n        # and add the smallest one into nums1.\n        while p1 < m and p2 < n: \n            if nums1_copy[p1] < nums2[p2]: \n                nums1.append(nums1_copy[p1])\n                p1 += 1\n            else:\n                nums1.append(nums2[p2])\n                p2 += 1\n\n        # if there are still elements to add\n        if p1 < m: \n            nums1[p1 + p2:] = nums1_copy[p1:]\n        if p2 < n:\n            nums1[p1 + p2:] = nums2[p2:]"}, {"lang": "Java", "code": "class Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    // two get pointers for nums1 and nums2\n    int p1 = m - 1;\n    int p2 = n - 1;\n    // set pointer for nums1\n    int p = m + n - 1;\n\n    // while there are still elements to compare\n    while ((p1 >= 0) && (p2 >= 0))\n      // compare two elements from nums1 and nums2 \n      // and add the largest one in nums1 \n      nums1[p--] = (nums1[p1] < nums2[p2]) ? nums2[p2--] : nums1[p1--];\n\n    // add missing elements from nums2\n    System.arraycopy(nums2, 0, nums1, 0, p2 + 1);\n  }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        # two get pointers for nums1 and nums2\n        p1 = m - 1\n        p2 = n - 1\n        # set pointer for nums1\n        p = m + n - 1\n        \n        # while there are still elements to compare\n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] < nums2[p2]:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            else:\n                nums1[p] =  nums1[p1]\n                p1 -= 1\n            p -= 1\n        \n        # add missing elements from nums2\n        nums1[:p2 + 1] = nums2[:p2 + 1]"}]}
{"url": "https://leetcode-cn.com/problems/gray-code", "source": []}
{"url": "https://leetcode-cn.com/problems/subsets-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/decode-ways", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-linked-list-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/restore-ip-addresses", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-tree-inorder-traversal", "source": [{"lang": "Java", "code": "class Solution {\n    public List < Integer > inorderTraversal(TreeNode root) {\n        List < Integer > res = new ArrayList < > ();\n        helper(root, res);\n        return res;\n    }\n\n    public void helper(TreeNode root, List < Integer > res) {\n        if (root != null) {\n            if (root.left != null) {\n                helper(root.left, res);\n            }\n            res.add(root.val);\n            if (root.right != null) {\n                helper(root.right, res);\n            }\n        }\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public List < Integer > inorderTraversal(TreeNode root) {\n        List < Integer > res = new ArrayList < > ();\n        Stack < TreeNode > stack = new Stack < > ();\n        TreeNode curr = root;\n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            res.add(curr.val);\n            curr = curr.right;\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "若current没有左子节点\n\n    a. 将current添加到输出\n\n    b. 进入右子树，亦即, current = current.right\n\n否则\n\n    a. 在current的左子树中，令current成为最右侧节点的右子节点\n\n    b. 进入左子树，亦即，current = current.left"}]}
{"url": "https://leetcode-cn.com/problems/unique-binary-search-trees-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/unique-binary-search-trees", "source": [{"lang": "Java", "code": "public class Solution {\n  public int numTrees(int n) {\n    int[] G = new int[n + 1];\n    G[0] = 1;\n    G[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n      for (int j = 1; j <= i; ++j) {\n        G[i] += G[j - 1] * G[i - j];\n      }\n    }\n    return G[n];\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        G = [0]*(n+1)\n        G[0], G[1] = 1, 1\n\n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                G[i] += G[j-1] * G[i-j]\n\n        return G[n]"}, {"lang": "Java", "code": "class Solution {\n  public int numTrees(int n) {\n    // Note: we should use long here instead of int, otherwise overflow\n    long C = 1;\n    for (int i = 0; i < n; ++i) {\n      C = C * 2 * (2 * i + 1) / (i + 2);\n    }\n    return (int) C;\n  }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        C = 1\n        for i in range(0, n):\n            C = C * 2*(2*i+1)/(i+2)\n        return int(C)"}]}
{"url": "https://leetcode-cn.com/problems/interleaving-string", "source": [{"lang": "Java", "code": "s1=\"abc\"\ns2=\"bcd\"\ns3=\"abcbdc\""}, {"lang": "Java", "code": "public class Solution {\n    public boolean is_Interleave(String s1,int i,String s2,int j,String res,String s3)\n    {\n        if(res.equals(s3) && i==s1.length() && j==s2.length())\n            return true;\n        boolean ans=false;\n        if(i<s1.length())\n            ans|=is_Interleave(s1,i+1,s2,j,res+s1.charAt(i),s3);\n        if(j<s2.length())\n            ans|=is_Interleave(s1,i,s2,j+1,res+s2.charAt(j),s3);\n        return ans;\n\n    }\n    public boolean isInterleave(String s1, String s2, String s3) {\n        return is_Interleave(s1,0,s2,0,\"\",s3);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n   public boolean is_Interleave(String s1, int i, String s2, int j, String s3, int k, int[][] memo) {\n       if (i == s1.length()) {\n           return s2.substring(j).equals(s3.substring(k));\n       }\n       if (j == s2.length()) {\n           return s1.substring(i).equals(s3.substring(k));\n       }\n       if (memo[i][j] >= 0) {\n           return memo[i][j] == 1 ? true : false;\n       }\n       boolean ans = false;\n       if (s3.charAt(k) == s1.charAt(i) && is_Interleave(s1, i + 1, s2, j, s3, k + 1, memo)\n               || s3.charAt(k) == s2.charAt(j) && is_Interleave(s1, i, s2, j + 1, s3, k + 1, memo)) {\n           ans = true;\n       }\n       memo[i][j] = ans ? 1 : 0;\n       return ans;\n   }\n   public boolean isInterleave(String s1, String s2, String s3) {\n       int memo[][] = new int[s1.length()][s2.length()];\n       for (int i = 0; i < s1.length(); i++) {\n           for (int j = 0; j < s2.length(); j++) {\n               memo[i][j] = -1;\n           }\n       }\n       return is_Interleave(s1, 0, s2, 0, s3, 0, memo);\n   }\n}"}, {"lang": "Java", "code": "s1=\"aabcc\"\ns2=\"dbbca\"\ns3=\"aadbbcbcac\""}]}
{"url": "https://leetcode-cn.com/problems/validate-binary-search-tree", "source": [{"lang": "Java", "code": "// Definition for a binary tree node.\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}"}, {"lang": "Python", "code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None"}, {"lang": "Java", "code": "class Solution {\n  public boolean helper(TreeNode node, Integer lower, Integer upper) {\n    if (node == null) return true;\n\n    int val = node.val;\n    if (lower != null && val <= lower) return false;\n    if (upper != null && val >= upper) return false;\n\n    if (! helper(node.right, val, upper)) return false;\n    if (! helper(node.left, lower, val)) return false;\n    return true;\n  }\n\n  public boolean isValidBST(TreeNode root) {\n    return helper(root, null, null);\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def helper(node, lower = float('-inf'), upper = float('inf')):\n            if not node:\n                return True\n            \n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n\n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            return True\n\n        return helper(root)"}, {"lang": "Java", "code": "class Solution {\n  LinkedList<TreeNode> stack = new LinkedList();\n  LinkedList<Integer> uppers = new LinkedList(),\n          lowers = new LinkedList();\n\n  public void update(TreeNode root, Integer lower, Integer upper) {\n    stack.add(root);\n    lowers.add(lower);\n    uppers.add(upper);\n  }\n\n  public boolean isValidBST(TreeNode root) {\n    Integer lower = null, upper = null, val;\n    update(root, lower, upper);\n\n    while (!stack.isEmpty()) {\n      root = stack.poll();\n      lower = lowers.poll();\n      upper = uppers.poll();\n\n      if (root == null) continue;\n      val = root.val;\n      if (lower != null && val <= lower) return false;\n      if (upper != null && val >= upper) return false;\n      update(root.right, val, upper);\n      update(root.left, lower, val);\n    }\n    return true;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n            \n        stack = [(root, float('-inf'), float('inf')), ] \n        while stack:\n            root, lower, upper = stack.pop()\n            if not root:\n                continue\n            val = root.val\n            if val <= lower or val >= upper:\n                return False\n            stack.append((root.right, val, upper))\n            stack.append((root.left, lower, val))\n        return True  "}, {"lang": "Java", "code": "class Solution {\n  public boolean isValidBST(TreeNode root) {\n    Stack<TreeNode> stack = new Stack();\n    double inorder = - Double.MAX_VALUE;\n\n    while (!stack.isEmpty() || root != null) {\n      while (root != null) {\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      // If next element in inorder traversal\n      // is smaller than the previous one\n      // that's not BST.\n      if (root.val <= inorder) return false;\n      inorder = root.val;\n      root = root.right;\n    }\n    return true;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        stack, inorder = [], float('-inf')\n        \n        while stack or root:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            # If next element in inorder traversal\n            # is smaller than the previous one\n            # that's not BST.\n            if root.val <= inorder:\n                return False\n            inorder = root.val\n            root = root.right\n\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/recover-binary-search-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/same-tree", "source": [{"lang": "Python", "code": "class Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"    \n        # p and q are both None\n        if not p and not q:\n            return True\n        # one of p and q is None\n        if not q or not p:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and \\\n               self.isSameTree(p.left, q.left)"}, {"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    // p and q are both null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.right, q.right) &&\n            isSameTree(p.left, q.left);\n  }\n}"}, {"lang": "Python", "code": "from collections import deque\nclass Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"    \n        def check(p, q):\n            # if both are None\n            if not p and not q:\n                return True\n            # one of p and q is None\n            if not q or not p:\n                return False\n            if p.val != q.val:\n                return False\n            return True\n        \n        deq = deque([(p, q),])\n        while deq:\n            p, q = deq.popleft()\n            if not check(p, q):\n                return False\n            \n            if p:\n                deq.append((p.left, q.left))\n                deq.append((p.right, q.right))\n                    \n        return True"}, {"lang": "Java", "code": "class Solution {\n  public boolean check(TreeNode p, TreeNode q) {\n    // p and q are null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return true;\n  }\n\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (!check(p, q)) return false;\n\n    // init deques\n    ArrayDeque<TreeNode> deqP = new ArrayDeque<TreeNode>();\n    ArrayDeque<TreeNode> deqQ = new ArrayDeque<TreeNode>();\n    deqP.addLast(p);\n    deqQ.addLast(q);\n\n    while (!deqP.isEmpty()) {\n      p = deqP.removeFirst();\n      q = deqQ.removeFirst();\n\n      if (!check(p, q)) return false;\n      if (p != null) {\n        // in Java nulls are not allowed in Deque\n        if (!check(p.left, q.left)) return false;\n        if (p.left != null) {\n          deqP.addLast(p.left);\n          deqQ.addLast(q.left);\n        }\n        if (!check(p.right, q.right)) return false;\n        if (p.right != null) {\n          deqP.addLast(p.right);\n          deqQ.addLast(q.right);\n        }\n      }\n    }\n    return true;\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/symmetric-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-tree-level-order-traversal", "source": [{"lang": "Python", "code": "class Solution:\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        levels = []\n        if not root:\n            return levels\n        \n        def helper(node, level):\n            # start the current level\n            if len(levels) == level:\n                levels.append([])\n\n            # append the current node value\n            levels[level].append(node.val)\n\n            # process child nodes for the next level\n            if node.left:\n                helper(node.left, level + 1)\n            if node.right:\n                helper(node.right, level + 1)\n            \n        helper(root, 0)\n        return levels"}, {"lang": "Java", "code": "class Solution {\n    List<List<Integer>> levels = new ArrayList<List<Integer>>();\n\n    public void helper(TreeNode node, int level) {\n        // start the current level\n        if (levels.size() == level)\n            levels.add(new ArrayList<Integer>());\n\n         // fulfil the current level\n         levels.get(level).add(node.val);\n\n         // process child nodes for the next level\n         if (node.left != null)\n            helper(node.left, level + 1);\n         if (node.right != null)\n            helper(node.right, level + 1);\n    }\n    \n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if (root == null) return levels;\n        helper(root, 0);\n        return levels;\n    }\n}"}, {"lang": "Python", "code": "from collections import deque\nclass Solution:\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        levels = []\n        if not root:\n            return levels\n        \n        level = 0\n        queue = deque([root,])\n        while queue:\n            # start the current level\n            levels.append([])\n            # number of elements in the current level \n            level_length = len(queue)\n            \n            for i in range(level_length):\n                node = queue.popleft()\n                # fulfill the current level\n                levels[level].append(node.val)\n                \n                # add child nodes of the current level\n                # in the queue for the next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            # go to next level\n            level += 1\n        \n        return levels"}, {"lang": "Java", "code": "class Solution {\n  public List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> levels = new ArrayList<List<Integer>>();\n    if (root == null) return levels;\n\n    Queue<TreeNode> queue = new LinkedList<TreeNode>();\n    queue.add(root);\n    int level = 0;\n    while ( !queue.isEmpty() ) {\n      // start the current level\n      levels.add(new ArrayList<Integer>());\n\n      // number of elements in the current level\n      int level_length = queue.size();\n      for(int i = 0; i < level_length; ++i) {\n        TreeNode node = queue.remove();\n\n        // fulfill the current level\n        levels.get(level).add(node.val);\n\n        // add child nodes of the current level\n        // in the queue for the next level\n        if (node.left != null) queue.add(node.left);\n        if (node.right != null) queue.add(node.right);\n      }\n      // go to next level\n      level++;\n    }\n    return levels;\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-depth-of-binary-tree", "source": [{"lang": "Java", "code": "  /* Definition for a binary tree node. */\n  public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }"}, {"lang": "Python", "code": "class TreeNode(object):\n    \"\"\" Definition of a binary tree node.\"\"\"\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None"}, {"lang": "Java", "code": "class Solution {\n  public int maxDepth(TreeNode root) {\n    if (root == null) {\n      return 0;\n    } else {\n      int left_height = maxDepth(root.left);\n      int right_height = maxDepth(root.right);\n      return java.lang.Math.max(left_height, right_height) + 1;\n    }\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\" \n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 "}, {"lang": "Java", "code": "import javafx.util.Pair;\nimport java.lang.Math;\n\nclass Solution {\n  public int maxDepth(TreeNode root) {\n    Queue<Pair<TreeNode, Integer>> stack = new LinkedList<>();\n    if (root != null) {\n      stack.add(new Pair(root, 1));\n    }\n\n    int depth = 0;\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> current = stack.poll();\n      root = current.getKey();\n      int current_depth = current.getValue();\n      if (root != null) {\n        depth = Math.max(depth, current_depth);\n        stack.add(new Pair(root.left, current_depth + 1));\n        stack.add(new Pair(root.right, current_depth + 1));\n      }\n    }\n    return depth;\n  }\n};"}, {"lang": "Python", "code": "class Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\" \n        stack = []\n        if root is not None:\n            stack.append((1, root))\n        \n        depth = 0\n        while stack != []:\n            current_depth, root = stack.pop()\n            if root is not None:\n                depth = max(depth, current_depth)\n                stack.append((current_depth + 1, root.left))\n                stack.append((current_depth + 1, root.right))\n        \n        return depth"}]}
{"url": "https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/balanced-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-depth-of-binary-tree", "source": [{"lang": "Java", "code": "// Definition for a binary tree node.\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}"}, {"lang": "Python", "code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None"}, {"lang": "Java", "code": "class Solution {\n  public int minDepth(TreeNode root) {\n    if (root == null) {\n      return 0;\n    }\n\n    if ((root.left == null) && (root.right == null)) {\n      return 1;\n    }\n\n    int min_depth = Integer.MAX_VALUE;\n    if (root.left != null) {\n      min_depth = Math.min(minDepth(root.left), min_depth);\n    }\n    if (root.right != null) {\n      min_depth = Math.min(minDepth(root.right), min_depth);\n    }\n\n    return min_depth + 1;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root: \n            return 0 \n        \n        children = [root.left, root.right]\n        # if we're at leaf node\n        if not any(children):\n            return 1\n        \n        min_depth = float('inf')\n        for c in children:\n            if c:\n                min_depth = min(self.minDepth(c), min_depth)\n        return min_depth + 1 "}, {"lang": "Java", "code": "import javafx.util.Pair;\nclass Solution {\n  public int minDepth(TreeNode root) {\n    LinkedList<Pair<TreeNode, Integer>> stack = new LinkedList<>();\n    if (root == null) {\n      return 0;\n    }\n    else {\n      stack.add(new Pair(root, 1));\n    }\n\n    int min_depth = Integer.MAX_VALUE;\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> current = stack.pollLast();\n      root = current.getKey();\n      int current_depth = current.getValue();\n      if ((root.left == null) && (root.right == null)) {\n        min_depth = Math.min(min_depth, current_depth);\n      }\n      if (root.left != null) {\n        stack.add(new Pair(root.left, current_depth + 1));\n      }\n      if (root.right != null) {\n        stack.add(new Pair(root.right, current_depth + 1));\n      }\n    }\n    return min_depth;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        else:\n            stack, min_depth = [(1, root),], float('inf')\n        \n        while stack:\n            depth, root = stack.pop()\n            children = [root.left, root.right]\n            if not any(children):\n                min_depth = min(depth, min_depth)\n            for c in children:\n                if c:\n                    stack.append((depth + 1, c))\n        \n        return min_depth "}, {"lang": "Java", "code": "import javafx.util.Pair;\nclass Solution {\n  public int minDepth(TreeNode root) {\n    LinkedList<Pair<TreeNode, Integer>> stack = new LinkedList<>();\n    if (root == null) {\n      return 0;\n    }\n    else {\n      stack.add(new Pair(root, 1));\n    }\n\n    int current_depth = 0;\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> current = stack.poll();\n      root = current.getKey();\n      current_depth = current.getValue();\n      if ((root.left == null) && (root.right == null)) {\n        break;\n      }\n      if (root.left != null) {\n        stack.add(new Pair(root.left, current_depth + 1));\n      }\n      if (root.right != null) {\n        stack.add(new Pair(root.right, current_depth + 1));\n      }\n    }\n    return current_depth;\n  }\n}"}, {"lang": "Python", "code": "from collections import deque\nclass Solution:\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        else:\n            node_deque = deque([(1, root),])\n        \n        while node_deque:\n            depth, root = node_deque.popleft()\n            children = [root.left, root.right]\n            if not any(children):\n                return depth\n            for c in children:\n                if c:\n                    node_deque.append((depth + 1, c))"}]}
{"url": "https://leetcode-cn.com/problems/path-sum", "source": [{"lang": "Java", "code": "/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}"}, {"lang": "Python", "code": "class TreeNode(object):\n    \"\"\" Definition of a binary tree node.\"\"\"\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None"}, {"lang": "Java", "code": "class Solution {\n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null)\n      return false;\n\n    sum -= root.val;\n    if ((root.left == null) && (root.right == null))\n      return (sum == 0);\n    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def hasPathSum(self, root, sum):\n        \"\"\"\n        :type root: TreeNode\n        :type sum: int\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n\n        sum -= root.val\n        if not root.left and not root.right:  # if reach a leaf\n            return sum == 0\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)"}, {"lang": "Java", "code": "class Solution {\n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null)\n      return false;\n\n    LinkedList<TreeNode> node_stack = new LinkedList();\n    LinkedList<Integer> sum_stack = new LinkedList();\n    node_stack.add(root);\n    sum_stack.add(sum - root.val);\n\n    TreeNode node;\n    int curr_sum;\n    while ( !node_stack.isEmpty() ) {\n      node = node_stack.pollLast();\n      curr_sum = sum_stack.pollLast();\n      if ((node.right == null) && (node.left == null) && (curr_sum == 0))\n        return true;\n\n      if (node.right != null) {\n        node_stack.add(node.right);\n        sum_stack.add(curr_sum - node.right.val);\n      }\n      if (node.left != null) {\n        node_stack.add(node.left);\n        sum_stack.add(curr_sum - node.left.val);\n      }\n    }\n    return false;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def hasPathSum(self, root, sum):\n        \"\"\"\n        :type root: TreeNode\n        :type sum: int\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n\n        de = [(root, sum - root.val), ]\n        while de:\n            node, curr_sum = de.pop()\n            if not node.left and not node.right and curr_sum == 0:  \n                return True\n            if node.right:\n                de.append((node.right, curr_sum - node.right.val))\n            if node.left:\n                de.append((node.left, curr_sum - node.left.val))\n        return False"}]}
{"url": "https://leetcode-cn.com/problems/path-sum-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list", "source": []}
{"url": "https://leetcode-cn.com/problems/distinct-subsequences", "source": []}
{"url": "https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node", "source": []}
{"url": "https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/pascals-triangle", "source": [{"lang": "Java", "code": "class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> triangle = new ArrayList<List<Integer>>();\n\n        // First base case; if user requests zero rows, they get zero rows.\n        if (numRows == 0) {\n            return triangle;\n        }\n\n        // Second base case; first row is always [1].\n        triangle.add(new ArrayList<>());\n        triangle.get(0).add(1);\n\n        for (int rowNum = 1; rowNum < numRows; rowNum++) {\n            List<Integer> row = new ArrayList<>();\n            List<Integer> prevRow = triangle.get(rowNum-1);\n\n            // The first row element is always 1.\n            row.add(1);\n\n            // Each triangle element (other than the first and last of each row)\n            // is equal to the sum of the elements above-and-to-the-left and\n            // above-and-to-the-right.\n            for (int j = 1; j < rowNum; j++) {\n                row.add(prevRow.get(j-1) + prevRow.get(j));\n            }\n\n            // The last row element is always 1.\n            row.add(1);\n\n            triangle.add(row);\n        }\n\n        return triangle;\n    }\n}"}, {"lang": "Python3", "code": "class Solution:\n    def generate(self, num_rows):\n        triangle = []\n\n        for row_num in range(num_rows):\n            # The first and last row elements are always 1.\n            row = [None for _ in range(row_num+1)]\n            row[0], row[-1] = 1, 1\n\n            # Each triangle element is equal to the sum of the elements\n            # above-and-to-the-left and above-and-to-the-right.\n            for j in range(1, len(row)-1):\n                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]\n\n            triangle.append(row)\n\n        return triangle"}]}
{"url": "https://leetcode-cn.com/problems/pascals-triangle-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/triangle", "source": []}
{"url": "https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock", "source": [{"lang": "Java", "code": "public class Solution {\n    public int maxProfit(int prices[]) {\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length - 1; i++) {\n            for (int j = i + 1; j < prices.length; j++) {\n                int profit = prices[j] - prices[i];\n                if (profit > maxprofit)\n                    maxprofit = profit;\n            }\n        }\n        return maxprofit;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int maxProfit(int prices[]) {\n        int minprice = Integer.MAX_VALUE;\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minprice)\n                minprice = prices[i];\n            else if (prices[i] - minprice > maxprofit)\n                maxprofit = prices[i] - minprice;\n        }\n        return maxprofit;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-tree-maximum-path-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-palindrome", "source": []}
{"url": "https://leetcode-cn.com/problems/word-ladder-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/word-ladder", "source": [{"lang": "Java", "code": "import javafx.util.Pair;\n\nclass Solution {\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n\n    // Since all words are of same length.\n    int L = beginWord.length();\n\n    // Dictionary to hold combination of words that can be formed,\n    // from any given word. By changing one letter at a time.\n    HashMap<String, ArrayList<String>> allComboDict = new HashMap<String, ArrayList<String>>();\n\n    wordList.forEach(\n        word -> {\n          for (int i = 0; i < L; i++) {\n            // Key is the generic word\n            // Value is a list of words which have the same intermediate generic word.\n            String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n            ArrayList<String> transformations =\n                allComboDict.getOrDefault(newWord, new ArrayList<String>());\n            transformations.add(word);\n            allComboDict.put(newWord, transformations);\n          }\n        });\n\n    // Queue for BFS\n    Queue<Pair<String, Integer>> Q = new LinkedList<Pair<String, Integer>>();\n    Q.add(new Pair(beginWord, 1));\n\n    // Visited to make sure we don't repeat processing same word.\n    HashMap<String, Boolean> visited = new HashMap<String, Boolean>();\n    visited.put(beginWord, true);\n\n    while (!Q.isEmpty()) {\n      Pair<String, Integer> node = Q.remove();\n      String word = node.getKey();\n      int level = node.getValue();\n      for (int i = 0; i < L; i++) {\n\n        // Intermediate words for current word\n        String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n\n        // Next states are all the words which share the same intermediate state.\n        for (String adjacentWord : allComboDict.getOrDefault(newWord, new ArrayList<String>())) {\n          // If at any point if we find what we are looking for\n          // i.e. the end word - we can return with the answer.\n          if (adjacentWord.equals(endWord)) {\n            return level + 1;\n          }\n          // Otherwise, add it to the BFS Queue. Also mark it visited\n          if (!visited.containsKey(adjacentWord)) {\n            visited.put(adjacentWord, true);\n            Q.add(new Pair(adjacentWord, level + 1));\n          }\n        }\n      }\n    }\n\n    return 0;\n  }\n}"}, {"lang": "Python", "code": "from collections import defaultdict\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n\n        if endWord not in wordList or not endWord or not beginWord or not wordList:\n            return 0\n\n        # Since all words are of same length.\n        L = len(beginWord)\n\n        # Dictionary to hold combination of words that can be formed,\n        # from any given word. By changing one letter at a time.\n        all_combo_dict = defaultdict(list)\n        for word in wordList:\n            for i in range(L):\n                # Key is the generic word\n                # Value is a list of words which have the same intermediate generic word.\n                all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\n\n\n        # Queue for BFS\n        queue = [(beginWord, 1)]\n        # Visited to make sure we don't repeat processing same word.\n        visited = {beginWord: True}\n        while queue:\n            current_word, level = queue.pop(0)      \n            for i in range(L):\n                # Intermediate words for current word\n                intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\n\n                # Next states are all the words which share the same intermediate state.\n                for word in all_combo_dict[intermediate_word]:\n                    # If at any point if we find what we are looking for\n                    # i.e. the end word - we can return with the answer.\n                    if word == endWord:\n                        return level + 1\n                    # Otherwise, add it to the BFS Queue. Also mark it visited\n                    if word not in visited:\n                        visited[word] = True\n                        queue.append((word, level + 1))\n                all_combo_dict[intermediate_word] = []\n        return 0"}, {"lang": "Java", "code": "import javafx.util.Pair;\n\nclass Solution {\n\n  private int L;\n  private HashMap<String, ArrayList<String>> allComboDict;\n\n  Solution() {\n    this.L = 0;\n\n    // Dictionary to hold combination of words that can be formed,\n    // from any given word. By changing one letter at a time.\n    this.allComboDict = new HashMap<String, ArrayList<String>>();\n  }\n\n  private int visitWordNode(\n      Queue<Pair<String, Integer>> Q,\n      HashMap<String, Integer> visited,\n      HashMap<String, Integer> othersVisited) {\n    Pair<String, Integer> node = Q.remove();\n    String word = node.getKey();\n    int level = node.getValue();\n\n    for (int i = 0; i < this.L; i++) {\n\n      // Intermediate words for current word\n      String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n\n      // Next states are all the words which share the same intermediate state.\n      for (String adjacentWord : this.allComboDict.getOrDefault(newWord, new ArrayList<String>())) {\n        // If at any point if we find what we are looking for\n        // i.e. the end word - we can return with the answer.\n        if (othersVisited.containsKey(adjacentWord)) {\n          return level + othersVisited.get(adjacentWord);\n        }\n\n        if (!visited.containsKey(adjacentWord)) {\n\n          // Save the level as the value of the dictionary, to save number of hops.\n          visited.put(adjacentWord, level + 1);\n          Q.add(new Pair(adjacentWord, level + 1));\n        }\n      }\n    }\n    return -1;\n  }\n\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n\n    if (!wordList.contains(endWord)) {\n      return 0;\n    }\n\n    // Since all words are of same length.\n    this.L = beginWord.length();\n\n    wordList.forEach(\n        word -> {\n          for (int i = 0; i < L; i++) {\n            // Key is the generic word\n            // Value is a list of words which have the same intermediate generic word.\n            String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n            ArrayList<String> transformations =\n                this.allComboDict.getOrDefault(newWord, new ArrayList<String>());\n            transformations.add(word);\n            this.allComboDict.put(newWord, transformations);\n          }\n        });\n\n    // Queues for birdirectional BFS\n    // BFS starting from beginWord\n    Queue<Pair<String, Integer>> Q_begin = new LinkedList<Pair<String, Integer>>();\n    // BFS starting from endWord\n    Queue<Pair<String, Integer>> Q_end = new LinkedList<Pair<String, Integer>>();\n    Q_begin.add(new Pair(beginWord, 1));\n    Q_end.add(new Pair(endWord, 1));\n\n    // Visited to make sure we don't repeat processing same word.\n    HashMap<String, Integer> visitedBegin = new HashMap<String, Integer>();\n    HashMap<String, Integer> visitedEnd = new HashMap<String, Integer>();\n    visitedBegin.put(beginWord, 1);\n    visitedEnd.put(endWord, 1);\n\n    while (!Q_begin.isEmpty() && !Q_end.isEmpty()) {\n\n      // One hop from begin word\n      int ans = visitWordNode(Q_begin, visitedBegin, visitedEnd);\n      if (ans > -1) {\n        return ans;\n      }\n\n      // One hop from end word\n      ans = visitWordNode(Q_end, visitedEnd, visitedBegin);\n      if (ans > -1) {\n        return ans;\n      }\n    }\n\n    return 0;\n  }\n}"}, {"lang": "Python", "code": "from collections import defaultdict\nclass Solution(object):\n    def __init__(self):\n        self.length = 0\n        # Dictionary to hold combination of words that can be formed,\n        # from any given word. By changing one letter at a time.\n        self.all_combo_dict = defaultdict(list)\n\n    def visitWordNode(self, queue, visited, others_visited):\n        current_word, level = queue.pop(0)\n        for i in range(self.length):\n            # Intermediate words for current word\n            intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\n\n            # Next states are all the words which share the same intermediate state.\n            for word in self.all_combo_dict[intermediate_word]:\n                # If the intermediate state/word has already been visited from the\n                # other parallel traversal this means we have found the answer.\n                if word in others_visited:\n                    return level + others_visited[word]\n                if word not in visited:\n                    # Save the level as the value of the dictionary, to save number of hops.\n                    visited[word] = level + 1\n                    queue.append((word, level + 1))\n        return None\n\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n\n        if endWord not in wordList or not endWord or not beginWord or not wordList:\n            return 0\n\n        # Since all words are of same length.\n        self.length = len(beginWord)\n\n        for word in wordList:\n            for i in range(self.length):\n                # Key is the generic word\n                # Value is a list of words which have the same intermediate generic word.\n                self.all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\n\n\n        # Queues for birdirectional BFS\n        queue_begin = [(beginWord, 1)] # BFS starting from beginWord\n        queue_end = [(endWord, 1)] # BFS starting from endWord\n\n        # Visited to make sure we don't repeat processing same word\n        visited_begin = {beginWord: 1}\n        visited_end = {endWord: 1}\n        ans = None\n\n        # We do a birdirectional search starting one pointer from begin\n        # word and one pointer from end word. Hopping one by one.\n        while queue_begin and queue_end:\n\n            # One hop from begin word\n            ans = self.visitWordNode(queue_begin, visited_begin, visited_end)\n            if ans:\n                return ans\n            # One hop from end word\n            ans = self.visitWordNode(queue_end, visited_end, visited_begin)\n            if ans:\n                return ans\n\n        return 0"}]}
{"url": "https://leetcode-cn.com/problems/longest-consecutive-sequence", "source": []}
{"url": "https://leetcode-cn.com/problems/sum-root-to-leaf-numbers", "source": []}
{"url": "https://leetcode-cn.com/problems/surrounded-regions", "source": []}
{"url": "https://leetcode-cn.com/problems/palindrome-partitioning", "source": []}
{"url": "https://leetcode-cn.com/problems/palindrome-partitioning-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/clone-graph", "source": []}
{"url": "https://leetcode-cn.com/problems/gas-station", "source": [{"lang": "Python", "code": "class Solution:\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(gas)\n        \n        total_tank, curr_tank = 0, 0\n        starting_station = 0\n        for i in range(n):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            # If one couldn't get here,\n            if curr_tank < 0:\n                # Pick up the next station as the starting one.\n                starting_station = i + 1\n                # Start with an empty tank.\n                curr_tank = 0\n        \n        return starting_station if total_tank >= 0 else -1"}, {"lang": "Java", "code": "class Solution {\n  public int canCompleteCircuit(int[] gas, int[] cost) {\n    int n = gas.length;\n\n    int total_tank = 0;\n    int curr_tank = 0;\n    int starting_station = 0;\n    for (int i = 0; i < n; ++i) {\n      total_tank += gas[i] - cost[i];\n      curr_tank += gas[i] - cost[i];\n      // If one couldn't get here,\n      if (curr_tank < 0) {\n        // Pick up the next station as the starting one.\n        starting_station = i + 1;\n        // Start with an empty tank.\n        curr_tank = 0;\n      }\n    }\n    return total_tank >= 0 ? starting_station : -1;\n  }\n}"}, {"lang": "C++", "code": "class Solution {\n  public:\n  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n    int n = gas.size();\n\n    int total_tank = 0;\n    int curr_tank = 0;\n    int starting_station = 0;\n    for (int i = 0; i < n; ++i) {\n      total_tank += gas[i] - cost[i];\n      curr_tank += gas[i] - cost[i];\n      // If one couldn't get here,\n      if (curr_tank < 0) {\n        // Pick up the next station as the starting one.\n        starting_station = i + 1;\n        // Start with an empty tank.\n        curr_tank = 0;\n      }\n    }\n    return total_tank >= 0 ? starting_station : -1;\n  }\n};"}]}
{"url": "https://leetcode-cn.com/problems/candy", "source": [{"lang": "Java", "code": "public class Solution {\n    public int candy(int[] ratings) {\n        int[] candies = new int[ratings.length];\n        Arrays.fill(candies, 1);\n        boolean flag = true;\n        int sum = 0;\n        while (flag) {\n            flag = false;\n            for (int i = 0; i < ratings.length; i++) {\n                if (i != ratings.length - 1 && ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\n                    candies[i] = candies[i + 1] + 1;\n                    flag = true;\n                }\n                if (i > 0 && ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1]) {\n                    candies[i] = candies[i - 1] + 1;\n                    flag = true;\n                }\n            }\n        }\n        for (int candy : candies) {\n            sum += candy;\n        }\n        return sum;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int candy(int[] ratings) {\n        int sum = 0;\n        int[] left2right = new int[ratings.length];\n        int[] right2left = new int[ratings.length];\n        Arrays.fill(left2right, 1);\n        Arrays.fill(right2left, 1);\n        for (int i = 1; i < ratings.length; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                left2right[i] = left2right[i - 1] + 1;\n            }\n        }\n        for (int i = ratings.length - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                right2left[i] = right2left[i + 1] + 1;\n            }\n        }\n        for (int i = 0; i < ratings.length; i++) {\n            sum += Math.max(left2right[i], right2left[i]);\n        }\n        return sum;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int candy(int[] ratings) {\n        int[] candies = new int[ratings.length];\n        Arrays.fill(candies, 1);\n        for (int i = 1; i < ratings.length; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n        int sum = candies[ratings.length - 1];\n        for (int i = ratings.length - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n            }\n            sum += candies[i];\n        }\n        return sum;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int count(int n) {\n        return (n * (n + 1)) / 2;\n    }\n    public int candy(int[] ratings) {\n        if (ratings.length <= 1) {\n            return ratings.length;\n        }\n        int candies = 0;\n        int up = 0;\n        int down = 0;\n        int old_slope = 0;\n        for (int i = 1; i < ratings.length; i++) {\n            int new_slope = (ratings[i] > ratings[i - 1]) ? 1 : (ratings[i] < ratings[i - 1] ? -1 : 0);\n            if ((old_slope > 0 && new_slope == 0) || (old_slope < 0 && new_slope >= 0)) {\n                candies += count(up) + count(down) + Math.max(up, down);\n                up = 0;\n                down = 0;\n            }\n            if (new_slope > 0)\n                up++;\n            if (new_slope < 0)\n                down++;\n            if (new_slope == 0)\n                candies++;\n\n            old_slope = new_slope;\n        }\n        candies += count(up) + count(down) + Math.max(up, down) + 1;\n        return candies;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/single-number", "source": [{"lang": "Python", "code": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        no_duplicate_list = []\n        for i in nums:\n            if i not in no_duplicate_list:\n                no_duplicate_list.append(i)\n            else:\n                no_duplicate_list.remove(i)\n        return no_duplicate_list.pop()"}, {"lang": "Python", "code": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        hash_table = {}\n        for i in nums:\n            try:\n                hash_table.pop(i)\n            except:\n                hash_table[i] = 1\n        return hash_table.popitem()[0]"}, {"lang": "Python", "code": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return 2 * sum(set(nums)) - sum(nums)"}, {"lang": "Python", "code": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        a = 0\n        for i in nums:\n            a ^= i\n        return a"}]}
{"url": "https://leetcode-cn.com/problems/single-number-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/copy-list-with-random-pointer", "source": []}
{"url": "https://leetcode-cn.com/problems/word-break", "source": [{"lang": "Java", "code": "public class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        return word_Break(s, new HashSet(wordDict), 0);\n    }\n    public boolean word_Break(String s, Set<String> wordDict, int start) {\n        if (start == s.length()) {\n            return true;\n        }\n        for (int end = start + 1; end <= s.length(); end++) {\n            if (wordDict.contains(s.substring(start, end)) && word_Break(s, wordDict, end)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        return word_Break(s, new HashSet(wordDict), 0, new Boolean[s.length()]);\n    }\n    public boolean word_Break(String s, Set<String> wordDict, int start, Boolean[] memo) {\n        if (start == s.length()) {\n            return true;\n        }\n        if (memo[start] != null) {\n            return memo[start];\n        }\n        for (int end = start + 1; end <= s.length(); end++) {\n            if (wordDict.contains(s.substring(start, end)) && word_Break(s, wordDict, end, memo)) {\n                return memo[start] = true;\n            }\n        }\n        return memo[start] = false;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet=new HashSet(wordDict);\n        Queue<Integer> queue = new LinkedList<>();\n        int[] visited = new int[s.length()];\n        queue.add(0);\n        while (!queue.isEmpty()) {\n            int start = queue.remove();\n            if (visited[start] == 0) {\n                for (int end = start + 1; end <= s.length(); end++) {\n                    if (wordDictSet.contains(s.substring(start, end))) {\n                        queue.add(end);\n                        if (end == s.length()) {\n                            return true;\n                        }\n                    }\n                }\n                visited[start] = 1;\n            }\n        }\n        return false;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet=new HashSet(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/word-break-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/linked-list-cycle", "source": [{"lang": "Java", "code": "public boolean hasCycle(ListNode head) {\n    Set<ListNode> nodesSeen = new HashSet<>();\n    while (head != null) {\n        if (nodesSeen.contains(head)) {\n            return true;\n        } else {\n            nodesSeen.add(head);\n        }\n        head = head.next;\n    }\n    return false;\n}"}, {"lang": "Java", "code": "public boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null) {\n        return false;\n    }\n    ListNode slow = head;\n    ListNode fast = head.next;\n    while (slow != fast) {\n        if (fast == null || fast.next == null) {\n            return false;\n        }\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return true;\n}"}]}
{"url": "https://leetcode-cn.com/problems/linked-list-cycle-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/reorder-list", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-tree-preorder-traversal", "source": [{"lang": "Java", "code": "/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}"}, {"lang": "Python", "code": "class TreeNode(object):\n    \"\"\" Definition of a binary tree node.\"\"\"\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None"}, {"lang": "Java", "code": "class Solution {\n  public List<Integer> preorderTraversal(TreeNode root) {\n    LinkedList<TreeNode> stack = new LinkedList<>();\n    LinkedList<Integer> output = new LinkedList<>();\n    if (root == null) {\n      return output;\n    }\n\n    stack.add(root);\n    while (!stack.isEmpty()) {\n      TreeNode node = stack.pollLast();\n      output.add(node.val);\n      if (node.right != null) {\n        stack.add(node.right);\n      }\n      if (node.left != null) {\n        stack.add(node.left);\n      }\n    }\n    return output;\n  }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n        \n        stack, output = [root, ], []\n        \n        while stack:\n            root = stack.pop()\n            if root is not None:\n                output.append(root.val)\n                if root.right is not None:\n                    stack.append(root.right)\n                if root.left is not None:\n                    stack.append(root.left)\n        \n        return output"}, {"lang": "Java", "code": "class Solution {\n  public List<Integer> preorderTraversal(TreeNode root) {\n    LinkedList<Integer> output = new LinkedList<>();\n\n    TreeNode node = root;\n    while (node != null) {\n      if (node.left == null) {\n        output.add(node.val);\n        node = node.right;\n      }\n      else {\n        TreeNode predecessor = node.left;\n        while ((predecessor.right != null) && (predecessor.right != node)) {\n          predecessor = predecessor.right;\n        }\n\n        if (predecessor.right == null) {\n          output.add(node.val);\n          predecessor.right = node;\n          node = node.left;\n        }\n        else{\n          predecessor.right = null;\n          node = node.right;\n        }\n      }\n    }\n    return output;\n  }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        node, output = root, []\n        while node:  \n            if not node.left: \n                output.append(node.val)\n                node = node.right \n            else: \n                predecessor = node.left \n\n                while predecessor.right and predecessor.right is not node: \n                    predecessor = predecessor.right \n\n                if not predecessor.right:\n                    output.append(node.val)\n                    predecessor.right = node  \n                    node = node.left  \n                else:\n                    predecessor.right = None\n                    node = node.right         \n\n        return output"}]}
{"url": "https://leetcode-cn.com/problems/binary-tree-postorder-traversal", "source": [{"lang": "Java", "code": "/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}"}, {"lang": "Python", "code": "class TreeNode(object):\n    \"\"\" Definition of a binary tree node.\"\"\"\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None"}, {"lang": "Java", "code": "class Solution {\n  public List<Integer> postorderTraversal(TreeNode root) {\n    LinkedList<TreeNode> stack = new LinkedList<>();\n    LinkedList<Integer> output = new LinkedList<>();\n    if (root == null) {\n      return output;\n    }\n\n    stack.add(root);\n    while (!stack.isEmpty()) {\n      TreeNode node = stack.pollLast();\n      output.addFirst(node.val);\n      if (node.left != null) {\n        stack.add(node.left);\n      }\n      if (node.right != null) {\n        stack.add(node.right);\n      }\n    }\n    return output;\n  }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n\n        stack, output = [root, ], []\n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            if root.left is not None:\n                stack.append(root.left)\n            if root.right is not None:\n                stack.append(root.right)\n                \n        return output[::-1]"}]}
{"url": "https://leetcode-cn.com/problems/lru-cache", "source": [{"lang": "Python", "code": "from collections import OrderedDict\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self:\n            return - 1\n        \n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last = False)\n\n# LRUCache 对象会以如下语句构造和调用:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)"}, {"lang": "Java", "code": "class LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n\n/**\n * LRUCache 对象会以如下语句构造和调用:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */"}, {"lang": "Python", "code": "class DLinkedNode(): \n    def __init__(self):\n        self.key = 0\n        self.value = 0\n        self.prev = None\n        self.next = None\n            \nclass LRUCache():\n    def _add_node(self, node):\n        \"\"\"\n        Always add the new node right after head.\n        \"\"\"\n        node.prev = self.head\n        node.next = self.head.next\n\n        self.head.next.prev = node\n        self.head.next = node\n\n    def _remove_node(self, node):\n        \"\"\"\n        Remove an existing node from the linked list.\n        \"\"\"\n        prev = node.prev\n        new = node.next\n\n        prev.next = new\n        new.prev = prev\n\n    def _move_to_head(self, node):\n        \"\"\"\n        Move certain node in between to the head.\n        \"\"\"\n        self._remove_node(node)\n        self._add_node(node)\n\n    def _pop_tail(self):\n        \"\"\"\n        Pop the current tail.\n        \"\"\"\n        res = self.tail.prev\n        self._remove_node(res)\n        return res\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.cache = {}\n        self.size = 0\n        self.capacity = capacity\n        self.head, self.tail = DLinkedNode(), DLinkedNode()\n\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        \n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        node = self.cache.get(key, None)\n        if not node:\n            return -1\n\n        # move the accessed node to the head;\n        self._move_to_head(node)\n\n        return node.value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        node = self.cache.get(key)\n\n        if not node: \n            newNode = DLinkedNode()\n            newNode.key = key\n            newNode.value = value\n\n            self.cache[key] = newNode\n            self._add_node(newNode)\n\n            self.size += 1\n\n            if self.size > self.capacity:\n                # pop the tail\n                tail = self._pop_tail()\n                del self.cache[tail.key]\n                self.size -= 1\n        else:\n            # update the value.\n            node.value = value\n            self._move_to_head(node)"}, {"lang": "Java", "code": "import java.util.Hashtable;\npublic class LRUCache {\n\n  class DLinkedNode {\n    int key;\n    int value;\n    DLinkedNode prev;\n    DLinkedNode next;\n  }\n\n  private void addNode(DLinkedNode node) {\n    /**\n     * Always add the new node right after head.\n     */\n    node.prev = head;\n    node.next = head.next;\n\n    head.next.prev = node;\n    head.next = node;\n  }\n\n  private void removeNode(DLinkedNode node){\n    /**\n     * Remove an existing node from the linked list.\n     */\n    DLinkedNode prev = node.prev;\n    DLinkedNode next = node.next;\n\n    prev.next = next;\n    next.prev = prev;\n  }\n\n  private void moveToHead(DLinkedNode node){\n    /**\n     * Move certain node in between to the head.\n     */\n    removeNode(node);\n    addNode(node);\n  }\n\n  private DLinkedNode popTail() {\n    /**\n     * Pop the current tail.\n     */\n    DLinkedNode res = tail.prev;\n    removeNode(res);\n    return res;\n  }\n\n  private Hashtable<Integer, DLinkedNode> cache =\n          new Hashtable<Integer, DLinkedNode>();\n  private int size;\n  private int capacity;\n  private DLinkedNode head, tail;\n\n  public LRUCache(int capacity) {\n    this.size = 0;\n    this.capacity = capacity;\n\n    head = new DLinkedNode();\n    // head.prev = null;\n\n    tail = new DLinkedNode();\n    // tail.next = null;\n\n    head.next = tail;\n    tail.prev = head;\n  }\n\n  public int get(int key) {\n    DLinkedNode node = cache.get(key);\n    if (node == null) return -1;\n\n    // move the accessed node to the head;\n    moveToHead(node);\n\n    return node.value;\n  }\n\n  public void put(int key, int value) {\n    DLinkedNode node = cache.get(key);\n\n    if(node == null) {\n      DLinkedNode newNode = new DLinkedNode();\n      newNode.key = key;\n      newNode.value = value;\n\n      cache.put(key, newNode);\n      addNode(newNode);\n\n      ++size;\n\n      if(size > capacity) {\n        // pop the tail\n        DLinkedNode tail = popTail();\n        cache.remove(tail.key);\n        --size;\n      }\n    } else {\n      // update the value.\n      node.value = value;\n      moveToHead(node);\n    }\n  }\n}\n\n/**\n * LRUCache 对象会以如下语句构造和调用:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */"}]}
{"url": "https://leetcode-cn.com/problems/insertion-sort-list", "source": []}
{"url": "https://leetcode-cn.com/problems/sort-list", "source": []}
{"url": "https://leetcode-cn.com/problems/max-points-on-a-line", "source": [{"lang": "Java", "code": "import javafx.util.Pair;\nclass Solution {\n  Point [] points;\n  int n;\n  HashMap<Double, Integer> lines = new HashMap<Double, Integer>();\n  int horisontal_lines;\n\n  public Pair<Integer, Integer> add_line(int i, int j, int count, int duplicates) {\n    /*\n    Add a line passing through i and j points.\n    Update max number of points on a line containing point i.\n    Update a number of duplicates of i point.\n    */\n    // rewrite points as coordinates\n    int x1 = points[i].x;\n    int y1 = points[i].y;\n    int x2 = points[j].x;\n    int y2 = points[j].y;\n    // add a duplicate point\n    if ((x1 == x2) && (y1 == y2))\n      duplicates++;\n    // add a horisontal line : y = const\n    else if (y1 == y2) {\n      horisontal_lines += 1;\n      count = Math.max(horisontal_lines, count);\n    }\n    // add a line : x = slope * y + c\n    // only slope is needed for a hash-map\n    // since we always start from the same point\n    else {\n      double slope = 1.0 * (x1 - x2) / (y1 - y2) + 0.0;\n      lines.put(slope, lines.getOrDefault(slope, 1) + 1);\n      count = Math.max(lines.get(slope), count);\n    }\n    return new Pair(count, duplicates);\n  }\n\n  public int max_points_on_a_line_containing_point_i(int i) {\n    /*\n    Compute the max number of points\n    for a line containing point i.\n    */\n    // init lines passing through point i\n    lines.clear();\n    horisontal_lines = 1;\n    // One starts with just one point on a line : point i.\n    int count = 1;\n    // There is no duplicates of a point i so far.\n    int duplicates = 0;\n\n    // Compute lines passing through point i (fixed)\n    // and point j (interation).\n    // Update in a loop the number of points on a line\n    // and the number of duplicates of point i.\n    for (int j = i + 1; j < n; j++) {\n      Pair<Integer, Integer> p = add_line(i, j, count, duplicates);\n      count = p.getKey();\n      duplicates = p.getValue();\n    }\n    return count + duplicates;\n  }\n\n  public int maxPoints(Point[] points) {\n    this.points = points;\n    // If the number of points is less than 3\n    // they are all on the same line.\n    n = points.length;\n    if (n < 3)\n      return n;\n\n    int max_count = 1;\n    // Compute in a loop a max number of points \n    // on a line containing point i.\n    for (int i = 0; i < n - 1; i++)\n      max_count = Math.max(max_points_on_a_line_containing_point_i(i), max_count);\n    return max_count;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def maxPoints(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: int\n        \"\"\"      \n        def max_points_on_a_line_containing_point_i(i):\n            \"\"\"\n            Compute the max number of points\n            for a line containing point i.\n            \"\"\"\n            def add_line(i, j, count, duplicates):\n                \"\"\"\n                Add a line passing through i and j points.\n                Update max number of points on a line containing point i.\n                Update a number of duplicates of i point.\n                \"\"\"\n                # rewrite points as coordinates\n                x1 = points[i].x\n                y1 = points[i].y\n                x2 = points[j].x\n                y2 = points[j].y\n                # add a duplicate point\n                if x1 == x2 and y1 == y2:  \n                    duplicates += 1\n                # add a horisontal line : y = const\n                elif y1 == y2:\n                    nonlocal horisontal_lines\n                    horisontal_lines += 1\n                    count = max(horisontal_lines, count)\n                # add a line : x = slope * y + c\n                # only slope is needed for a hash-map\n                # since we always start from the same point\n                else:\n                    slope = (x1 - x2) / (y1 - y2)\n                    lines[slope] = lines.get(slope, 1) + 1\n                    count = max(lines[slope], count)\n                return count, duplicates\n            \n            # init lines passing through point i\n            lines, horisontal_lines = {}, 1\n            # One starts with just one point on a line : point i.\n            count = 1\n            # There is no duplicates of a point i so far.\n            duplicates = 0\n            # Compute lines passing through point i (fixed)\n            # and point j (interation).\n            # Update in a loop the number of points on a line\n            # and the number of duplicates of point i.\n            for j in range(i + 1, n):\n                count, duplicates = add_line(i, j, count, duplicates)\n            return count + duplicates\n            \n        # If the number of points is less than 3\n        # they are all on the same line.\n        n = len(points)\n        if n < 3:\n            return n\n        \n        max_count = 1\n        # Compute in a loop a max number of points \n        # on a line containing point i.\n        for i in range(n - 1):\n            max_count = max(max_points_on_a_line_containing_point_i(i), max_count)\n        return max_count"}]}
{"url": "https://leetcode-cn.com/problems/evaluate-reverse-polish-notation", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-words-in-a-string", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-product-subarray", "source": []}
{"url": "https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array", "source": []}
{"url": "https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/min-stack", "source": []}
{"url": "https://leetcode-cn.com/problems/intersection-of-two-linked-lists", "source": []}
{"url": "https://leetcode-cn.com/problems/find-peak-element", "source": [{"lang": "Java", "code": "public class Solution {\n    public int findPeakElement(int[] nums) {\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i] > nums[i + 1])\n                return i;\n        }\n        return nums.length - 1;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int findPeakElement(int[] nums) {\n        return search(nums, 0, nums.length - 1);\n    }\n    public int search(int[] nums, int l, int r) {\n        if (l == r)\n            return l;\n        int mid = (l + r) / 2;\n        if (nums[mid] > nums[mid + 1])\n            return search(nums, l, mid);\n        return search(nums, mid + 1, r);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int findPeakElement(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] > nums[mid + 1])\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/maximum-gap", "source": [{"lang": "C++", "code": "int maximumGap(vector<int>& nums)\n{\n    if (nums.empty() || nums.size() < 2)            // check if array is empty or small sized\n        return 0;\n\n    sort(nums.begin(), nums.end());                 // sort the array\n\n    int maxGap = 0;\n\n    for (int i = 0; i < nums.size() - 1; i++)\n        maxGap = max(nums[i + 1] - nums[i], maxGap);\n\n    return maxGap;\n}"}, {"lang": "c++", "code": "int maximumGap(vector<int>& nums)\n{\n    if (nums.empty() || nums.size() < 2)\n        return 0;\n\n    int maxVal = *max_element(nums.begin(), nums.end());\n\n    int exp = 1;                                 // 1, 10, 100, 1000 ...\n    int radix = 10;                              // base 10 system\n\n    vector<int> aux(nums.size());\n\n    /* LSD Radix Sort */\n    while (maxVal / exp > 0) {                   // Go through all digits from LSD to MSD\n        vector<int> count(radix, 0);\n\n        for (int i = 0; i < nums.size(); i++)    // Counting sort\n            count[(nums[i] / exp) % 10]++;\n\n        for (int i = 1; i < count.size(); i++)   // you could also use partial_sum()\n            count[i] += count[i - 1];\n\n        for (int i = nums.size() - 1; i >= 0; i--)\n            aux[--count[(nums[i] / exp) % 10]] = nums[i];\n\n        for (int i = 0; i < nums.size(); i++)\n            nums[i] = aux[i];\n\n        exp *= 10;\n    }\n\n    int maxGap = 0;\n\n    for (int i = 0; i < nums.size() - 1; i++)\n        maxGap = max(nums[i + 1] - nums[i], maxGap);\n\n    return maxGap;\n}"}, {"lang": "c++", "code": "class Bucket {\npublic:\n    bool used = false;\n    int minval = numeric_limits<int>::max();        // same as INT_MAX\n    int maxval = numeric_limits<int>::min();        // same as INT_MIN\n};\n\nint maximumGap(vector<int>& nums)\n{\n    if (nums.empty() || nums.size() < 2)\n        return 0;\n\n    int mini = *min_element(nums.begin(), nums.end()),\n        maxi = *max_element(nums.begin(), nums.end());\n\n    int bucketSize = max(1, (maxi - mini) / ((int)nums.size() - 1));        // bucket size or capacity\n    int bucketNum = (maxi - mini) / bucketSize + 1;                         // number of buckets\n    vector<Bucket> buckets(bucketNum);\n\n    for (auto&& num : nums) {\n        int bucketIdx = (num - mini) / bucketSize;                          // locating correct bucket\n        buckets[bucketIdx].used = true;\n        buckets[bucketIdx].minval = min(num, buckets[bucketIdx].minval);\n        buckets[bucketIdx].maxval = max(num, buckets[bucketIdx].maxval);\n    }\n\n    int prevBucketMax = mini, maxGap = 0;\n    for (auto&& bucket : buckets) {\n        if (!bucket.used)\n            continue;\n\n        maxGap = max(maxGap, bucket.minval - prevBucketMax);\n        prevBucketMax = bucket.maxval;\n    }\n\n    return maxGap;\n}"}]}
{"url": "https://leetcode-cn.com/problems/compare-version-numbers", "source": []}
{"url": "https://leetcode-cn.com/problems/fraction-to-recurring-decimal", "source": [{"lang": "java", "code": "public String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) {\n        return \"0\";\n    }\n    StringBuilder fraction = new StringBuilder();\n    // If either one is negative (not both)\n    if (numerator < 0 ^ denominator < 0) {\n        fraction.append(\"-\");\n    }\n    // Convert to Long or else abs(-2147483648) overflows\n    long dividend = Math.abs(Long.valueOf(numerator));\n    long divisor = Math.abs(Long.valueOf(denominator));\n    fraction.append(String.valueOf(dividend / divisor));\n    long remainder = dividend % divisor;\n    if (remainder == 0) {\n        return fraction.toString();\n    }\n    fraction.append(\".\");\n    Map<Long, Integer> map = new HashMap<>();\n    while (remainder != 0) {\n        if (map.containsKey(remainder)) {\n            fraction.insert(map.get(remainder), \"(\");\n            fraction.append(\")\");\n            break;\n        }\n        map.put(remainder, fraction.length());\n        remainder *= 10;\n        fraction.append(String.valueOf(remainder / divisor));\n        remainder %= divisor;\n    }\n    return fraction.toString();\n}"}]}
{"url": "https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted", "source": []}
{"url": "https://leetcode-cn.com/problems/excel-sheet-column-title", "source": []}
{"url": "https://leetcode-cn.com/problems/majority-element", "source": []}
{"url": "https://leetcode-cn.com/problems/excel-sheet-column-number", "source": []}
{"url": "https://leetcode-cn.com/problems/factorial-trailing-zeroes", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-search-tree-iterator", "source": [{"lang": "Python", "code": "1. new_iterator = BSTIterator(root);\n2. while (new_iterator.hasNext())\n3.     process(new_iterator.next());"}, {"lang": "Java", "code": ""}, {"lang": "Python", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\nclass BSTIterator {\n\n    ArrayList<Integer> nodesSorted;\n    int index;\n\n    public BSTIterator(TreeNode root) {\n\n        // Array containing all the nodes in the sorted order\n        this.nodesSorted = new ArrayList<Integer>();\n        \n        // Pointer to the next smallest element in the BST\n        this.index = -1;\n        \n        // Call to flatten the input binary search tree\n        this._inorder(root);\n    }\n\n    private void _inorder(TreeNode root) {\n\n        if (root == null) {\n            return;\n        }\n\n        this._inorder(root.left);\n        this.nodesSorted.add(root.val);\n        this._inorder(root.right);\n    }\n\n    /**\n     * @return the next smallest number\n     */\n    public int next() {\n        return this.nodesSorted.get(++this.index);\n    }\n\n    /**\n     * @return whether we have a next smallest number\n     */\n    public boolean hasNext() {\n        return this.index + 1 < this.nodesSorted.size();\n    }\n}"}, {"lang": "Java", "code": "def inorder_left(root):\n   while (root):\n     S.append(root)\n     root = root.left"}]}
{"url": "https://leetcode-cn.com/problems/dungeon-game", "source": []}
{"url": "https://leetcode-cn.com/problems/largest-number", "source": [{"lang": "Java", "code": "class Solution {\n    private class LargerNumberComparator implements Comparator<String> {\n        @Override\n        public int compare(String a, String b) {\n            String order1 = a + b;\n            String order2 = b + a;\n           return order2.compareTo(order1);\n        }\n    }\n\n    public String largestNumber(int[] nums) {\n        // Get input integers as strings.\n        String[] asStrs = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            asStrs[i] = String.valueOf(nums[i]);\n        }\n\n        // Sort strings according to custom comparator.\n        Arrays.sort(asStrs, new LargerNumberComparator());\n\n        // If, after being sorted, the largest number is `0`, the entire number\n        // is zero.\n        if (asStrs[0].equals(\"0\")) {\n            return \"0\";\n        }\n\n        // Build largest number from sorted array.\n        String largestNumberStr = new String();\n        for (String numAsStr : asStrs) {\n            largestNumberStr += numAsStr;\n        }\n\n        return largestNumberStr;\n    }\n}"}, {"lang": "Python", "code": "class LargerNumKey(str):\n    def __lt__(x, y):\n        return x+y > y+x\n        \nclass Solution:\n    def largestNumber(self, nums):\n        largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey))\n        return '0' if largest_num[0] == '0' else largest_num"}]}
{"url": "https://leetcode-cn.com/problems/repeated-dna-sequences", "source": []}
{"url": "https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv", "source": []}
{"url": "https://leetcode-cn.com/problems/rotate-array", "source": [{"lang": "Java", "code": "public class Solution {\n    public void rotate(int[] nums, int k) {\n        int temp, previous;\n        for (int i = 0; i < k; i++) {\n            previous = nums[nums.length - 1];\n            for (int j = 0; j < nums.length; j++) {\n                temp = nums[j];\n                nums[j] = previous;\n                previous = temp;\n            }\n        }\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public void rotate(int[] nums, int k) {\n        int[] a = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            a[(i + k) % nums.length] = nums[i];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = a[i];\n        }\n    }\n}"}, {"lang": "Java", "code": "nums: [1, 2, 3, 4, 5, 6]\nk: 2"}, {"lang": "Java", "code": "public class Solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n        int count = 0;\n        for (int start = 0; count < nums.length; start++) {\n            int current = start;\n            int prev = nums[start];\n            do {\n                int next = (current + k) % nums.length;\n                int temp = nums[next];\n                nums[next] = prev;\n                prev = temp;\n                current = next;\n                count++;\n            } while (start != current);\n        }\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/reverse-bits", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-1-bits", "source": []}
{"url": "https://leetcode-cn.com/problems/house-robber", "source": [{"lang": "Java", "code": "public int rob(int[] num) {\n    int prevMax = 0;\n    int currMax = 0;\n    for (int x : num) {\n        int temp = currMax;\n        currMax = Math.max(prevMax + x, currMax);\n        prevMax = temp;\n    }\n    return currMax;\n}"}]}
{"url": "https://leetcode-cn.com/problems/binary-tree-right-side-view", "source": [{"lang": "Python", "code": "class Solution(object):\n    def rightSideView(self, root):\n        rightmost_value_at_depth = dict() # depth -> node.val\n        max_depth = -1\n\n        stack = [(root, 0)]\n        while stack:\n            node, depth = stack.pop()\n\n            if node is not None:\n                # maintain knowledge of the number of levels in the tree.\n                max_depth = max(max_depth, depth)\n\n                # only insert into dict if depth is not already present.\n                rightmost_value_at_depth.setdefault(depth, node.val)\n\n                stack.append((node.left, depth+1))\n                stack.append((node.right, depth+1))\n\n        return [rightmost_value_at_depth[depth] for depth in range(max_depth+1)]"}, {"lang": "Java", "code": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        Map<Integer, Integer> rightmostValueAtDepth = new HashMap<Integer, Integer>();\n        int max_depth = -1;\n\n        /* These two stacks are always synchronized, providing an implicit\n         * association values with the same offset on each stack. */\n        Stack<TreeNode> nodeStack = new Stack<TreeNode>();\n        Stack<Integer> depthStack = new Stack<Integer>();\n        nodeStack.push(root);\n        depthStack.push(0);\n\n        while (!nodeStack.isEmpty()) {\n            TreeNode node = nodeStack.pop();\n            int depth = depthStack.pop();\n\n            if (node != null) {\n                max_depth = Math.max(max_depth, depth);\n\n                /* The first node that we encounter at a particular depth contains\n                * the correct value. */\n                if (!rightmostValueAtDepth.containsKey(depth)) {\n                    rightmostValueAtDepth.put(depth, node.val);\n                }\n\n                nodeStack.push(node.left);\n                nodeStack.push(node.right);\n                depthStack.push(depth+1);\n                depthStack.push(depth+1);\n            }\n        }\n\n        /* Construct the solution based on the values that we end up with at the\n         * end. */\n        List<Integer> rightView = new ArrayList<Integer>();\n        for (int depth = 0; depth <= max_depth; depth++) {\n            rightView.add(rightmostValueAtDepth.get(depth));\n        }\n\n        return rightView;\n    }\n}"}, {"lang": "Python", "code": "from collections import deque\n\nclass Solution(object):\n    def rightSideView(self, root):\n        rightmost_value_at_depth = dict() # depth -> node.val\n        max_depth = -1\n\n        queue = deque([(root, 0)])\n        while queue:\n            node, depth = queue.popleft()\n\n            if node is not None:\n                # maintain knowledge of the number of levels in the tree.\n                max_depth = max(max_depth, depth)\n\n                # overwrite rightmost value at current depth. the correct value\n                # will never be overwritten, as it is always visited last.\n                rightmost_value_at_depth[depth] = node.val\n\n                queue.append((node.left, depth+1))\n                queue.append((node.right, depth+1))\n\n        return [rightmost_value_at_depth[depth] for depth in range(max_depth+1)]"}, {"lang": "Java", "code": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        Map<Integer, Integer> rightmostValueAtDepth = new HashMap<Integer, Integer>();\n        int max_depth = -1;\n\n        /* These two Queues are always synchronized, providing an implicit\n         * association values with the same offset on each Queue. */\n        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();\n        Queue<Integer> depthQueue = new LinkedList<Integer>();\n        nodeQueue.add(root);\n        depthQueue.add(0);\n\n        while (!nodeQueue.isEmpty()) {\n            TreeNode node = nodeQueue.remove();\n            int depth = depthQueue.remove();\n\n            if (node != null) {\n                max_depth = Math.max(max_depth, depth);\n\n                /* The last node that we encounter at a particular depth contains\n                * the correct value, so the correct value is never overwritten. */\n                rightmostValueAtDepth.put(depth, node.val);\n\n                nodeQueue.add(node.left);\n                nodeQueue.add(node.right);\n                depthQueue.add(depth+1);\n                depthQueue.add(depth+1);\n            }\n        }\n\n        /* Construct the solution based on the values that we end up with at the\n         * end. */\n        List<Integer> rightView = new ArrayList<Integer>();\n        for (int depth = 0; depth <= max_depth; depth++) {\n            rightView.add(rightmostValueAtDepth.get(depth));\n        }\n\n        return rightView;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/number-of-islands", "source": [{"lang": "C++", "code": "class Solution {\nprivate:\n  void dfs(vector<vector<char>>& grid, int r, int c) {\n    int nr = grid.size();\n    int nc = grid[0].size();\n\n    grid[r][c] = '0';\n    if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);\n    if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);\n    if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);\n    if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);\n  }\n\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          dfs(grid, r, c);\n        }\n      }\n    }\n\n    return num_islands;\n  }\n};"}, {"lang": "Java", "code": "class Solution {\n  void dfs(char[][] grid, int r, int c) {\n    int nr = grid.length;\n    int nc = grid[0].length;\n\n    if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {\n      return;\n    }\n\n    grid[r][c] = '0';\n    dfs(grid, r - 1, c);\n    dfs(grid, r + 1, c);\n    dfs(grid, r, c - 1);\n    dfs(grid, r, c + 1);\n  }\n\n  public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          dfs(grid, r, c);\n        }\n      }\n    }\n\n    return num_islands;\n  }\n}"}, {"lang": "C++", "code": "class Solution {\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          grid[r][c] = '0'; // mark as visited\n          queue<pair<int, int>> nei***ors;\n          nei***ors.push({r, c});\n          while (!nei***ors.empty()) {\n            auto rc = nei***ors.front();\n            nei***ors.pop();\n            int row = rc.first, col = rc.second;\n            if (row - 1 >= 0 && grid[row-1][col] == '1') {\n              nei***ors.push({row-1, col}); grid[row-1][col] = '0';\n            }\n            if (row + 1 < nr && grid[row+1][col] == '1') {\n              nei***ors.push({row+1, col}); grid[row+1][col] = '0';\n            }\n            if (col - 1 >= 0 && grid[row][col-1] == '1') {\n              nei***ors.push({row, col-1}); grid[row][col-1] = '0';\n            }\n            if (col + 1 < nc && grid[row][col+1] == '1') {\n              nei***ors.push({row, col+1}); grid[row][col+1] = '0';\n            }\n          }\n        }\n      }\n    }\n\n    return num_islands;\n  }\n};"}, {"lang": "Java", "code": "class Solution {\n  public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          grid[r][c] = '0'; // mark as visited\n          Queue<Integer> nei***ors = new LinkedList<>();\n          nei***ors.add(r * nc + c);\n          while (!nei***ors.isEmpty()) {\n            int id = nei***ors.remove();\n            int row = id / nc;\n            int col = id % nc;\n            if (row - 1 >= 0 && grid[row-1][col] == '1') {\n              nei***ors.add((row-1) * nc + col);\n              grid[row-1][col] = '0';\n            }\n            if (row + 1 < nr && grid[row+1][col] == '1') {\n              nei***ors.add((row+1) * nc + col);\n              grid[row+1][col] = '0';\n            }\n            if (col - 1 >= 0 && grid[row][col-1] == '1') {\n              nei***ors.add(row * nc + col-1);\n              grid[row][col-1] = '0';\n            }\n            if (col + 1 < nc && grid[row][col+1] == '1') {\n              nei***ors.add(row * nc + col+1);\n              grid[row][col+1] = '0';\n            }\n          }\n        }\n      }\n    }\n\n    return num_islands;\n  }\n}"}, {"lang": "C++", "code": "class UnionFind {\npublic:\n  UnionFind(vector<vector<char>>& grid) {\n    count = 0;\n    int m = grid.size();\n    int n = grid[0].size();\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (grid[i][j] == '1') {\n            parent.push_back(i * n + j);\n            ++count;\n          }\n          else parent.push_back(-1);\n          rank.push_back(0);\n        }\n    }\n  }\n\n  int find(int i) { // path compression\n    if (parent[i] != i) parent[i] = find(parent[i]);\n    return parent[i];\n  }\n\n  void Union(int x, int y) { // union with rank\n    int rootx = find(x);\n    int rooty = find(y);\n    if (rootx != rooty) {\n      if (rank[rootx] > rank[rooty]) parent[rooty] = rootx;\n      else if (rank[rootx] < rank[rooty]) parent[rootx] = rooty;\n      else {\n        parent[rooty] = rootx; rank[rootx] += 1;\n      }\n      --count;\n    }\n  }\n\n  int getCount() const {\n    return count;\n  }\n\nprivate:\n  vector<int> parent;\n  vector<int> rank;\n  int count; // # of connected components\n};\n\nclass Solution {\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    UnionFind uf (grid);\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          grid[r][c] = '0';\n          if (r - 1 >= 0 && grid[r-1][c] == '1') uf.Union(r * nc + c, (r-1) * nc + c);\n          if (r + 1 < nr && grid[r+1][c] == '1') uf.Union(r * nc + c, (r+1) * nc + c);\n          if (c - 1 >= 0 && grid[r][c-1] == '1') uf.Union(r * nc + c, r * nc + c - 1);\n          if (c + 1 < nc && grid[r][c+1] == '1') uf.Union(r * nc + c, r * nc + c + 1);\n        }\n      }\n    }\n\n    return uf.getCount();\n  }\n};"}, {"lang": "Java", "code": "class Solution {\n  class UnionFind {\n    int count; // # of connected components\n    int[] parent;\n    int[] rank;\n\n    public UnionFind(char[][] grid) { // for problem 200\n      count = 0;\n      int m = grid.length;\n      int n = grid[0].length;\n      parent = new int[m * n];\n      rank = new int[m * n];\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (grid[i][j] == '1') {\n            parent[i * n + j] = i * n + j;\n            ++count;\n          }\n          rank[i * n + j] = 0;\n        }\n      }\n    }\n\n    public int find(int i) { // path compression\n      if (parent[i] != i) parent[i] = find(parent[i]);\n      return parent[i];\n    }\n\n    public void union(int x, int y) { // union with rank\n      int rootx = find(x);\n      int rooty = find(y);\n      if (rootx != rooty) {\n        if (rank[rootx] > rank[rooty]) {\n          parent[rooty] = rootx;\n        } else if (rank[rootx] < rank[rooty]) {\n          parent[rootx] = rooty;\n        } else {\n          parent[rooty] = rootx; rank[rootx] += 1;\n        }\n        --count;\n      }\n    }\n\n    public int getCount() {\n      return count;\n    }\n  }\n\n  public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n    UnionFind uf = new UnionFind(grid);\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          grid[r][c] = '0';\n          if (r - 1 >= 0 && grid[r-1][c] == '1') {\n            uf.union(r * nc + c, (r-1) * nc + c);\n          }\n          if (r + 1 < nr && grid[r+1][c] == '1') {\n            uf.union(r * nc + c, (r+1) * nc + c);\n          }\n          if (c - 1 >= 0 && grid[r][c-1] == '1') {\n            uf.union(r * nc + c, r * nc + c - 1);\n          }\n          if (c + 1 < nc && grid[r][c+1] == '1') {\n            uf.union(r * nc + c, r * nc + c + 1);\n          }\n        }\n      }\n    }\n\n    return uf.getCount();\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/bitwise-and-of-numbers-range", "source": []}
{"url": "https://leetcode-cn.com/problems/happy-number", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-linked-list-elements", "source": [{"lang": "Python", "code": "class Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        sentinel = ListNode(0)\n        sentinel.next = head\n        \n        prev, curr = sentinel, head\n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return sentinel.next"}, {"lang": "Java", "code": "class Solution {\n  public ListNode removeElements(ListNode head, int val) {\n    ListNode sentinel = new ListNode(0);\n    sentinel.next = head;\n\n    ListNode prev = sentinel, curr = head;\n    while (curr != null) {\n      if (curr.val == val) prev.next = curr.next;\n      else prev = curr;\n      curr = curr.next;\n    }\n    return sentinel.next;\n  }\n}"}, {"lang": "C++", "code": "class Solution {\n  public:\n  ListNode* removeElements(ListNode* head, int val) {\n    ListNode* sentinel = new ListNode(0);\n    sentinel->next = head;\n\n    ListNode *prev = sentinel, *curr = head, *toDelete = nullptr;\n    while (curr != nullptr) {\n      if (curr->val == val) {\n        prev->next = curr->next;\n        toDelete = curr;\n      } else prev = curr;\n\n      curr = curr->next;\n\n      if (toDelete != nullptr) {\n        delete toDelete;\n        toDelete = nullptr;\n      }\n    }\n\n    ListNode *ret = sentinel->next;\n    delete sentinel;\n    return ret;\n  }\n};"}]}
{"url": "https://leetcode-cn.com/problems/count-primes", "source": []}
{"url": "https://leetcode-cn.com/problems/isomorphic-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-linked-list", "source": [{"lang": "Java", "code": "public ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode curr = head;\n    while (curr != null) {\n        ListNode nextTemp = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = nextTemp;\n    }\n    return prev;\n}"}, {"lang": "Java", "code": "public ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode p = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return p;\n}"}]}
{"url": "https://leetcode-cn.com/problems/course-schedule", "source": []}
{"url": "https://leetcode-cn.com/problems/implement-trie-prefix-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-size-subarray-sum", "source": [{"lang": "C++", "code": "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = 0;\n            for (int k = i; k <= j; k++) {\n                sum += nums[k];\n            }\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //Found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}"}, {"lang": "C++", "code": "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = INT_MAX;\n    vector<int> sums(n);\n    sums[0] = nums[0];\n    for (int i = 1; i < n; i++)\n        sums[i] = sums[i - 1] + nums[i];\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = sums[j] - sums[i] + nums[i];\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //Found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}"}, {"lang": "C++", "code": "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = INT_MAX;\n    vector<int> sums(n + 1, 0); //size = n+1 for easier calculations\n    //sums[0]=0 : Meaning that it is the sum of first 0 elements\n    //sums[1]=A[0] : Sum of first 1 elements\n    //ans so on...\n    for (int i = 1; i <= n; i++)\n        sums[i] = sums[i - 1] + nums[i - 1];\n    for (int i = 1; i <= n; i++) {\n        int to_find = s + sums[i - 1];\n        auto bound = lower_bound(sums.begin(), sums.end(), to_find);\n        if (bound != sums.end()) {\n            ans = min(ans, static_cast<int>(bound - (sums.begin() + i - 1)));\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}"}, {"lang": "C++", "code": "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        while (sum >= s) {\n            ans = min(ans, i + 1 - left);\n            sum -= nums[left++];\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}"}]}
{"url": "https://leetcode-cn.com/problems/course-schedule-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/add-and-search-word-data-structure-design", "source": []}
{"url": "https://leetcode-cn.com/problems/word-search-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/house-robber-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/shortest-palindrome", "source": [{"lang": "C++", "code": "string shortestPalindrome(string s)\n{\n    int n = s.size();\n    string rev(s);\n    reverse(rev.begin(), rev.end());\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        if (s.substr(0, n - i) == rev.substr(i))\n            return rev.substr(0, i) + s;\n    }\n    return \"\";\n}"}, {"lang": "C++", "code": "string shortestPalindrome(string s)\n{\n    int n = s.size();\n    int i = 0;\n    for (int j = n - 1; j >= 0; j--) {\n        if (s[i] == s[j])\n            i++;\n    }\n    if (i == n)\n        return s;\n    string remain_rev = s.substr(i, n);\n    reverse(remain_rev.begin(), remain_rev.end());\n    return remain_rev + shortestPalindrome(s.substr(0, i)) + s.substr(i);\n}"}, {"lang": "C++", "code": "f(0) = 0\nfor(i = 1; i < n; i++)\n{\n t = f(i-1)\n while(t > 0 && b[i] != b[t])\n  t = f(t-1)\n if(b[i] == b[t]){\n  ++t\n f(i) = t\n}"}]}
{"url": "https://leetcode-cn.com/problems/kth-largest-element-in-an-array", "source": []}
{"url": "https://leetcode-cn.com/problems/combination-sum-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/contains-duplicate", "source": []}
{"url": "https://leetcode-cn.com/problems/the-skyline-problem", "source": [{"lang": "Python", "code": "class Solution:\n    def getSkyline(self, buildings: 'List[List[int]]') -> 'List[List[int]]':\n        \"\"\"\n        Divide-and-conquer algorithm to solve skyline problem,\n        which is similar with the merge sort algorithm.\n        \"\"\"\n        n = len(buildings)\n        # The base cases\n        if n == 0:\n            return []\n        if n == 1:\n            x_start, x_end, y = buildings[0]\n            return [[x_start, y], [x_end, 0]] \n         \n        # If there is more than one building, \n        # recursively divide the input into two subproblems.\n        left_skyline = self.getSkyline(buildings[: n // 2])\n        right_skyline = self.getSkyline(buildings[n // 2 :])\n        \n        # Merge the results of subproblem together.\n        return self.merge_skylines(left_skyline, right_skyline)\n    \n    def merge_skylines(self, left, right):\n        \"\"\"\n        Merge two skylines together.\n        \"\"\"\n        def update_output(x, y):\n            \"\"\"\n            Update the final output with the new element.\n            \"\"\"\n            # if skyline change is not vertical - \n            # add the new point\n            if not output or output[-1][0] != x:\n                output.append([x, y])\n            # if skyline change is vertical - \n            # update the last point\n            else:\n                output[-1][1] = y\n        \n        def append_skyline(p, lst, n, y, curr_y):\n            \"\"\"\n            Append the rest of the skyline elements with indice (p, n)\n            to the final output.\n            \"\"\"\n            while p < n: \n                x, y = lst[p]\n                p += 1\n                if curr_y != y:\n                    update_output(x, y)\n                    curr_y = y\n                \n        n_l, n_r = len(left), len(right)\n        p_l = p_r = 0\n        curr_y  = left_y = right_y = 0\n        output = []\n            \n        # while we're in the region where both skylines are present\n        while p_l < n_l and p_r < n_r:\n            point_l, point_r = left[p_l], right[p_r]\n            # pick up the smallest x\n            if point_l[0] < point_r[0]: \n                x, left_y = point_l\n                p_l += 1\n            else: \n                x, right_y = point_r \n                p_r += 1\n            # max height (i.e. y) between both skylines\n            max_y = max(left_y, right_y)\n            # if there is a skyline change\n            if curr_y != max_y:\n                update_output(x, max_y)\n                curr_y = max_y\n\n        # there is only left skyline\n        append_skyline(p_l, left, n_l, left_y, curr_y)\n\n        # there is only right skyline\n        append_skyline(p_r, right, n_r, right_y, curr_y)\n                \n        return output"}, {"lang": "Java", "code": "class Solution {\n  /**\n   *  Divide-and-conquer algorithm to solve skyline problem, \n   *  which is similar with the merge sort algorithm.\n   */\n  public List<List<Integer>> getSkyline(int[][] buildings) {\n    int n = buildings.length;\n    List<List<Integer>> output = new ArrayList<List<Integer>>();\n\n    // The base cases \n    if (n == 0) return output;\n    if (n == 1) {\n      int xStart = buildings[0][0];\n      int xEnd = buildings[0][1];\n      int y = buildings[0][2];\n\n      output.add(new ArrayList<Integer>() {{add(xStart); add(y); }});\n      output.add(new ArrayList<Integer>() {{add(xEnd); add(0); }});\n      // output.add(new int[]{xStart, y});\n      // output.add(new int[]{xEnd, 0});\n      return output;\n    }\n\n    // If there is more than one building, \n    // recursively divide the input into two subproblems.\n    List<List<Integer>> leftSkyline, rightSkyline;\n    leftSkyline = getSkyline(Arrays.copyOfRange(buildings, 0, n / 2));\n    rightSkyline = getSkyline(Arrays.copyOfRange(buildings, n / 2, n));\n\n    // Merge the results of subproblem together.\n    return mergeSkylines(leftSkyline, rightSkyline);\n  }\n\n  /**\n   *  Merge two skylines together.\n   */\n  public List<List<Integer>> mergeSkylines(List<List<Integer>> left, List<List<Integer>> right) {\n    int nL = left.size(), nR = right.size();\n    int pL = 0, pR = 0;\n    int currY = 0, leftY = 0, rightY = 0;\n    int x, maxY;\n    List<List<Integer>> output = new ArrayList<List<Integer>>();\n\n    // while we're in the region where both skylines are present\n    while ((pL < nL) && (pR < nR)) {\n      List<Integer> pointL = left.get(pL);\n      List<Integer> pointR = right.get(pR);\n      // pick up the smallest x\n      if (pointL.get(0) < pointR.get(0)) {\n        x = pointL.get(0);\n        leftY = pointL.get(1);\n        pL++;\n      }\n      else {\n        x = pointR.get(0);\n        rightY = pointR.get(1);\n        pR++;\n      }\n      // max height (i.e. y) between both skylines\n      maxY = Math.max(leftY, rightY);\n      // update output if there is a skyline change\n      if (currY != maxY) {\n        updateOutput(output, x, maxY);\n        currY = maxY;\n      }\n    }\n\n    // there is only left skyline\n    appendSkyline(output, left, pL, nL, currY);\n\n    // there is only right skyline\n    appendSkyline(output, right, pR, nR, currY);\n\n    return output;\n  }\n\n  /**\n   * Update the final output with the new element.\n   */\n  public void updateOutput(List<List<Integer>> output, int x, int y) {\n    // if skyline change is not vertical - \n    // add the new point\n    if (output.isEmpty() || output.get(output.size() - 1).get(0) != x)\n      output.add(new ArrayList<Integer>() {{add(x); add(y); }});\n      // if skyline change is vertical - \n      // update the last point\n    else {\n      output.get(output.size() - 1).set(1, y);\n    }\n  }\n\n  /**\n   *  Append the rest of the skyline elements with indice (p, n)\n   *  to the final output.\n   */\n  public void appendSkyline(List<List<Integer>> output, List<List<Integer>> skyline,\n                            int p, int n, int currY) {\n    while (p < n) {\n      List<Integer> point = skyline.get(p);\n      int x = point.get(0);\n      int y = point.get(1);\n      p++;\n\n      // update output\n      // if there is a skyline change\n      if (currY != y) {\n        updateOutput(output, x, y);\n        currY = y;\n      }\n    }\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/contains-duplicate-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/contains-duplicate-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/maximal-square", "source": [{"lang": "Java", "code": "public class Solution {\n    public int maximalSquare(char[][] matrix) {\n        int rows = matrix.length, cols = rows > 0 ? matrix[0].length : 0;\n        int maxsqlen = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (matrix[i][j] == '1') {\n                    int sqlen = 1;\n                    boolean flag = true;\n                    while (sqlen + i < rows && sqlen + j < cols && flag) {\n                        for (int k = j; k <= sqlen + j; k++) {\n                            if (matrix[i + sqlen][k] == '0') {\n                                flag = false;\n                                break;\n                            }\n                        }\n                        for (int k = i; k <= sqlen + i; k++) {\n                            if (matrix[k][j + sqlen] == '0') {\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if (flag)\n                            sqlen++;\n                    }\n                    if (maxsqlen < sqlen) {\n                        maxsqlen = sqlen;\n                    }\n                }\n            }\n        }\n        return maxsqlen * maxsqlen;\n    }\n}"}, {"lang": "Java", "code": "0 1 1 1 0\n1 1 1 1 1\n0 1 1 1 1\n0 1 1 1 1\n0 0 1 1 1"}, {"lang": "Java", "code": "public class Solution {\n    public int maximalSquare(char[][] matrix) {\n        int rows = matrix.length, cols = rows > 0 ? matrix[0].length : 0;\n        int[][] dp = new int[rows + 1][cols + 1];\n        int maxsqlen = 0;\n        for (int i = 1; i <= rows; i++) {\n            for (int j = 1; j <= cols; j++) {\n                if (matrix[i-1][j-1] == '1'){\n                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n                    maxsqlen = Math.max(maxsqlen, dp[i][j]);\n                }\n            }\n        }\n        return maxsqlen * maxsqlen;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/count-complete-tree-nodes", "source": [{"lang": "Python", "code": "class Solution:\n    def countNodes(self, root: TreeNode) -> int:\n        return 1 + self.countNodes(root.right) + self.countNodes(root.left) if root else 0"}, {"lang": "Java", "code": "class Solution {\n  public int countNodes(TreeNode root) {\n    return root != null ? 1 + countNodes(root.right) + countNodes(root.left) : 0;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def compute_depth(self, node: TreeNode) -> int:\n        \"\"\"\n        Return tree depth in O(d) time.\n        \"\"\"\n        d = 0\n        while node.left:\n            node = node.left\n            d += 1\n        return d\n\n    def exists(self, idx: int, d: int, node: TreeNode) -> bool:\n        \"\"\"\n        Last level nodes are enumerated from 0 to 2**d - 1 (left -> right).\n        Return True if last level node idx exists. \n        Binary search with O(d) complexity.\n        \"\"\"\n        left, right = 0, 2**d - 1\n        for _ in range(d):\n            pivot = left + (right - left) // 2\n            if idx <= pivot:\n                node = node.left\n                right = pivot\n            else:\n                node = node.right\n                left = pivot + 1\n        return node is not None\n        \n    def countNodes(self, root: TreeNode) -> int:\n        # if the tree is empty\n        if not root:\n            return 0\n        \n        d = self.compute_depth(root)\n        # if the tree contains 1 node\n        if d == 0:\n            return 1\n        \n        # Last level nodes are enumerated from 0 to 2**d - 1 (left -> right).\n        # Perform binary search to check how many nodes exist.\n        left, right = 1, 2**d - 1\n        while left <= right:\n            pivot = left + (right - left) // 2\n            if self.exists(pivot, d, root):\n                left = pivot + 1\n            else:\n                right = pivot - 1\n        \n        # The tree contains 2**d - 1 nodes on the first (d - 1) levels\n        # and left nodes on the last level.\n        return (2**d - 1) + left"}, {"lang": "Java", "code": "class Solution {\n  // Return tree depth in O(d) time.\n  public int computeDepth(TreeNode node) {\n    int d = 0;\n    while (node.left != null) {\n      node = node.left;\n      ++d;\n    }\n    return d;\n  }\n\n  // Last level nodes are enumerated from 0 to 2**d - 1 (left -> right).\n  // Return True if last level node idx exists. \n  // Binary search with O(d) complexity.\n  public boolean exists(int idx, int d, TreeNode node) {\n    int left = 0, right = (int)Math.pow(2, d) - 1;\n    int pivot;\n    for(int i = 0; i < d; ++i) {\n      pivot = left + (right - left) / 2;\n      if (idx <= pivot) {\n        node = node.left;\n        right = pivot;\n      }\n      else {\n        node = node.right;\n        left = pivot + 1;\n      }\n    }\n    return node != null;\n  }\n\n  public int countNodes(TreeNode root) {\n    // if the tree is empty\n    if (root == null) return 0;\n\n    int d = computeDepth(root);\n    // if the tree contains 1 node\n    if (d == 0) return 1;\n\n    // Last level nodes are enumerated from 0 to 2**d - 1 (left -> right).\n    // Perform binary search to check how many nodes exist.\n    int left = 1, right = (int)Math.pow(2, d) - 1;\n    int pivot;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (exists(pivot, d, root)) left = pivot + 1;\n      else right = pivot - 1;\n    }\n\n    // The tree contains 2**d - 1 nodes on the first (d - 1) levels\n    // and left nodes on the last level.\n    return (int)Math.pow(2, d) - 1 + left;\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/rectangle-area", "source": []}
{"url": "https://leetcode-cn.com/problems/basic-calculator", "source": [{"lang": "Python", "code": "class Solution:\n\n    def evaluate_expr(self, stack):\n        res = stack.pop() if stack else 0\n\n        # Evaluate the expression till we get corresponding ')'\n        while stack and stack[-1] != ')':\n            sign = stack.pop()\n            if sign == '+':\n                res += stack.pop()\n            else:\n                res -= stack.pop()\n        return res       \n\n    def calculate(self, s: str) -> int:\n\n        stack = []\n        n, operand = 0, 0\n\n        for i in range(len(s) - 1, -1, -1):\n            ch = s[i]\n\n            if ch.isdigit():\n\n                # Forming the operand - in reverse order.\n                operand = (10**n * int(ch)) + operand\n                n += 1\n\n            elif ch != \" \":\n                if n:\n                    # Save the operand on the stack\n                    # As we encounter some non-digit.\n                    stack.append(operand)\n                    n, operand = 0, 0\n\n                if ch == '(':         \n                    res = self.evaluate_expr(stack)\n                    stack.pop()        \n\n                    # Append the evaluated result to the stack.\n                    # This result could be of a sub-expression within the parenthesis.\n                    stack.append(res)\n\n                # For other non-digits just push onto the stack.\n                else:\n                    stack.append(ch)\n\n        # Push the last operand to stack, if any.\n        if n:\n            stack.append(operand)\n\n        # Evaluate any left overs in the stack.\n        return self.evaluate_expr(stack)"}, {"lang": "Java", "code": "class Solution {\n\n    public int evaluateExpr(Stack<Object> stack) {\n\n        int res = 0;\n\n        if (!stack.empty()) {\n            res = (int) stack.pop();\n        }\n\n        // Evaluate the expression till we get corresponding ')'\n        while (!stack.empty() && !((char) stack.peek() == ')')) {\n\n            char sign = (char) stack.pop();\n\n            if (sign == '+') {\n                res += (int) stack.pop();\n            } else {\n                res -= (int) stack.pop();\n            }\n        }\n        return res;\n    }\n\n    public int calculate(String s) {\n\n        int operand = 0;\n        int n = 0;\n        Stack<Object> stack = new Stack<Object>();\n\n        for (int i = s.length() - 1; i >= 0; i--) {\n\n            char ch = s.charAt(i);\n\n            if (Character.isDigit(ch)) {\n\n                // Forming the operand - in reverse order.\n                operand = (int) Math.pow(10, n) * (int) (ch - '0') + operand;\n                n += 1;\n\n            } else if (ch != ' ') {\n                if (n != 0) {\n\n                    // Save the operand on the stack\n                    // As we encounter some non-digit.\n                    stack.push(operand);\n                    n = 0;\n                    operand = 0;\n\n                }\n                if (ch == '(') {\n\n                    int res = evaluateExpr(stack);\n                    stack.pop();\n\n                    // Append the evaluated result to the stack.\n                    // This result could be of a sub-expression within the parenthesis.\n                    stack.push(res);\n\n                } else {\n                    // For other non-digits just push onto the stack.\n                    stack.push(ch);\n                }\n            }\n        }\n\n        //Push the last operand to stack, if any.\n        if (n != 0) {\n            stack.push(operand);\n        }\n\n        // Evaluate any left overs in the stack.\n        return evaluateExpr(stack);\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def calculate(self, s: str) -> int:\n\n        stack = []\n        operand = 0\n        res = 0 # For the on-going result\n        sign = 1 # 1 means positive, -1 means negative  \n\n        for ch in s:\n            if ch.isdigit():\n\n                # Forming operand, since it could be more than one digit\n                operand = (operand * 10) + int(ch)\n\n            elif ch == '+':\n\n                # Evaluate the expression to the left,\n                # with result, sign, operand\n                res += sign * operand\n\n                # Save the recently encountered '+' sign\n                sign = 1\n\n                # Reset operand\n                operand = 0\n\n            elif ch == '-':\n\n                res += sign * operand\n                sign = -1\n                operand = 0\n\n            elif ch == '(':\n\n                # Push the result and sign on to the stack, for later\n                # We push the result first, then sign\n                stack.append(res)\n                stack.append(sign)\n\n                # Reset operand and result, as if new evaluation begins for the new sub-expression\n                sign = 1\n                res = 0\n\n            elif ch == ')':\n\n                # Evaluate the expression to the left\n                # with result, sign and operand\n                res += sign * operand\n\n                # ')' marks end of expression within a set of parenthesis\n                # Its result is multiplied with sign on top of stack\n                # as stack.pop() is the sign before the parenthesis\n                res *= stack.pop() # stack pop 1, sign\n\n                # Then add to the next operand on the top.\n                # as stack.pop() is the result calculated before this parenthesis\n                # (operand on stack) + (sign on stack * (result from parenthesis))\n                res += stack.pop() # stack pop 2, operand\n\n                # Reset the operand\n                operand = 0\n\n        return res + sign * operand"}, {"lang": "Java", "code": "class Solution {\n    public int calculate(String s) {\n\n        Stack<Integer> stack = new Stack<Integer>();\n        int operand = 0;\n        int result = 0; // For the on-going result\n        int sign = 1;  // 1 means positive, -1 means negative\n\n        for (int i = 0; i < s.length(); i++) {\n\n            char ch = s.charAt(i);\n            if (Character.isDigit(ch)) {\n\n                // Forming operand, since it could be more than one digit\n                operand = 10 * operand + (int) (ch - '0');\n\n            } else if (ch == '+') {\n\n                // Evaluate the expression to the left,\n                // with result, sign, operand\n                result += sign * operand;\n\n                // Save the recently encountered '+' sign\n                sign = 1;\n\n                // Reset operand\n                operand = 0;\n\n            } else if (ch == '-') {\n\n                result += sign * operand;\n                sign = -1;\n                operand = 0;\n\n            } else if (ch == '(') {\n\n                // Push the result and sign on to the stack, for later\n                // We push the result first, then sign\n                stack.push(result);\n                stack.push(sign);\n\n                // Reset operand and result, as if new evaluation begins for the new sub-expression\n                sign = 1;\n                result = 0;\n\n            } else if (ch == ')') {\n\n                // Evaluate the expression to the left\n                // with result, sign and operand\n                result += sign * operand;\n\n                // ')' marks end of expression within a set of parenthesis\n                // Its result is multiplied with sign on top of stack\n                // as stack.pop() is the sign before the parenthesis\n                result *= stack.pop();\n\n                // Then add to the next operand on the top.\n                // as stack.pop() is the result calculated before this parenthesis\n                // (operand on stack) + (sign on stack * (result from parenthesis))\n                result += stack.pop();\n\n                // Reset the operand\n                operand = 0;\n            }\n        }\n        return result + (sign * operand);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/implement-stack-using-queues", "source": [{"lang": "Java", "code": "private Queue<Integer> q1 = new LinkedList<>();\nprivate Queue<Integer> q2 = new LinkedList<>();\nprivate int top;\n\n// Push element x onto stack.\npublic void push(int x) {\n    q1.add(x);\n    top = x;\n}"}, {"lang": "Java", "code": "// Removes the element on top of the stack.\npublic void pop() {\n    while (q1.size() > 1) {\n        top = q1.remove();\n        q2.add(top);\n    }\n    q1.remove();\n    Queue<Integer> temp = q1;\n    q1 = q2;\n    q2 = temp;\n}"}, {"lang": "Java", "code": "public void push(int x) {\n    q2.add(x);\n    top = x;\n    while (!q1.isEmpty()) {                \n        q2.add(q1.remove());\n    }\n    Queue<Integer> temp = q1;\n    q1 = q2;\n    q2 = temp;\n}"}, {"lang": "Java", "code": "// Removes the element on top of the stack.\npublic void pop() {\n    q1.remove();\n    if (!q1.isEmpty()) {\n     top = q1.peek();\n    }\n}"}, {"lang": "Java", "code": "// Removes the element on top of the stack.\npublic void pop() {\n    q1.remove();\n    if (!q1.isEmpty()) {\n     top = q1.peek();\n    }\n}"}, {"lang": "Java", "code": "// Get the top element.\npublic int top() {\n    return top;\n}"}, {"lang": "Java", "code": "private LinkedList<Integer> q1 = new LinkedList<>();\n\n// Push element x onto stack.\npublic void push(int x) {\n    q1.add(x);\n    int sz = q1.size();\n    while (sz > 1) {\n        q1.add(q1.remove());\n        sz--;\n    }\n}"}, {"lang": "Java", "code": "// Removes the element on top of the stack.\npublic void pop() {\n    q1.remove();\n}"}, {"lang": "Java", "code": "// Return whether the stack is empty.\npublic boolean empty() {\n    return q1.isEmpty();\n}"}, {"lang": "Java", "code": "// Get the top element.\npublic int top() {\n    return q1.peek();\n}"}]}
{"url": "https://leetcode-cn.com/problems/invert-binary-tree", "source": [{"lang": "Java", "code": "public TreeNode invertTree(TreeNode root) {\n    if (root == null) {\n        return null;\n    }\n    TreeNode right = invertTree(root.right);\n    TreeNode left = invertTree(root.left);\n    root.left = right;\n    root.right = left;\n    return root;\n}"}, {"lang": "Java", "code": "public TreeNode invertTree(TreeNode root) {\n    if (root == null) return null;\n    Queue<TreeNode> queue = new LinkedList<TreeNode>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        TreeNode current = queue.poll();\n        TreeNode temp = current.left;\n        current.left = current.right;\n        current.right = temp;\n        if (current.left != null) queue.add(current.left);\n        if (current.right != null) queue.add(current.right);\n    }\n    return root;\n}"}]}
{"url": "https://leetcode-cn.com/problems/basic-calculator-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/summary-ranges", "source": [{"lang": "1", "code": "public class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> summary = new ArrayList<>();\n        for (int i = 0, j = 0; j < nums.length; ++j) {\n            // check if j + 1 extends the range [nums[i], nums[j]]\n            if (j + 1 < nums.length && nums[j + 1] == nums[j] + 1)\n                continue;\n            // put the range [nums[i], nums[j]] into the list\n            if (i == j)\n                summary.add(nums[i] + \"\");\n            else\n                summary.add(nums[i] + \"->\" + nums[j]);\n            i = j + 1;\n        }\n        return summary;\n    }\n}"}, {"lang": "1", "code": "public class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> summary = new ArrayList<>();\n        for (int i, j = 0; j < nums.length; ++j){\n            i = j;\n            // try to extend the range [nums[i], nums[j]]\n            while (j + 1 < nums.length && nums[j + 1] == nums[j] + 1)\n                ++j;\n            // put the range into the list\n            if (i == j)\n                summary.add(nums[i] + \"\");\n            else\n                summary.add(nums[i] + \"->\" + nums[j]);\n        }\n        return summary;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/majority-element-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst", "source": []}
{"url": "https://leetcode-cn.com/problems/power-of-two", "source": []}
{"url": "https://leetcode-cn.com/problems/implement-queue-using-stacks", "source": [{"lang": "Java", "code": "private int front;\n\npublic void push(int x) {\n    if (s1.empty())\n        front = x;\n    while (!s1.isEmpty())\n        s2.push(s1.pop());\n    s2.push(x);\n    while (!s2.isEmpty())\n        s1.push(s2.pop());\n}"}, {"lang": "Java", "code": "// Removes the element from the front of queue.\npublic void pop() {\n    s1.pop();\n    if (!s1.empty())\n        front = s1.peek();\n}"}, {"lang": "Java", "code": "// Return whether the queue is empty.\npublic boolean empty() {\n    return s1.isEmpty();\n}"}, {"lang": "Java", "code": "// Get the front element.\npublic int peek() {\n  return front;\n}"}, {"lang": "Java", "code": "private Stack<Integer> s1 = new Stack<>();\nprivate Stack<Integer> s2 = new Stack<>();\n\n// Push element x to the back of queue.\npublic void push(int x) {\n    if (s1.empty())\n        front = x;\n    s1.push(x);\n}"}, {"lang": "Java", "code": "// Removes the element from in front of queue.\npublic void pop() {\n    if (s2.isEmpty()) {\n        while (!s1.isEmpty())\n            s2.push(s1.pop());\n    }\n    s2.pop();    \n}"}, {"lang": "Java", "code": "// Return whether the queue is empty.\npublic boolean empty() {\n    return s1.isEmpty() && s2.isEmpty();\n}"}, {"lang": "Java", "code": "// Get the front element.\npublic int peek() {\n    if (!s2.isEmpty()) {\n        return s2.peek();\n    }\n    return front;\n}"}]}
{"url": "https://leetcode-cn.com/problems/number-of-digit-one", "source": []}
{"url": "https://leetcode-cn.com/problems/palindrome-linked-list", "source": [{"lang": "Python", "code": "def isPalindrome(self, head: ListNode) -> bool:\n    vals = []\n    current_node = head\n    while current_node is not None:\n        vals.append(current_node.val)\n        current_node = current_node.next\n    return vals == vals[::-1]"}, {"lang": "Java", "code": "class Solution {\n    public boolean isPalindrome(ListNode head) {\n        List<Integer> vals = new ArrayList<>();\n\n        // Convert LinkedList into ArrayList.\n        ListNode currentNode = head;\n        while (currentNode != null) {\n            vals.add(currentNode.val);\n            currentNode = currentNode.next;\n        }\n\n        // Use two-pointer technique to check for palindrome.\n        int front = 0;\n        int back = vals.size() - 1;\n        while (front < back) {\n            // Note that we must use ! .equals instead of !=\n            // because we are comparing Integer, not int.\n            if (!vals.get(front).equals(vals.get(back))) {\n                return false;\n            }\n            front++;\n            back--;\n        }\n        return true;\n    }\n}"}, {"lang": "Python", "code": "function print_values_in_reverse(ListNode head)\n    if head is NOT null\n        print_values_in_reverse(head.next)\n        print head.val"}, {"lang": "Java", "code": ""}, {"lang": "Python", "code": "class Solution {\n\n    private ListNode frontPointer;\n\n    private boolean recursivelyCheck(ListNode currentNode) {\n        if (currentNode != null) {\n            if (!recursivelyCheck(currentNode.next)) return false;\n            if (currentNode.val != frontPointer.val) return false;\n            frontPointer = frontPointer.next;\n        }\n        return true;\n    }\n\n    public boolean isPalindrome(ListNode head) {\n        frontPointer = head;\n        return recursivelyCheck(head);\n    }\n}"}, {"lang": "Java", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/delete-node-in-a-linked-list", "source": [{"lang": "Java", "code": "public void deleteNode(ListNode node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n}"}]}
{"url": "https://leetcode-cn.com/problems/product-of-array-except-self", "source": [{"lang": "Python", "code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        # The length of the input array \n        length = len(nums)\n        \n        # The left and right arrays as described in the algorithm\n        L, R, answer = [0]*length, [0]*length, [0]*length\n        \n        # L[i] contains the product of all the elements to the left\n        # Note: for the element at index '0', there are no elements to the left,\n        # so the L[0] would be 1\n        L[0] = 1\n        for i in range(1, length):\n            \n            # L[i - 1] already contains the product of elements to the left of 'i - 1'\n            # Simply multiplying it with nums[i - 1] would give the product of all \n            # elements to the left of index 'i'\n            L[i] = nums[i - 1] * L[i - 1]\n        \n        # R[i] contains the product of all the elements to the right\n        # Note: for the element at index 'length - 1', there are no elements to the right,\n        # so the R[length - 1] would be 1\n        R[length - 1] = 1\n        for i in reversed(range(length - 1)):\n            \n            # R[i + 1] already contains the product of elements to the right of 'i + 1'\n            # Simply multiplying it with nums[i + 1] would give the product of all \n            # elements to the right of index 'i'\n            R[i] = nums[i + 1] * R[i + 1]\n        \n        # Constructing the answer array\n        for i in range(length):\n            # For the first element, R[i] would be product except self\n            # For the last element of the array, product except self would be L[i]\n            # Else, multiple product of all elements to the left and to the right\n            answer[i] = L[i] * R[i]\n        \n        return answer"}, {"lang": "Java", "code": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n\n        // The length of the input array\n        int length = nums.length;\n\n        // The left and right arrays as described in the algorithm\n        int[] L = new int[length];\n        int[] R = new int[length];\n\n        // Final answer array to be returned\n        int[] answer = new int[length];\n\n        // L[i] contains the product of all the elements to the left\n        // Note: for the element at index '0', there are no elements to the left,\n        // so L[0] would be 1\n        L[0] = 1;\n        for (int i = 1; i < length; i++) {\n\n            // L[i - 1] already contains the product of elements to the left of 'i - 1'\n            // Simply multiplying it with nums[i - 1] would give the product of all\n            // elements to the left of index 'i'\n            L[i] = nums[i - 1] * L[i - 1];\n        }\n\n        // R[i] contains the product of all the elements to the right\n        // Note: for the element at index 'length - 1', there are no elements to the right,\n        // so the R[length - 1] would be 1\n        R[length - 1] = 1;\n        for (int i = length - 2; i >= 0; i--) {\n\n            // R[i + 1] already contains the product of elements to the right of 'i + 1'\n            // Simply multiplying it with nums[i + 1] would give the product of all\n            // elements to the right of index 'i'\n            R[i] = nums[i + 1] * R[i + 1];\n        }\n\n        // Constructing the answer array\n        for (int i = 0; i < length; i++) {\n            // For the first element, R[i] would be product except self\n            // For the last element of the array, product except self would be L[i]\n            // Else, multiple product of all elements to the left and to the right\n            answer[i] = L[i] * R[i];\n        }\n\n        return answer;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \n        # The length of the input array \n        length = len(nums)\n        \n        # The answer array to be returned\n        answer = [0]*length\n        \n        # answer[i] contains the product of all the elements to the left\n        # Note: for the element at index '0', there are no elements to the left,\n        # so the answer[0] would be 1\n        answer[0] = 1\n        for i in range(1, length):\n            \n            # answer[i - 1] already contains the product of elements to the left of 'i - 1'\n            # Simply multiplying it with nums[i - 1] would give the product of all \n            # elements to the left of index 'i'\n            answer[i] = nums[i - 1] * answer[i - 1]\n        \n        # R contains the product of all the elements to the right\n        # Note: for the element at index 'length - 1', there are no elements to the right,\n        # so the R would be 1\n        R = 1;\n        for i in reversed(range(length)):\n            \n            # For the index 'i', R would contain the \n            # product of all elements to the right. We update R accordingly\n            answer[i] = answer[i] * R\n            R *= nums[i]\n        \n        return answer"}, {"lang": "Java", "code": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n\n        // The length of the input array \n        int length = nums.length;\n\n        // Final answer array to be returned\n        int[] answer = new int[length];\n\n        // answer[i] contains the product of all the elements to the left\n        // Note: for the element at index '0', there are no elements to the left,\n        // so the answer[0] would be 1\n        answer[0] = 1;\n        for (int i = 1; i < length; i++) {\n\n            // answer[i - 1] already contains the product of elements to the left of 'i - 1'\n            // Simply multiplying it with nums[i - 1] would give the product of all \n            // elements to the left of index 'i'\n            answer[i] = nums[i - 1] * answer[i - 1];\n        }\n\n        // R contains the product of all the elements to the right\n        // Note: for the element at index 'length - 1', there are no elements to the right,\n        // so the R would be 1\n        int R = 1;\n        for (int i = length - 1; i >= 0; i--) {\n\n            // For the index 'i', R would contain the \n            // product of all elements to the right. We update R accordingly\n            answer[i] = answer[i] * R;\n            R *= nums[i];\n        }\n\n        return answer;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/sliding-window-maximum", "source": []}
{"url": "https://leetcode-cn.com/problems/search-a-2d-matrix-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/different-ways-to-add-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-anagram", "source": [{"lang": "Java", "code": "public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    char[] str1 = s.toCharArray();\n    char[] str2 = t.toCharArray();\n    Arrays.sort(str1);\n    Arrays.sort(str2);\n    return Arrays.equals(str1, str2);\n}"}, {"lang": "Java", "code": "public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    int[] counter = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n        counter[s.charAt(i) - 'a']++;\n        counter[t.charAt(i) - 'a']--;\n    }\n    for (int count : counter) {\n        if (count != 0) {\n            return false;\n        }\n    }\n    return true;\n}"}, {"lang": "Java", "code": "public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    int[] table = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n        table[s.charAt(i) - 'a']++;\n    }\n    for (int i = 0; i < t.length(); i++) {\n        table[t.charAt(i) - 'a']--;\n        if (table[t.charAt(i) - 'a'] < 0) {\n            return false;\n        }\n    }\n    return true;\n}"}]}
{"url": "https://leetcode-cn.com/problems/binary-tree-paths", "source": [{"lang": "Java", "code": "/* Definition for a binary tree node. */\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n}"}, {"lang": "Python", "code": "class TreeNode(object):\n    \"\"\" Definition of a binary tree node.\"\"\"\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None"}, {"lang": "Java", "code": "class Solution {\n    public void construct_paths(TreeNode root, String path, LinkedList<String> paths) {\n        if (root != null) {\n            path += Integer.toString(root.val);\n            if ((root.left == null) && (root.right == null))  // 当前节点是叶子节点\n                paths.add(path);  // 把路径加入到答案中\n            else {\n                path += \"->\";  // 当前节点不是叶子节点，继续递归遍历\n                construct_paths(root.left, path, paths);\n                construct_paths(root.right, path, paths);\n            }\n        }\n    }\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        LinkedList<String> paths = new LinkedList();\n        construct_paths(root, \"\", paths);\n        return paths;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        def construct_paths(root, path):\n            if root:\n                path += str(root.val)\n                if not root.left and not root.right:  # 当前节点是叶子节点\n                    paths.append(path)  # 把路径加入到答案中\n                else:\n                    path += '->'  # 当前节点不是叶子节点，继续递归遍历\n                    construct_paths(root.left, path)\n                    construct_paths(root.right, path)\n\n        paths = []\n        construct_paths(root, '')\n        return paths"}, {"lang": "Java", "code": "class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        LinkedList<String> paths = new LinkedList();\n        if (root == null)\n            return paths;\n\n        LinkedList<TreeNode> node_stack = new LinkedList();\n        LinkedList<String> path_stack = new LinkedList();\n        node_stack.add(root);\n        path_stack.add(Integer.toString(root.val));\n        TreeNode node;\n        String path;\n        while (!node_stack.isEmpty()) {\n            node = node_stack.pollLast();\n            path = path_stack.pollLast();\n            if ((node.left == null) && (node.right == null))\n                paths.add(path);\n            if (node.left != null) {\n                node_stack.add(node.left);\n                path_stack.add(path + \"->\" + Integer.toString(node.left.val));\n            }\n            if (node.right != null) {\n                node_stack.add(node.right);\n                path_stack.add(path + \"->\" + Integer.toString(node.right.val));\n            }\n        }\n        return paths;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        if not root:\n            return []\n        \n        paths = []\n        stack = [(root, str(root.val))]\n        while stack:\n            node, path = stack.pop()\n            if not node.left and not node.right:\n                paths.append(path)\n            if node.left:\n                stack.append((node.left, path + '->' + str(node.left.val)))\n            if node.right:\n                stack.append((node.right, path + '->' + str(node.right.val)))\n        \n        return paths"}]}
{"url": "https://leetcode-cn.com/problems/add-digits", "source": []}
{"url": "https://leetcode-cn.com/problems/single-number-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/ugly-number", "source": []}
{"url": "https://leetcode-cn.com/problems/ugly-number-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/missing-number", "source": [{"lang": "Java", "code": "class Solution {\n    public int missingNumber(int[] nums) {\n        Arrays.sort(nums);\n\n        // 判断 n 是否出现在末位\n        if (nums[nums.length-1] != nums.length) {\n            return nums.length;\n        }\n        // 判断 0 是否出现在首位\n        else if (nums[0] != 0) {\n            return 0;\n        }\n\n        // 此时缺失的数字一定在 (0, n) 中\n        for (int i = 1; i < nums.length; i++) {\n            int expectedNum = nums[i-1] + 1;\n            if (nums[i] != expectedNum) {\n                return expectedNum;\n            }\n        }\n\n        // 未缺失任何数字（保证函数有返回值）\n        return -1;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def missingNumber(self, nums):\n        nums.sort()\n\n        # Ensure that n is at the last index\n        if nums[-1] != len(nums):\n            return len(nums)\n        # Ensure that 0 is at the first index\n        elif nums[0] != 0:\n            return 0\n\n        # If we get here, then the missing number is on the range (0, n)\n        for i in range(1, len(nums)):\n            expected_num = nums[i-1] + 1\n            if nums[i] != expected_num:\n                return expected_num"}, {"lang": "Java", "code": "class Solution {\n    public int missingNumber(int[] nums) {\n        Set<Integer> numSet = new HashSet<Integer>();\n        for (int num : nums) numSet.add(num);\n\n        int expectedNumCount = nums.length + 1;\n        for (int number = 0; number < expectedNumCount; number++) {\n            if (!numSet.contains(number)) {\n                return number;\n            }\n        }\n        return -1;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def missingNumber(self, nums):\n        num_set = set(nums)\n        n = len(nums) + 1\n        for number in range(n):\n            if number not in num_set:\n                return number"}, {"lang": "Java", "code": "class Solution {\n    public int missingNumber(int[] nums) {\n        int missing = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            missing ^= i ^ nums[i];\n        }\n        return missing;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def missingNumber(self, nums):\n        missing = len(nums)\n        for i, num in enumerate(nums):\n            missing ^= i ^ num\n        return missing"}, {"lang": "Java", "code": "class Solution {\n    public int missingNumber(int[] nums) {\n        int expectedSum = nums.length*(nums.length + 1)/2;\n        int actualSum = 0;\n        for (int num : nums) actualSum += num;\n        return expectedSum - actualSum;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def missingNumber(self, nums):\n        expected_sum = len(nums)*(len(nums)+1)//2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum"}]}
{"url": "https://leetcode-cn.com/problems/integer-to-english-words", "source": [{"lang": "Java", "code": "class Solution {\n    public String one(int num) {\n        switch(num) {\n            case 1: return \"One\";\n            case 2: return \"Two\";\n            case 3: return \"Three\";\n            case 4: return \"Four\";\n            case 5: return \"Five\";\n            case 6: return \"Six\";\n            case 7: return \"Seven\";\n            case 8: return \"Eight\";\n            case 9: return \"Nine\";\n        }\n        return \"\";\n    }\n\n    public String twoLessThan20(int num) {\n        switch(num) {\n            case 10: return \"Ten\";\n            case 11: return \"Eleven\";\n            case 12: return \"Twelve\";\n            case 13: return \"Thirteen\";\n            case 14: return \"Fourteen\";\n            case 15: return \"Fifteen\";\n            case 16: return \"Sixteen\";\n            case 17: return \"Seventeen\";\n            case 18: return \"Eighteen\";\n            case 19: return \"Nineteen\";\n        }\n        return \"\";\n    }\n\n    public String ten(int num) {\n        switch(num) {\n            case 2: return \"Twenty\";\n            case 3: return \"Thirty\";\n            case 4: return \"Forty\";\n            case 5: return \"Fifty\";\n            case 6: return \"Sixty\";\n            case 7: return \"Seventy\";\n            case 8: return \"Eighty\";\n            case 9: return \"Ninety\";\n        }\n        return \"\";\n    }\n\n    public String two(int num) {\n        if (num == 0)\n            return \"\";\n        else if (num < 10)\n            return one(num);\n        else if (num < 20)\n            return twoLessThan20(num);\n        else {\n            int tenner = num / 10;\n            int rest = num - tenner * 10;\n            if (rest != 0)\n              return ten(tenner) + \" \" + one(rest);\n            else\n              return ten(tenner);\n        }\n    }\n\n    public String three(int num) {\n        int hundred = num / 100;\n        int rest = num - hundred * 100;\n        String res = \"\";\n        if (hundred * rest != 0)\n            res = one(hundred) + \" Hundred \" + two(rest);\n        else if ((hundred == 0) && (rest != 0))\n            res = two(rest);\n        else if ((hundred != 0) && (rest == 0))\n            res = one(hundred) + \" Hundred\";\n        return res;\n    }\n\n    public String numberToWords(int num) {\n        if (num == 0)\n            return \"Zero\";\n\n        int billion = num / 1000000000;\n        int million = (num - billion * 1000000000) / 1000000;\n        int thousand = (num - billion * 1000000000 - million * 1000000) / 1000;\n        int rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000;\n\n        String result = \"\";\n        if (billion != 0)\n            result = three(billion) + \" Billion\";\n        if (million != 0) {\n            if (! result.isEmpty())\n                result += \" \";\n            result += three(million) + \" Million\";\n        }\n        if (thousand != 0) {\n            if (! result.isEmpty())\n                result += \" \";\n            result += three(thousand) + \" Thousand\";\n        }\n        if (rest != 0) {\n            if (! result.isEmpty())\n                result += \" \";\n            result += three(rest);\n        }\n        return result;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        def one(num):\n            switcher = {\n                1: 'One',\n                2: 'Two',\n                3: 'Three',\n                4: 'Four',\n                5: 'Five',\n                6: 'Six',\n                7: 'Seven',\n                8: 'Eight',\n                9: 'Nine'\n            }\n            return switcher.get(num)\n\n        def two_less_20(num):\n            switcher = {\n                10: 'Ten',\n                11: 'Eleven',\n                12: 'Twelve',\n                13: 'Thirteen',\n                14: 'Fourteen',\n                15: 'Fifteen',\n                16: 'Sixteen',\n                17: 'Seventeen',\n                18: 'Eighteen',\n                19: 'Nineteen'\n            }\n            return switcher.get(num)\n\n        def ten(num):\n            switcher = {\n                2: 'Twenty',\n                3: 'Thirty',\n                4: 'Forty',\n                5: 'Fifty',\n                6: 'Sixty',\n                7: 'Seventy',\n                8: 'Eighty',\n                9: 'Ninety'\n            }\n            return switcher.get(num)\n\n        def two(num):\n            if not num:\n                return ''\n            elif num < 10:\n                return one(num)\n            elif num < 20:\n                return two_less_20(num)\n            else:\n                tenner = num // 10\n                rest = num - tenner * 10\n                return ten(tenner) + ' ' + one(rest) if rest else ten(tenner)\n\n        def three(num):\n            hundred = num // 100\n            rest = num - hundred * 100\n            if hundred and rest:\n                return one(hundred) + ' Hundred ' + two(rest) \n            elif not hundred and rest: \n                return two(rest)\n            elif hundred and not rest:\n                return one(hundred) + ' Hundred'\n\n        billion = num // 1000000000\n        million = (num - billion * 1000000000) // 1000000\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\n        rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000\n\n        if not num:\n            return 'Zero'\n\n        result = ''\n        if billion:\n            result = three(billion) + ' Billion'\n        if million:\n            result += ' ' if result else ''\n            result += three(million) + ' Million'\n        if thousand:\n            result += ' ' if result else ''\n            result += three(thousand) + ' Thousand'\n        if rest:\n            result += ' ' if result else ''\n            result += three(rest)\n        return result"}]}
{"url": "https://leetcode-cn.com/problems/h-index", "source": []}
{"url": "https://leetcode-cn.com/problems/h-index-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/first-bad-version", "source": [{"lang": "Java", "code": "public int firstBadVersion(int n) {\n    for (int i = 1; i < n; i++) {\n        if (isBadVersion(i)) {\n            return i;\n        }\n    }\n    return n;\n}"}, {"lang": "Java", "code": "场景一：isBadVersion(mid) => false\n\n 1 2 3 4 5 6 7 8 9\n G G G G G G B B B       G = 正确版本，B = 错误版本\n |       |       |\nleft    mid    right"}]}
{"url": "https://leetcode-cn.com/problems/perfect-squares", "source": []}
{"url": "https://leetcode-cn.com/problems/expression-add-operators", "source": [{"lang": "Java", "code": "1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3\n1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51\n1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45"}, {"lang": "Python", "code": "1 * 23 - 4 + 5 + 6 = 30\n12 - 3 * 4 + 5 * 6 = 30\n1 - 23 - 4 + 56 = 30"}]}
{"url": "https://leetcode-cn.com/problems/move-zeroes", "source": [{"lang": "C++", "code": "void moveZeroes(vector<int>& nums) {\n    int n = nums.size();\n\n    // Count the zeroes\n    int numZeroes = 0;\n    for (int i = 0; i < n; i++) {\n        numZeroes += (nums[i] == 0);\n    }\n\n    // Make all the non-zero elements retain their original order.\n    vector<int> ans;\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            ans.push_back(nums[i]);\n        }\n    }\n\n    // Move all zeroes to the end\n    while (numZeroes--) {\n        ans.push_back(0);\n    }\n\n    // Combine the result\n    for (int i = 0; i < n; i++) {\n        nums[i] = ans[i];\n    }\n}"}, {"lang": "C++", "code": "void moveZeroes(vector<int>& nums) {\n    int lastNonZeroFoundAt = 0;\n    // If the current element is not 0, then we need to\n    // append it just in front of last non 0 element we found. \n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[lastNonZeroFoundAt++] = nums[i];\n        }\n    }\n    // After we have finished processing new elements,\n    // all the non-zero elements are already at beginning of array.\n    // We just need to fill remaining array with 0's.\n    for (int i = lastNonZeroFoundAt; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}"}, {"lang": "C++", "code": "void moveZeroes(vector<int>& nums) {\n    for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {\n        if (nums[cur] != 0) {\n            swap(nums[lastNonZeroFoundAt++], nums[cur]);\n        }\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/peeking-iterator", "source": []}
{"url": "https://leetcode-cn.com/problems/find-the-duplicate-number", "source": []}
{"url": "https://leetcode-cn.com/problems/game-of-life", "source": []}
{"url": "https://leetcode-cn.com/problems/word-pattern", "source": []}
{"url": "https://leetcode-cn.com/problems/nim-game", "source": []}
{"url": "https://leetcode-cn.com/problems/find-median-from-data-stream", "source": [{"lang": "C++", "code": "class MedianFinder {\n    vector<double> store;\n\npublic:\n    // Adds a number into the data structure.\n    void addNum(int num)\n    {\n        store.push_back(num);\n    }\n\n    // Returns the median of current data stream\n    double findMedian()\n    {\n        sort(store.begin(), store.end());\n\n        int n = store.size();\n        return (n & 1 ? store[n / 2] : (store[n / 2 - 1] + store[n / 2]) * 0.5);\n    }\n};"}, {"lang": "C++", "code": "class MedianFinder {\n    vector<int> store; // resize-able container\n\npublic:\n    // Adds a number into the data structure.\n    void addNum(int num)\n    {\n        if (store.empty())\n            store.push_back(num);\n        else\n            store.insert(lower_bound(store.begin(), store.end(), num), num);     // binary search and insertion combined\n    }\n\n    // Returns the median of current data stream\n    double findMedian()\n    {\n        int n = store.size();\n        return n & 1 ? store[n / 2] : (store[n / 2 - 1] + store[n / 2]) * 0.5;\n    }\n};"}, {"lang": "C++", "code": "Adding number 41\nMaxHeap lo: [41]           // MaxHeap stores the largest value at the top (index 0)\nMinHeap hi: []             // MinHeap stores the smallest value at the top (index 0)\nMedian is 41\n=======================\nAdding number 35\nMaxHeap lo: [35]\nMinHeap hi: [41]\nMedian is 38\n=======================\nAdding number 62\nMaxHeap lo: [41, 35]\nMinHeap hi: [62]\nMedian is 41\n=======================\nAdding number 4\nMaxHeap lo: [35, 4]\nMinHeap hi: [41, 62]\nMedian is 38\n=======================\nAdding number 97\nMaxHeap lo: [41, 35, 4]\nMinHeap hi: [62, 97]\nMedian is 41\n=======================\nAdding number 108\nMaxHeap lo: [41, 35, 4]\nMinHeap hi: [62, 97, 108]\nMedian is 51.5"}, {"lang": "C++", "code": "class MedianFinder {\n    priority_queue<int> lo;                              // max heap\n    priority_queue<int, vector<int>, greater<int>> hi;   // min heap\n\npublic:\n    // Adds a number into the data structure.\n    void addNum(int num)\n    {\n        lo.push(num);                                    // Add to max heap\n\n        hi.push(lo.top());                               // balancing step\n        lo.pop();\n\n        if (lo.size() < hi.size()) {                     // maintain size property\n            lo.push(hi.top());\n            hi.pop();\n        }\n    }\n\n    // Returns the median of current data stream\n    double findMedian()\n    {\n        return lo.size() > hi.size() ? (double) lo.top() : (lo.top() + hi.top()) * 0.5;\n    }\n};"}]}
{"url": "https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/bulls-and-cows", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-increasing-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-invalid-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/range-sum-query-immutable", "source": []}
{"url": "https://leetcode-cn.com/problems/range-sum-query-2d-immutable", "source": []}
{"url": "https://leetcode-cn.com/problems/additive-number", "source": []}
{"url": "https://leetcode-cn.com/problems/range-sum-query-mutable", "source": []}
{"url": "https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-height-trees", "source": []}
{"url": "https://leetcode-cn.com/problems/burst-balloons", "source": []}
{"url": "https://leetcode-cn.com/problems/super-ugly-number", "source": []}
{"url": "https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-duplicate-letters", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-product-of-word-lengths", "source": []}
{"url": "https://leetcode-cn.com/problems/bulb-switcher", "source": []}
{"url": "https://leetcode-cn.com/problems/create-maximum-number", "source": []}
{"url": "https://leetcode-cn.com/problems/coin-change", "source": [{"lang": "Java", "code": "public class Solution {\n\n  public int coinChange(int[] coins, int amount) {\n    return coinChange(0, coins, amount);\n  }\n\n  private int coinChange(int idxCoin, int[] coins, int amount) {\n    if (amount == 0)\n      return 0;\n    if (idxCoin < coins.length && amount > 0) {\n      int maxVal = amount/coins[idxCoin];\n      int minCost = Integer.MAX_VALUE;\n      for (int x = 0; x <= maxVal; x++) {\n        if (amount >= x * coins[idxCoin]) {\n          int res = coinChange(idxCoin + 1, coins, amount - x * coins[idxCoin]);\n          if (res != -1)\n            minCost = Math.min(minCost, res + x);\n        }\n      }\n      return (minCost == Integer.MAX_VALUE)? -1: minCost;\n    }\n    return -1;\n  }\n}\n\n// Time Limit Exceeded"}, {"lang": "Java", "code": "public class Solution {\n\n  public int coinChange(int[] coins, int amount) {\n    if (amount < 1) return 0;\n    return coinChange(coins, amount, new int[amount]);\n  }\n\n  private int coinChange(int[] coins, int rem, int[] count) {\n    if (rem < 0) return -1;\n    if (rem == 0) return 0;\n    if (count[rem - 1] != 0) return count[rem - 1];\n    int min = Integer.MAX_VALUE;\n    for (int coin : coins) {\n      int res = coinChange(coins, rem - coin, count);\n      if (res >= 0 && res < min)\n        min = 1 + res;\n    }\n    count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;\n    return count[rem - 1];\n  }\n}"}, {"lang": "Python", "code": "coins = [1, 2, 5], amount = 11"}, {"lang": "Java", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/wiggle-sort-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/power-of-three", "source": []}
{"url": "https://leetcode-cn.com/problems/count-of-range-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/odd-even-linked-list", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/patching-array", "source": [{"lang": "Java", "code": "public class Solution {\n    public int minPatches(int[] nums, int n) {\n        int patches = 0, i = 0;\n        long miss = 1; // use long to avoid integer overflow error\n        while (miss <= n) {\n            if (i < nums.length && nums[i] <= miss) // miss is covered\n                miss += nums[i++];\n            else { // patch miss to the array\n                miss += miss;\n                patches++; // increase the answer\n            }\n        }\n        return patches;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/reconstruct-itinerary", "source": []}
{"url": "https://leetcode-cn.com/problems/increasing-triplet-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/self-crossing", "source": []}
{"url": "https://leetcode-cn.com/problems/palindrome-pairs", "source": []}
{"url": "https://leetcode-cn.com/problems/house-robber-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/counting-bits", "source": [{"lang": "Java", "code": "public class Solution {\n    public int[] countBits(int num) {\n        int[] ans = new int[num + 1];\n        for (int i = 0; i <= num; ++i)\n            ans[i] = popcount(i);\n        return ans;\n    }\n    private int popcount(int x) {\n        int count;\n        for (count = 0; x != 0; ++count)\n          x &= x - 1; //zeroing out the least significant nonzero bit\n        return count;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[] countBits(int num) {\n        int[] ans = new int[num + 1];\n        int i = 0, b = 1;\n        // [0, b) is calculated\n        while (b <= num) {\n            // generate [b, 2b) or [b, num) from [0, b)\n            while(i < b && i + b <= num){\n                ans[i + b] = ans[i] + 1;\n                ++i;\n            }\n            i = 0;   // reset i\n            b <<= 1; // b = 2b\n        }\n        return ans;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n  public int[] countBits(int num) {\n      int[] ans = new int[num + 1];\n      for (int i = 1; i <= num; ++i)\n        ans[i] = ans[i >> 1] + (i & 1); // x / 2 is x >> 1 and x % 2 is x & 1\n      return ans;\n  }\n}"}, {"lang": "Java", "code": "public class Solution {\n  public int[] countBits(int num) {\n      int[] ans = new int[num + 1];\n      for (int i = 1; i <= num; ++i)\n        ans[i] = ans[i & (i - 1)] + 1;\n      return ans;\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/flatten-nested-list-iterator", "source": []}
{"url": "https://leetcode-cn.com/problems/power-of-four", "source": []}
{"url": "https://leetcode-cn.com/problems/integer-break", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-string", "source": [{"lang": "Python", "code": "class Solution:\n    def reverseString(self, s):\n        s.reverse()"}, {"lang": "Python", "code": "class Solution:\n    def reverseString(self, s):\n        def helper(left, right):\n            if left < right:\n                s[left], s[right] = s[right], s[left]\n                helper(left + 1, right - 1)\n\n        helper(0, len(s) - 1)"}, {"lang": "Java", "code": "class Solution {\n  public void helper(char[] s, int left, int right) {\n    if (left >= right) return;\n    char tmp = s[left];\n    s[left++] = s[right];\n    s[right--] = tmp;\n    helper(s, left, right);\n  }\n\n  public void reverseString(char[] s) {\n    helper(s, 0, s.length - 1);\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def reverseString(self, s):\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1"}]}
{"url": "https://leetcode-cn.com/problems/reverse-vowels-of-a-string", "source": []}
{"url": "https://leetcode-cn.com/problems/top-k-frequent-elements", "source": []}
{"url": "https://leetcode-cn.com/problems/intersection-of-two-arrays", "source": [{"lang": "Python", "code": "class Solution:\n    def set_intersection(self, set1, set2):\n        return [x for x in set1 if x in set2]\n        \n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"  \n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        if len(set1) < len(set2):\n            return self.set_intersection(set1, set2)\n        else:\n            return self.set_intersection(set2, set1)"}, {"lang": "Java", "code": "class Solution {\n  public int[] set_intersection(HashSet<Integer> set1, HashSet<Integer> set2) {\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (Integer s : set1)\n      if (set2.contains(s)) output[idx++] = s;\n\n    return Arrays.copyOf(output, idx);\n  }\n\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<Integer>();\n    for (Integer n : nums1) set1.add(n);\n    HashSet<Integer> set2 = new HashSet<Integer>();\n    for (Integer n : nums2) set2.add(n);\n\n    if (set1.size() < set2.size()) return set_intersection(set1, set2);\n    else return set_intersection(set2, set1);\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"  \n        set1 = set(nums1)\n        set2 = set(nums2)\n        return list(set2 & set1)"}, {"lang": "Java", "code": "class Solution {\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<Integer>();\n    for (Integer n : nums1) set1.add(n);\n    HashSet<Integer> set2 = new HashSet<Integer>();\n    for (Integer n : nums2) set2.add(n);\n\n    set1.retainAll(set2);\n\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (int s : set1) output[idx++] = s;\n    return output;\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/intersection-of-two-arrays-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals", "source": []}
{"url": "https://leetcode-cn.com/problems/russian-doll-envelopes", "source": [{"lang": "Python", "code": "from bisect import bisect_left\n\nclass Solution:\n    def maxEnvelopes(self, arr: List[List[int]]) -> int:\n        # sort increasing in first dimension and decreasing on second\n        arr.sort(key=lambda x: (x[0], -x[1]))\n\n        def lis(nums):\n            dp = []\n            for i in range(len(nums)):\n                idx = bisect_left(dp, nums[i])\n                if idx == len(dp):\n                    dp.append(nums[i])\n                else:\n                    dp[idx] = nums[i]\n            return len(dp)\n        # extract the second dimension and run the LIS\n        return lis([i[1] for i in arr])"}, {"lang": "Java", "code": "class Solution {\n\n    public int lengthOfLIS(int[] nums) {\n        int[] dp = new int[nums.length];\n        int len = 0;\n        for (int num : nums) {\n            int i = Arrays.binarySearch(dp, 0, len, num);\n            if (i < 0) {\n                i = -(i + 1);\n            }\n            dp[i] = num;\n            if (i == len) {\n                len++;\n            }\n        }\n        return len;\n    }\n\n    public int maxEnvelopes(int[][] envelopes) {\n        // sort on increasing in first dimension and decreasing in second\n        Arrays.sort(envelopes, new Comparator<int[]>() {\n            public int compare(int[] arr1, int[] arr2) {\n                if (arr1[0] == arr2[0]) {\n                    return arr2[1] - arr1[1];\n                } else {\n                    return arr1[0] - arr2[0];\n                }\n           }\n        });\n        // extract the second dimension and run LIS\n        int[] secondDim = new int[envelopes.length];\n        for (int i = 0; i < envelopes.length; ++i) secondDim[i] = envelopes[i][1];\n        return lengthOfLIS(secondDim);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/design-twitter", "source": []}
{"url": "https://leetcode-cn.com/problems/count-numbers-with-unique-digits", "source": []}
{"url": "https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k", "source": []}
{"url": "https://leetcode-cn.com/problems/water-and-jug-problem", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-perfect-square", "source": [{"lang": "Python", "code": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num < 2:\n            return True\n        \n        left, right = 2, num // 2\n        \n        while left <= right:\n            x = left + (right - left) // 2\n            guess_squared = x * x\n            if guess_squared == num:\n                return True\n            if guess_squared > num:\n                right = x - 1\n            else:\n                left = x + 1\n        \n        return False"}, {"lang": "Java", "code": "class Solution {\n  public boolean isPerfectSquare(int num) {\n    if (num < 2) {\n      return true;\n    }\n\n    long left = 2, right = num / 2, x, guessSquared;\n    while (left <= right) {\n      x = left + (right - left) / 2;\n      guessSquared = x * x;\n      if (guessSquared == num) {\n        return true;\n      }\n      if (guessSquared > num) {\n        right = x - 1;\n      } else {\n        left = x + 1;\n      }\n    }\n    return false;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num < 2:\n            return True\n        \n        x = num // 2\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num"}, {"lang": "Java", "code": "class Solution {\n  public boolean isPerfectSquare(int num) {\n    if (num < 2) return true;\n\n    long x = num / 2;\n    while (x * x > num) {\n      x = (x + num / x) / 2;\n    }\n    return (x * x == num);\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/largest-divisible-subset", "source": []}
{"url": "https://leetcode-cn.com/problems/sum-of-two-integers", "source": []}
{"url": "https://leetcode-cn.com/problems/super-pow", "source": []}
{"url": "https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums", "source": []}
{"url": "https://leetcode-cn.com/problems/guess-number-higher-or-lower", "source": [{"lang": "Java", "code": "/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        for (int i = 1; i < n; i++)\n            if (guess(i) == 0)\n                return i;\n        return n;\n    }\n}"}, {"lang": "Java", "code": "/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low = 1;\n        int high = n;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            int res = guess(mid);\n            if (res == 0)\n                return mid;\n            else if (res < 0)\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return -1;\n    }\n}"}, {"lang": "Java", "code": "/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low = 1;\n        int high = n;\n        while (low <= high) {\n            int mid1 = low + (high - low) / 3;\n            int mid2 = high - (high - low) / 3;\n            int res1 = guess(mid1);\n            int res2 = guess(mid2);\n            if (res1 == 0)\n                return mid1;\n            if (res2 == 0)\n                return mid2;\n            else if (res1 < 0)\n                high = mid1 - 1;\n            else if (res2 > 0)\n                low = mid2 + 1;\n            else {\n                low = mid1 + 1;\n                high = mid2 - 1;\n            }\n        }\n        return -1;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/wiggle-subsequence", "source": [{"lang": "Java", "code": "public class Solution {\n    private int calculate(int[] nums, int index, boolean isUp) {\n        int maxcount = 0;\n        for (int i = index + 1; i < nums.length; i++) {\n            if ((isUp && nums[i] > nums[index]) || (!isUp && nums[i] < nums[index]))\n                maxcount = Math.max(maxcount, 1 + calculate(nums, i, !isUp));\n        }\n        return maxcount;\n    }\n\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2)\n            return nums.length;\n        return 1 + Math.max(calculate(nums, 0, true), calculate(nums, 0, false));\n    }\n}"}, {"lang": "java", "code": "public class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2)\n            return nums.length;\n        int[] up = new int[nums.length];\n        int[] down = new int[nums.length];\n        for (int i = 1; i < nums.length; i++) {\n            for(int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    up[i] = Math.max(up[i],down[j] + 1);\n                } else if (nums[i] < nums[j]) {\n                    down[i] = Math.max(down[i],up[j] + 1);\n                }\n            }\n        }\n        return 1 + Math.max(down[nums.length - 1], up[nums.length - 1]);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2)\n            return nums.length;\n        int[] up = new int[nums.length];\n        int[] down = new int[nums.length];\n        up[0] = down[0] = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1]) {\n                up[i] = down[i - 1] + 1;\n                down[i] = down[i - 1];\n            } else if (nums[i] < nums[i - 1]) {\n                down[i] = up[i - 1] + 1;\n                up[i] = up[i - 1];\n            } else {\n                down[i] = down[i - 1];\n                up[i] = up[i - 1];\n            }\n        }\n        return Math.max(down[nums.length - 1], up[nums.length - 1]);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2)\n            return nums.length;\n        int down = 1, up = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1])\n                up = down + 1;\n            else if (nums[i] < nums[i - 1])\n                down = up + 1;\n        }\n        return Math.max(down, up);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2)\n            return nums.length;\n        int prevdiff = nums[1] - nums[0];\n        int count = prevdiff != 0 ? 2 : 1;\n        for (int i = 2; i < nums.length; i++) {\n            int diff = nums[i] - nums[i - 1];\n            if ((diff > 0 && prevdiff <= 0) || (diff < 0 && prevdiff >= 0)) {\n                count++;\n                prevdiff = diff;\n            }\n        }\n        return count;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/combination-sum-iv", "source": []}
{"url": "https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/insert-delete-getrandom-o1", "source": []}
{"url": "https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed", "source": []}
{"url": "https://leetcode-cn.com/problems/linked-list-random-node", "source": []}
{"url": "https://leetcode-cn.com/problems/ransom-note", "source": []}
{"url": "https://leetcode-cn.com/problems/shuffle-an-array", "source": [{"lang": "Java", "code": "class Solution {\n    private int[] array;\n    private int[] original;\n\n    private Random rand = new Random();\n\n    private List<Integer> getArrayCopy() {\n        List<Integer> asList = new ArrayList<Integer>();\n        for (int i = 0; i < array.length; i++) {\n            asList.add(array[i]);\n        }\n        return asList;\n    }\n\n    public Solution(int[] nums) {\n        array = nums;\n        original = nums.clone();\n    }\n    \n    public int[] reset() {\n        array = original;\n        original = original.clone();\n        return array;\n    }\n    \n    public int[] shuffle() {\n        List<Integer> aux = getArrayCopy();\n\n        for (int i = 0; i < array.length; i++) {\n            int removeIdx = rand.nextInt(aux.size());\n            array[i] = aux.get(removeIdx);\n            aux.remove(removeIdx);\n        }\n\n        return array;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def __init__(self, nums):\n        self.array = nums\n        self.original = list(nums)\n\n    def reset(self):\n        self.array = self.original\n        self.original = list(self.original)\n        return self.array\n\n    def shuffle(self):\n        aux = list(self.array)\n\n        for idx in range(len(self.array)):\n            remove_idx = random.randrange(len(aux))\n            self.array[idx] = aux.pop(remove_idx)\n\n        return self.array"}, {"lang": "Java", "code": "class Solution {\n    private int[] array;\n    private int[] original;\n\n    Random rand = new Random();\n\n    private int randRange(int min, int max) {\n        return rand.nextInt(max - min) + min;\n    }\n\n    private void swapAt(int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    public Solution(int[] nums) {\n        array = nums;\n        original = nums.clone();\n    }\n    \n    public int[] reset() {\n        array = original;\n        original = original.clone();\n        return original;\n    }\n    \n    public int[] shuffle() {\n        for (int i = 0; i < array.length; i++) {\n            swapAt(i, randRange(i, array.length));\n        }\n        return array;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def __init__(self, nums):\n        self.array = nums\n        self.original = list(nums)\n\n    def reset(self):\n        self.array = self.original\n        self.original = list(self.original)\n        return self.array\n\n    def shuffle(self):\n        for i in range(len(self.array)):\n            swap_idx = random.randrange(i, len(self.array))\n            self.array[i], self.array[swap_idx] = self.array[swap_idx], self.array[i]\n        return self.array"}]}
{"url": "https://leetcode-cn.com/problems/mini-parser", "source": []}
{"url": "https://leetcode-cn.com/problems/lexicographical-numbers", "source": []}
{"url": "https://leetcode-cn.com/problems/first-unique-character-in-a-string", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-absolute-file-path", "source": []}
{"url": "https://leetcode-cn.com/problems/find-the-difference", "source": []}
{"url": "https://leetcode-cn.com/problems/elimination-game", "source": []}
{"url": "https://leetcode-cn.com/problems/perfect-rectangle", "source": []}
{"url": "https://leetcode-cn.com/problems/is-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/utf-8-validation", "source": []}
{"url": "https://leetcode-cn.com/problems/decode-string", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/rotate-function", "source": []}
{"url": "https://leetcode-cn.com/problems/integer-replacement", "source": []}
{"url": "https://leetcode-cn.com/problems/random-pick-index", "source": []}
{"url": "https://leetcode-cn.com/problems/evaluate-division", "source": []}
{"url": "https://leetcode-cn.com/problems/nth-digit", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-watch", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-k-digits", "source": []}
{"url": "https://leetcode-cn.com/problems/frog-jump", "source": [{"lang": "Java", "code": "public class Solution {\n    public boolean canCross(int[] stones) {\n        return can_Cross(stones, 0, 0);\n    }\n    public boolean can_Cross(int[] stones, int ind, int jumpsize) {\n        for (int i = ind + 1; i < stones.length; i++) {\n            int gap = stones[i] - stones[ind];\n            if (gap >= jumpsize - 1 && gap <= jumpsize + 1) {\n                if (can_Cross(stones, i, gap)) {\n                    return true;\n                }\n            }\n        }\n        return ind == stones.length - 1;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean canCross(int[] stones) {\n        return can_Cross(stones, 0, 0);\n    }\n    public boolean can_Cross(int[] stones, int ind, int jumpsize) {\n        if (ind == stones.length - 1) {\n            return true;\n        }\n        int ind1 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize);\n        if (ind1 >= 0 && can_Cross(stones, ind1, jumpsize)) {\n            return true;\n        }\n        int ind2 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize - 1);\n        if (ind2 >= 0 && can_Cross(stones, ind2, jumpsize - 1)) {\n            return true;\n        }\n        int ind3 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize + 1);\n        if (ind3 >= 0 && can_Cross(stones, ind3, jumpsize + 1)) {\n            return true;\n        }\n        return false;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean canCross(int[] stones) {\n        int[][] memo = new int[stones.length][stones.length];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return can_Cross(stones, 0, 0, memo) == 1;\n    }\n    public int can_Cross(int[] stones, int ind, int jumpsize, int[][] memo) {\n        if (memo[ind][jumpsize] >= 0) {\n            return memo[ind][jumpsize];\n        }\n        for (int i = ind + 1; i < stones.length; i++) {\n            int gap = stones[i] - stones[ind];\n            if (gap >= jumpsize - 1 && gap <= jumpsize + 1) {\n                if (can_Cross(stones, i, gap, memo) == 1) {\n                    memo[ind][gap] = 1;\n                    return 1;\n                }\n            }\n        }\n        memo[ind][jumpsize] = (ind == stones.length - 1) ? 1 : 0;\n        return memo[ind][jumpsize];\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean canCross(int[] stones) {\n        int[][] memo = new int[stones.length][stones.length];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return can_Cross(stones, 0, 0, memo) == 1;\n    }\n    public int can_Cross(int[] stones, int ind, int jumpsize, int[][] memo) {\n        if (memo[ind][jumpsize] >= 0) {\n            return memo[ind][jumpsize];\n        }\n        int ind1 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize);\n        if (ind1 >= 0 && can_Cross(stones, ind1, jumpsize, memo) == 1) {\n            memo[ind][jumpsize] = 1;\n            return 1;\n        }\n        int ind2 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize - 1);\n        if (ind2 >= 0 && can_Cross(stones, ind2, jumpsize - 1, memo) == 1) {\n            memo[ind][jumpsize - 1] = 1;\n            return 1;\n        }\n        int ind3 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize + 1);\n        if (ind3 >= 0 && can_Cross(stones, ind3, jumpsize + 1, memo) == 1) {\n            memo[ind][jumpsize + 1] = 1;\n            return 1;\n        }\n        memo[ind][jumpsize] = ((ind == stones.length - 1) ? 1 : 0);\n        return memo[ind][jumpsize];\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean canCross(int[] stones) {\n        HashMap<Integer, Set<Integer>> map = new HashMap<>();\n        for (int i = 0; i < stones.length; i++) {\n            map.put(stones[i], new HashSet<Integer>());\n        }\n        map.get(0).add(0);\n        for (int i = 0; i < stones.length; i++) {\n            for (int k : map.get(stones[i])) {\n                for (int step = k - 1; step <= k + 1; step++) {\n                    if (step > 0 && map.containsKey(stones[i] + step)) {\n                        map.get(stones[i] + step).add(step);\n                    }\n                }\n            }\n        }\n        return map.get(stones[stones.length - 1]).size() > 0;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/sum-of-left-leaves", "source": []}
{"url": "https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal", "source": []}
{"url": "https://leetcode-cn.com/problems/queue-reconstruction-by-height", "source": []}
{"url": "https://leetcode-cn.com/problems/trapping-rain-water-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-palindrome", "source": []}
{"url": "https://leetcode-cn.com/problems/split-array-largest-sum", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int ans;\n    int n, m;\n    void dfs(vector<int>& nums, int i, int cntSubarrays, int curSum, int curMax) {\n        if (i == n && cntSubarrays == m) {\n            ans = min(ans, curMax);\n            return;\n        }\n        if (i == n) {\n            return;  \n        }\n        if (i > 0) {\n            dfs(nums, i + 1, cntSubarrays, curSum + nums[i], max(curMax, curSum + nums[i]));\n        }\n        if (cntSubarrays < m) {\n            dfs(nums, i + 1, cntSubarrays + 1, nums[i], max(curMax, nums[i]));\n        }\n    }\n    int splitArray(vector<int>& nums, int M) {\n        ans = INT_MAX;\n        n = nums.size();\n        m = M;\n        dfs(nums, 0, 0, 0, 0);\n        return ans;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    private int ans;\n    private int n, m;\n    private void dfs(int[] nums, int i, int cntSubarrays, int curSum, int curMax) {\n        if (i == n && cntSubarrays == m) {\n            ans = Math.min(ans, curMax);\n            return;\n        }\n        if (i == n) {\n            return;\n        }\n        if (i > 0) {\n            dfs(nums, i + 1, cntSubarrays, curSum + nums[i], Math.max(curMax, curSum + nums[i]));\n        }\n        if (cntSubarrays < m) {\n            dfs(nums, i + 1, cntSubarrays + 1, nums[i], Math.max(curMax, nums[i]));\n        }\n    }\n    public int splitArray(int[] nums, int M) {\n        ans = Integer.MAX_VALUE;\n        n = nums.length;\n        m = M;\n        dfs(nums, 0, 0, 0, 0);\n        return ans;\n    }\n}"}, {"lang": "C++", "code": "class Solution {\npublic:\n    int splitArray(vector<int>& nums, int m) {\n        int n = nums.size();\n        vector<vector<int>> f(n + 1, vector<int>(m + 1, INT_MAX));\n        vector<int> sub(n + 1, 0);\n        for (int i = 0; i < n; i++) {\n            sub[i + 1] = sub[i] + nums[i];\n        }\n        f[0][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                for (int k = 0; k < i; k++) {\n                    f[i][j] = min(f[i][j], max(f[k][j - 1], sub[i] - sub[k]));\n                }\n            }\n        }\n        return f[n][m];\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int splitArray(int[] nums, int m) {\n        int n = nums.length;\n        int[][] f = new int[n + 1][m + 1];\n        int[] sub = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                f[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            sub[i + 1] = sub[i] + nums[i];\n        }\n        f[0][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                for (int k = 0; k < i; k++) {\n                    f[i][j] = Math.min(f[i][j], Math.max(f[k][j - 1], sub[i] - sub[k]));\n                }\n            }\n        }\n        return f[n][m];        \n    }\n}"}, {"lang": "C++", "code": "#define LL long long\nclass Solution {\npublic:\n    int splitArray(vector<int>& nums, int m) {\n        LL l = 0, r = 0;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            r += nums[i];\n            if (l < nums[i]) {\n                l = nums[i];\n            }\n        }\n        LL ans =  r;\n        while (l <= r) {\n            LL mid = (l + r) >> 1;\n            LL sum = 0;\n            int cnt = 1;            \n            for (int i = 0; i < n; i++) {\n                if (sum + nums[i] > mid) {\n                    cnt ++;\n                    sum = nums[i];\n                } else {\n                    sum += nums[i];\n                }\n            }\n            if (cnt <= m) {\n                ans = min(ans, mid);\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int splitArray(int[] nums, int m) {\n        long l = 0;\n        long r = 0;        \n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            r += nums[i];\n            if (l < nums[i]) {\n                l = nums[i];\n            }\n        }\n        long ans = r;\n        while (l <= r) {\n            long mid = (l + r) >> 1;\n            long sum = 0;\n            int cnt = 1;\n            for (int i = 0; i < n; i++) {\n                if (sum + nums[i] > mid) {\n                    cnt ++;\n                    sum = nums[i];\n                } else {\n                    sum += nums[i];\n                }\n            }\n            if (cnt <= m) {\n                ans = Math.min(ans, mid);\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return (int)ans;      \n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/fizz-buzz", "source": []}
{"url": "https://leetcode-cn.com/problems/arithmetic-slices", "source": []}
{"url": "https://leetcode-cn.com/problems/third-maximum-number", "source": []}
{"url": "https://leetcode-cn.com/problems/add-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/partition-equal-subset-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/pacific-atlantic-water-flow", "source": []}
{"url": "https://leetcode-cn.com/problems/battleships-in-a-board", "source": []}
{"url": "https://leetcode-cn.com/problems/strong-password-checker", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array", "source": []}
{"url": "https://leetcode-cn.com/problems/reconstruct-original-digits-from-english", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-repeating-character-replacement", "source": []}
{"url": "https://leetcode-cn.com/problems/construct-quad-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list", "source": []}
{"url": "https://leetcode-cn.com/problems/all-oone-data-structure", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-genetic-mutation", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-segments-in-a-string", "source": [{"lang": "Java", "code": "String[] tokens = \"\".split(\"\\\\s++\");\ntokens.length; // 1\ntokens[0]; // \"\""}, {"lang": "Python", "code": ""}, {"lang": "Java", "code": "class Solution:\n    def countSegments(self, s):\n        return len(s.split())"}, {"lang": "Python", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/non-overlapping-intervals", "source": []}
{"url": "https://leetcode-cn.com/problems/find-right-interval", "source": [{"lang": "Java", "code": " /**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n    public int[] findRightInterval(Interval[] intervals) {\n        int[] res = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            int min = Integer.MAX_VALUE;\n            int minindex = -1;\n            for (int j = 0; j < intervals.length; j++) {\n                if (intervals[j].start >= intervals[i].end && intervals[j].start < min) {\n                    min = intervals[j].start;\n                    minindex = j;\n                }\n            }\n            res[i] = minindex;\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": " /**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n    public int[] findRightInterval(Interval[] intervals) {\n        int[] res = new int[intervals.length];\n        HashMap<Interval, Integer> hash = new HashMap<>();\n        for (int i = 0; i < intervals.length; i++) {\n            hash.put(intervals[i], i);\n        }\n        Arrays.sort(intervals, (a, b) -> a.start - b.start);\n        for (int i = 0; i < intervals.length; i++) {\n            int min = Integer.MAX_VALUE;\n            int minindex = -1;\n            for (int j = i + 1; j < intervals.length; j++) {\n                if (intervals[j].start >= intervals[i].end && intervals[j].start < min) {\n                    min = intervals[j].start;\n                    minindex = hash.get(intervals[j]);\n                }\n            }\n            res[hash.get(intervals[i])] = minindex;\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "/**\n* Definition for an interval.\n* public class Interval {\n*     int start;\n*     int end;\n*     Interval() { start = 0; end = 0; }\n*     Interval(int s, int e) { start = s; end = e; }\n* }\n*/\npublic class Solution {\n\n   public Interval binary_search(Interval[] intervals, int target, int start, int end) {\n       if (start >= end) {\n           if (intervals[start].start >= target) {\n               return intervals[start];\n           }\n           return null;\n       }\n       int mid = (start + end) / 2;\n       if (intervals[mid].start < target) {\n           return binary_search(intervals, target, mid + 1, end);\n       } else {\n           return binary_search(intervals, target, start, mid);\n       }\n   }\n\n   public int[] findRightInterval(Interval[] intervals) {\n       int[] res = new int[intervals.length];\n       HashMap<Interval, Integer> hash = new HashMap<>();\n       for (int i = 0; i < intervals.length; i++) {\n           hash.put(intervals[i], i);\n       }\n       Arrays.sort(intervals, (a, b) -> a.start - b.start);\n       for (int i = 0; i < intervals.length; i++) {\n           Interval interval = binary_search(intervals, intervals[i].end, 0, intervals.length - 1);\n           res[hash.get(intervals[i])] = interval == null ? -1 : hash.get(interval);\n       }\n       return res;\n   }\n}"}, {"lang": "Java", "code": " /**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n\n    public int[] findRightInterval(Interval[] intervals) {\n        TreeMap<Integer, Integer> starts = new TreeMap<>();\n        int res[] = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            starts.put(intervals[i].start, i);\n        }\n        for (int i = 0; i < intervals.length; i++) {\n            Map.Entry<Integer, Integer> pos = starts.ceilingEntry(intervals[i].end);\n            res[i] = pos == null ? -1 : pos.getValue();\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n\n    public int[] findRightInterval(Interval[] intervals) {\n        Interval[] endIntervals = Arrays.copyOf(intervals, intervals.length);\n        HashMap<Interval, Integer> hash = new HashMap<>();\n        for (int i = 0; i < intervals.length; i++) {\n            hash.put(intervals[i], i);\n        }\n        Arrays.sort(intervals, (a, b) -> a.start - b.start);\n        Arrays.sort(endIntervals, (a, b) -> a.end - b.end);\n        int j = 0;\n        int[] res = new int[intervals.length];\n        for (int i = 0; i < endIntervals.length; i++) {\n            while (j < intervals.length && intervals[j].start < endIntervals[i].end) {\n                j++;\n            }\n            res[hash.get(endIntervals[i])] = j == intervals.length ? -1 : hash.get(intervals[j]);\n        }\n        return res;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/path-sum-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/find-all-anagrams-in-a-string", "source": []}
{"url": "https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order", "source": []}
{"url": "https://leetcode-cn.com/problems/arranging-coins", "source": []}
{"url": "https://leetcode-cn.com/problems/find-all-duplicates-in-an-array", "source": []}
{"url": "https://leetcode-cn.com/problems/string-compression", "source": [{"lang": "Python", "code": "class Solution(object):\n    def compress(self, chars):\n        anchor = write = 0\n        for read, c in enumerate(chars):\n            if read + 1 == len(chars) or chars[read + 1] != c:\n                chars[write] = chars[anchor]\n                write += 1\n                if read > anchor:\n                    for digit in str(read - anchor + 1):\n                        chars[write] = digit\n                        write += 1\n                anchor = read + 1\n        return write"}, {"lang": "Java", "code": "class Solution {\n    public int compress(char[] chars) {\n        int anchor = 0, write = 0;\n        for (int read = 0; read < chars.length; read++) {\n            if (read + 1 == chars.length || chars[read + 1] != chars[read]) {\n                chars[write++] = chars[anchor];\n                if (read > anchor) {\n                    for (char c: (\"\" + (read - anchor + 1)).toCharArray()) {\n                        chars[write++] = c;\n                    }\n                }\n                anchor = read + 1;\n            }\n        }\n        return write;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/add-two-numbers-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-boomerangs", "source": []}
{"url": "https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array", "source": []}
{"url": "https://leetcode-cn.com/problems/serialize-and-deserialize-bst", "source": []}
{"url": "https://leetcode-cn.com/problems/delete-node-in-a-bst", "source": []}
{"url": "https://leetcode-cn.com/problems/sort-characters-by-frequency", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements", "source": []}
{"url": "https://leetcode-cn.com/problems/4sum-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/assign-cookies", "source": []}
{"url": "https://leetcode-cn.com/problems/132-pattern", "source": []}
{"url": "https://leetcode-cn.com/problems/circular-array-loop", "source": []}
{"url": "https://leetcode-cn.com/problems/poor-pigs", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        int states = minutesToTest / minutesToDie + 1;\n        return ceil(log(buckets) / log(states));\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        int states = minutesToTest / minutesToDie + 1;\n        return (int) Math.ceil(Math.log(buckets) / Math.log(states));\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        states = minutesToTest // minutesToDie + 1\n        return math.ceil(math.log(buckets) / math.log(states))"}]}
{"url": "https://leetcode-cn.com/problems/repeated-substring-pattern", "source": []}
{"url": "https://leetcode-cn.com/problems/lfu-cache", "source": []}
{"url": "https://leetcode-cn.com/problems/hamming-distance", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/island-perimeter", "source": []}
{"url": "https://leetcode-cn.com/problems/can-i-win", "source": []}
{"url": "https://leetcode-cn.com/problems/count-the-repetitions", "source": []}
{"url": "https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string", "source": []}
{"url": "https://leetcode-cn.com/problems/validate-ip-address", "source": []}
{"url": "https://leetcode-cn.com/problems/implement-rand10-using-rand7", "source": []}
{"url": "https://leetcode-cn.com/problems/concatenated-words", "source": []}
{"url": "https://leetcode-cn.com/problems/matchsticks-to-square", "source": [{"lang": "Java", "code": "import java.util.HashMap;\nimport java.util.Collections;\n\nclass Solution {\n    public List<Integer> nums;\n    public int[] sums;\n    public int possibleSquareSide;\n\n    public Solution() {\n        this.sums = new int[4];\n    }\n\n    // Depth First Search function.\n    public boolean dfs(int index) {\n\n        // If we have exhausted all our matchsticks, check if all sides of the square are of equal length\n        if (index == this.nums.size()) {\n            return sums[0] == sums[1] && sums[1] == sums[2] && sums[2] == sums[3];\n        }\n\n        // Get current matchstick.\n        int element = this.nums.get(index);\n\n        // Try adding it to each of the 4 sides (if possible)\n        for(int i = 0; i < 4; i++) {\n            if (this.sums[i] + element <= this.possibleSquareSide) {\n                this.sums[i] += element;\n                if (this.dfs(index + 1)) {\n                    return true;\n                }\n                this.sums[i] -= element;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean makesquare(int[] nums) {\n        // Empty matchsticks.\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n\n        // Find the perimeter of the square (if at all possible)\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n\n        this.possibleSquareSide =  perimeter / 4;\n        if (this.possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n\n        // Convert the array of primitive int to ArrayList (for sorting).\n        this.nums = Arrays.stream(nums).boxed().collect(Collectors.toList());\n        Collections.sort(this.nums, Collections.reverseOrder());\n        return this.dfs(0);\n    }\n}"}, {"lang": "Python", "code": "def makesquare(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n\n    # If there are no matchsticks, then we can't form any square\n    if not nums:\n        return False\n\n    # Number of matchsticks we have\n    L = len(nums)\n\n    # Perimeter of our square (if one can be formed)\n    perimeter = sum(nums)\n\n    # Possible side of our square.\n    possible_side =  perimeter // 4\n\n    # If the perimeter can be equally split into 4 parts (and hence 4 sides, then we move on).\n    if possible_side * 4 != perimeter:\n        return False\n\n    # Reverse sort the matchsticks because we want to consider the biggest one first.\n    nums.sort(reverse=True)\n\n    # This array represents the 4 sides and their current lengths\n    sums = [0 for _ in range(4)]\n\n    # Our recursive dfs function.\n    def dfs(index):\n\n        # If we reach the end of matchsticks array, we check if the square was formed or not\n        if index == L:\n            # If 3 equal sides were formed, 4th will be the same as these three and answer should be True in that case.\n            return sums[0] == sums[1] == sums[2] == possible_side\n\n        # The current matchstick can belong to any of the 4 sides (provided their remaining lenghts are >= the size of the current matchstick)\n        for i in range(4):\n            # If this matchstick can fir in the space left for the current side\n            if sums[i] + nums[index] <= possible_side:\n                # Recurse\n                sums[i] += nums[index]\n                if dfs(index + 1):\n                    return True\n                # Revert the effects of recursion because we no longer need them for other recursions.\n                sums[i] -= nums[index]\n        return False        \n    return dfs(0)"}, {"lang": "Java", "code": "(4, 4), (3, 5), (3, 5) -----------> 已经有 3 个组被放满\n(3, 4), (3, 5), (4), (5) ---------> 没有组被放满\n(3, 3), (4, 4), (5), (5) ---------> 已经有 1 个组被放满"}, {"lang": "Python", "code": "let square_side = sum(matchsticks) / 4\nfunc recurse(matchsticks_used, sides_formed) {\n    if sides_formed == 4, then {\n        Square Formed!!\n    }\n    for match in matchsticks available, do {\n          add match to matchsticks_used\n          let result = recurse(matchsticks_used, sides_formed)\n          if result == True, then {\n              return True\n          }\n          remove match from matchsticks_used\n    }\n    return False\n}"}]}
{"url": "https://leetcode-cn.com/problems/ones-and-zeroes", "source": [{"lang": "Java", "code": "dp(i, j) = max(1 + dp(i - cost_zero[k], j - cost_one[k]))\n    if i >= cost_zero[k] and j >= cost_one[k]"}]}
{"url": "https://leetcode-cn.com/problems/heaters", "source": []}
{"url": "https://leetcode-cn.com/problems/number-complement", "source": []}
{"url": "https://leetcode-cn.com/problems/total-hamming-distance", "source": []}
{"url": "https://leetcode-cn.com/problems/generate-random-point-in-a-circle", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    double rad, xc, yc;\n    //c++11 random floating point number generation\n    mt19937 rng{random_device{}()};\n    uniform_real_distribution<double> uni{0, 1};\n\n    Solution(double radius, double x_center, double y_center) {\n        rad = radius, xc = x_center, yc = y_center;\n    }\n\n    vector<double> randPoint() {\n        double x0 = xc - rad;\n        double y0 = yc - rad;\n\n        while(true) {\n            double xg = x0 + uni(rng) * 2 * rad;\n            double yg = y0 + uni(rng) * 2 * rad;\n            if (sqrt(pow((xg - xc), 2) + pow((yg - yc), 2)) <= rad)\n                return {xg, yg};\n        }\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    double rad, xc, yc;\n    public Solution(double radius, double x_center, double y_center) {\n        rad = radius;\n        xc = x_center;\n        yc = y_center;\n    }\n\n    public double[] randPoint() {\n        double x0 = xc - rad;\n        double y0 = yc - rad;\n\n        while(true) {\n            double xg = x0 + Math.random() * rad * 2;\n            double yg = y0 + Math.random() * rad * 2;\n            if (Math.sqrt(Math.pow((xg - xc) , 2) + Math.pow((yg - yc), 2)) <= rad)\n                return new double[]{xg, yg};\n        }\n    }\n}"}, {"lang": "C++", "code": "class Solution {\npublic:\n    double rad, xc, yc;\n    //c++11 random floating point number generation\n    mt19937 rng{random_device{}()};\n    uniform_real_distribution<double> uni{0, 1};\n\n    Solution(double radius, double x_center, double y_center) {\n        rad = radius, xc = x_center, yc = y_center;\n    }\n\n    vector<double> randPoint() {\n        double d = rad * sqrt(uni(rng));\n        double theta = uni(rng) * (2 * M_PI);\n        return {d * cos(theta) + xc, d * sin(theta) + yc};\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    double rad, xc, yc;\n    public Solution(double radius, double x_center, double y_center) {\n        rad = radius;\n        xc = x_center;\n        yc = y_center;\n    }\n\n    public double[] randPoint() {\n        double d = rad * Math.sqrt(Math.random());\n        double theta = Math.random() * 2 * Math.PI;\n        return new double[]{d * Math.cos(theta) + xc, d * Math.sin(theta) + yc};\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/largest-palindrome-product", "source": []}
{"url": "https://leetcode-cn.com/problems/sliding-window-median", "source": [{"lang": "C++", "code": "vector<double> medianSlidingWindow(vector<int>& nums, int k)\n{\n    vector<double> medians;\n    unordered_map<int, int> hash_table;\n    priority_queue<int> lo;                                 // max heap\n    priority_queue<int, vector<int>, greater<int> > hi;     // min heap\n\n    int i = 0;      // index of current incoming element being processed\n\n    // initialize the heaps\n    while (i < k)\n        lo.push(nums[i++]);\n    for (int j = 0; j < k / 2; j++) {\n        hi.push(lo.top());\n        lo.pop();\n    }\n\n    while (true) {\n        // get median of current window\n        medians.push_back(k & 1 ? lo.top() : ((double)lo.top() + (double)hi.top()) * 0.5);\n\n        if (i >= nums.size())\n            break;                          // break if all elements processed\n\n        int out_num = nums[i - k],          // outgoing element\n            in_num = nums[i++],             // incoming element\n            balance = 0;                    // balance factor\n\n        // number `out_num` exits window\n        balance += (out_num <= lo.top() ? -1 : 1);\n        hash_table[out_num]++;\n\n        // number `in_num` enters window\n        if (!lo.empty() && in_num <= lo.top()) {\n            balance++;\n            lo.push(in_num);\n        }\n        else {\n            balance--;\n            hi.push(in_num);\n        }\n\n        // re-balance heaps\n        if (balance < 0) {                  // `lo` needs more valid elements\n            lo.push(hi.top());\n            hi.pop();\n            balance++;\n        }\n        if (balance > 0) {                  // `hi` needs more valid elements\n            hi.push(lo.top());\n            lo.pop();\n            balance--;\n        }\n\n        // remove invalid numbers that should be discarded from heap tops\n        while (hash_table[lo.top()]) {\n            hash_table[lo.top()]--;\n            lo.pop();\n        }\n        while (!hi.empty() && hash_table[hi.top()]) {\n            hash_table[hi.top()]--;\n            hi.pop();\n        }\n    }\n\n    return medians;\n}"}, {"lang": "C++", "code": "vector<double> medianSlidingWindow(vector<int>& nums, int k)\n{\n    vector<double> medians;\n    multiset<int> window(nums.begin(), nums.begin() + k);\n\n    auto mid = next(window.begin(), k / 2);\n\n    for (int i = k;; i++) {\n\n        // Push the current median\n        medians.push_back(((double)(*mid) + *next(mid, k % 2 - 1)) * 0.5);\n\n        // If all done, break\n        if (i == nums.size())\n            break;\n\n        // Insert incoming element\n        window.insert(nums[i]);\n        if (nums[i] < *mid)\n            mid--;                  // same as mid = prev(mid)\n\n        // Remove outgoing element\n        if (nums[i - k] <= *mid)\n            mid++;                  // same as mid = next(mid)\n\n        window.erase(window.lower_bound(nums[i - k]));\n    }\n\n    return medians;\n}"}]}
{"url": "https://leetcode-cn.com/problems/magical-string", "source": []}
{"url": "https://leetcode-cn.com/problems/license-key-formatting", "source": []}
{"url": "https://leetcode-cn.com/problems/smallest-good-base", "source": []}
{"url": "https://leetcode-cn.com/problems/max-consecutive-ones", "source": []}
{"url": "https://leetcode-cn.com/problems/predict-the-winner", "source": [{"lang": "Java", "code": "public class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        return winner(nums, 0, nums.length - 1, 1) >= 0;\n    }\n    public int winner(int[] nums, int s, int e, int turn) {\n        if (s == e)\n            return turn * nums[s];\n        int a = turn * nums[s] + winner(nums, s + 1, e, -turn);\n        int b = turn * nums[e] + winner(nums, s, e - 1, -turn);\n        return turn * Math.max(turn * a, turn * b);\n    }\n}"}, {"lang": "Java", "code": "dp(i, j) = max(nums[i] - dp(i+1, j), nums[j] - dp(i, j-1))\ndp(i, i) = nums[i]"}, {"lang": "Java", "code": "public class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        int[][] dp = new int[nums.length + 1][nums.length];\n        for (int s = nums.length; s >= 0; s--) {\n            for (int e = s + 1; e < nums.length; e++) {\n                int a = nums[s] - dp[s + 1][e];\n                int b = nums[e] - dp[s][e - 1];\n                dp[s][e] = Math.max(a, b);\n            }\n        }\n        return dp[0][nums.length - 1] >= 0;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/zuma-game", "source": []}
{"url": "https://leetcode-cn.com/problems/increasing-subsequences", "source": []}
{"url": "https://leetcode-cn.com/problems/construct-the-rectangle", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-pairs", "source": [{"lang": "C++", "code": "update(BIT,index, val):\n    while(index<0):\n        BIT[index]+=val\n        index-=(index&(-index))"}, {"lang": "C++", "code": "query(BIT,index):\n    sum=0\n    while(index<BIT.size):\n        sum+=BIT[index]\n        index+=(index&(-index))"}]}
{"url": "https://leetcode-cn.com/problems/target-sum", "source": [{"lang": "Java", "code": "public class Solution {\n    int count = 0;\n    public int findTargetSumWays(int[] nums, int S) {\n        calculate(nums, 0, 0, S);\n        return count;\n    }\n    public void calculate(int[] nums, int i, int sum, int S) {\n        if (i == nums.length) {\n            if (sum == S)\n                count++;\n        } else {\n            calculate(nums, i + 1, sum + nums[i], S);\n            calculate(nums, i + 1, sum - nums[i], S);\n        }\n    }\n}"}, {"lang": "Java", "code": "dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]"}, {"lang": "Java", "code": "dp[i][j + nums[i]] += dp[i - 1][j]\ndp[i][j - nums[i]] += dp[i - 1][j]"}]}
{"url": "https://leetcode-cn.com/problems/teemo-attacking", "source": [{"lang": "Java", "code": "class Solution {\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\n        int n = timeSeries.length;\n        if (n == 0) return 0;\n\n        int total = 0;\n        for(int i = 0; i < n - 1; ++i)\n          total += Math.min(timeSeries[i + 1] - timeSeries[i], duration);\n        return total + duration;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        n = len(timeSeries)\n        if n == 0:\n            return 0\n        \n        total = 0\n        for i in range(n - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        return total + duration"}]}
{"url": "https://leetcode-cn.com/problems/next-greater-element-i", "source": []}
{"url": "https://leetcode-cn.com/problems/random-point-in-non-overlapping-rectangles", "source": []}
{"url": "https://leetcode-cn.com/problems/diagonal-traverse", "source": []}
{"url": "https://leetcode-cn.com/problems/keyboard-row", "source": []}
{"url": "https://leetcode-cn.com/problems/find-mode-in-binary-search-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/ipo", "source": [{"lang": "Python", "code": "from heapq import nlargest, heappop, heappush\nclass Solution:\n    def findMaximizedCapital(self, k: int, W: int, Profits: List[int], Capital: List[int]) -> int:\n        # to speed up: if all projects are available\n        if W >= max(Capital):\n            return W + sum(nlargest(k, Profits))\n        \n        n = len(Profits)\n        projects = [(Capital[i], Profits[i]) for i in range(n)]\n        # sort the projects :\n        # the most available (= the smallest capital) is the last one\n        projects.sort(key = lambda x : -x[0])\n        \n        available = []\n        while k > 0:\n            # update available projects\n            while projects and projects[-1][0] <= W:\n                heappush(available, -projects.pop()[1])\n            # if there are available projects,\n            # pick the most profitable one\n            if available:\n                W -= heappop(available)\n            # not enough capital to start any project\n            else:\n                break\n            k -= 1\n        return W  "}, {"lang": "Java", "code": "class Solution {\n  public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n    // to speed up: if all projects are available\n    boolean speedUp = true;\n    for (int c: Capital) if (W < c) speedUp = false;\n    if (speedUp) {\n      PriorityQueue<Integer> heap = new PriorityQueue<>();\n      for (int p: Profits) {\n        heap.add(p);\n        if (heap.size() > k) heap.poll();\n      }\n      for (int h: heap) W += h;\n      return W;\n    }\n\n    int n = Profits.length;\n    // sort the projects\n    // the most available (= the smallest capital) is the head of the heap\n    PriorityQueue<int[]> projects = new PriorityQueue<>((x, y) -> (x[0] - y[0]));\n    for(int i = 0; i < n; i++) {\n      projects.add(new int[] {Capital[i], Profits[i]});\n    }\n\n    // max heap\n    PriorityQueue<Integer> available = new PriorityQueue<>((x, y) -> (y - x));\n    while (k > 0) {\n      // update available projects\n      while (!projects.isEmpty() && projects.peek()[0] <= W)\n        available.add(projects.poll()[1]);\n\n      // if there are available projects,\n      // pick the most profitable one\n      if (!available.isEmpty()) W += available.poll();\n      // not enough capital to start any project\n      else break;\n      --k;\n    }\n    return W;\n  }\n}"}, {"lang": "Python", "code": "from heapq import nlargest\nclass Solution:\n    def findMaximizedCapital(self, k: int, W: int, Profits: List[int], Capital: List[int]) -> int:\n        # to speed up: if all projects are available\n        if W >= max(Capital):\n            return W + sum(nlargest(k, Profits))\n        \n        n = len(Profits)\n        for i in range(min(n, k)):\n            idx = -1 \n            # if there are available projects,\n            # pick the most profitable one\n            for j in range(n):\n                if W >= Capital[j]:\n                    if idx == -1: \n                        idx = j\n                    elif Profits[idx] < Profits[j]: \n                        idx = j\n                        \n            # not enough capital to start any project\n            if idx == -1:\n                break\n            \n            # add the profit from chosen project\n            # and remove the project from further consideration\n            W += Profits[idx]\n            Capital[idx] = float('inf')\n            \n        return  W"}, {"lang": "Java", "code": "class Solution {\n    public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n        // to speed up: if all projects are available\n        boolean speedUp = true;\n        for (int c: Capital) if (W < c) speedUp = false;\n        if (speedUp) {\n            PriorityQueue<Integer> heap = new PriorityQueue<>();\n            for (int p: Profits) {\n                heap.add(p);\n                if (heap.size() > k) heap.poll();    \n            }\n            for (int h: heap) W += h; \n            return W;\n        }\n        \n        int idx;\n        int n = Profits.length;\n        for(int i = 0; i < Math.min(k, n); ++i) {\n            idx = -1; \n            // if there are available projects,\n            // pick the most profitable one\n            for(int j = 0; j < n; ++j) { \n                if (W >= Capital[j]) {\n                    if (idx == -1 ) idx = j;\n                    else if (Profits[idx] < Profits[j]) idx = j;\n                }\n            }\n            // not enough capital to start any project\n            if(idx == -1) break;\n            \n            // add the profit from chosen project\n            // and remove the project from further consideration\n            W += Profits[idx];\n            Capital[idx] = Integer.MAX_VALUE;                \n        }\n        return  W;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/next-greater-element-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/base-7", "source": []}
{"url": "https://leetcode-cn.com/problems/relative-ranks", "source": []}
{"url": "https://leetcode-cn.com/problems/perfect-number", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if (num <= 0) {\n            return false;\n        }\n        int sum = 0;\n        for (int i = 1; i * i <= num; i++) {\n            if (num % i == 0) {\n                sum += i;\n                if (i * i != num) {\n                    sum += num / i;\n                }\n\n            }\n        }\n        return sum - num == num;\n    }\n}"}, {"lang": "Java", "code": "6 = 2^1 * (2^2 - 1)\n28 = 2^2 * (2^3 - 1)\n496 = 2^3 * (2^4 - 1)\n8128 = 2^4 * (2^5 - 1)"}]}
{"url": "https://leetcode-cn.com/problems/most-frequent-subtree-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/fibonacci-number", "source": [{"lang": "Java", "code": "public class Solution {\n    public int fib(int N) {\n        if (N <= 1) {\n            return N;\n        }\n        return fib(N-1) + fib(N-2);\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def fib(self, N: int) -> int:\n        if N <= 1:\n            return N\n        return self.fib(N-1) + self.fib(N-2)"}, {"lang": "Java", "code": "func fib(N int) int {\n    if N <= 1 {\n        return N\n    }\n    return fib(N-1) + fib(N-2)\n}"}, {"lang": "Python", "code": ""}, {"lang": "Go", "code": ""}, {"lang": "Java", "code": "func fib(N int) int {\n    if N <= 1 {\n        return N\n    }\n    return memoize(N)\n}\n\nfunc memoize(N int) int {\n    cache := map[int]int{0: 0, 1: 1}\n\n    for i := 2; i <= N; i++ {\n        cache[i] = cache[i-1] + cache[i-2]\n    }\n    return cache[N]\n}"}, {"lang": "Python", "code": ""}, {"lang": "Go", "code": ""}, {"lang": "Java", "code": "var cache = map[int]int{0: 0, 1: 1}\n\nfunc fib(N int) int {\n    if N <= 1 {\n        return N\n    }\n    return memoize(N)\n}\n\nfunc memoize(N int) int {\n    if _, ok := cache[N]; ok {\n        return cache[N]\n    }\n    cache[N] = memoize(N-1) + memoize(N-2)\n    return memoize(N)\n}"}, {"lang": "Python", "code": ""}, {"lang": "Go", "code": ""}, {"lang": "Java", "code": "func fib(N int) int {\n    if N <= 1 {\n        return N\n    }\n    if N == 2 {\n        return 1\n    }\n\n    current := 0\n    prev1 := 1\n    prev2 := 1\n\n    for i := 3; i <= N; i++ {\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    }\n    return current\n}"}, {"lang": "Python", "code": ""}, {"lang": "Go", "code": ""}, {"lang": "Java", "code": "func fib(N int) int {\n    if N <= 1 {\n        return N\n    }\n    var A = [2][2]int{\n        {1,1},\n        {1,0},\n    }\n    A = matrixPower(A, N-1)\n    return A[0][0]\n}\n\nfunc matrixPower(A [2][2]int, N int) [2][2]int {\n    if N <= 1 {\n        return A\n    }\n    A = matrixPower(A, N/2)\n    A = multiply(A, A)\n\n    var B = [2][2]int{\n        {1,1},\n        {1,0},\n    }\n    if N%2 != 0 {\n        A = multiply(A, B)\n    }\n\n    return A\n}\n\nfunc multiply(A [2][2]int, B [2][2]int) [2][2]int {\n    x := A[0][0] * B[0][0] + A[0][1] * B[1][0];\n    y := A[0][0] * B[0][1] + A[0][1] * B[1][1];\n    z := A[1][0] * B[0][0] + A[1][1] * B[1][0];\n    w := A[1][0] * B[0][1] + A[1][1] * B[1][1];\n\n    A[0][0] = x;\n    A[0][1] = y;\n    A[1][0] = z;\n    A[1][1] = w;\n\n    return A\n}"}, {"lang": "Python", "code": ""}, {"lang": "Go", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/find-bottom-left-tree-value", "source": []}
{"url": "https://leetcode-cn.com/problems/freedom-trail", "source": []}
{"url": "https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-palindromic-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/super-washing-machines", "source": [{"lang": "Python", "code": "class Solution:\n    def findMinMoves(self, machines: List[int]) -> int:\n        n = len(machines)\n        dress_total = sum(machines)\n        if dress_total % n != 0:\n            return -1\n        \n        dress_per_machine = dress_total // n\n        for i in range(n):\n            # Change the number of dresses in the machines to\n            # the number of dresses to be removed from this machine\n            # (could be negative)\n            machines[i] -= dress_per_machine\n            \n        # curr_sum is a number of dresses to move at this point, \n        # max_sum is a max number of dresses to move at this point or before,\n        # m is number of dresses to move out from the current machine.\n        curr_sum = max_sum = res = 0\n        for m in machines:\n            curr_sum += m\n            max_sum = max(max_sum, abs(curr_sum))\n            res = max(res, max_sum, m)\n        return res"}, {"lang": "Java", "code": "class Solution {\n    public int findMinMoves(int[] machines) {\n        int n = machines.length, dressTotal = 0;\n        for (int m : machines) dressTotal += m;\n        if (dressTotal % n != 0) return -1;\n\n        int dressPerMachine = dressTotal / n;\n        // Change the number of dresses in the machines to\n        // the number of dresses to be removed from this machine\n        // (could be negative)\n        for (int i = 0; i < n; i++) machines[i] -= dressPerMachine;\n\n        // currSum is a number of dresses to move at this point, \n        // maxSum is a max number of dresses to move at this point or before,\n        // m is number of dresses to move out from the current machine.\n        int currSum = 0, maxSum = 0, tmpRes = 0, res = 0;\n        for (int m : machines) {\n            currSum += m;\n            maxSum = Math.max(maxSum, Math.abs(currSum));\n            tmpRes = Math.max(maxSum, m);\n            res = Math.max(res, tmpRes);\n        }\n        return res;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/coin-change-2", "source": []}
{"url": "https://leetcode-cn.com/problems/random-flip-matrix", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n\n    unordered_map<int,int> V;\n    int nr, nc, rem;\n\n    //c++11 random integer generation\n    mt19937 rng{random_device{}()};\n    //uniform random integer in [0, bound]\n    int randint(int bound) {\n        uniform_int_distribution<int> uni(0, bound);\n        return uni(rng);\n    }\n\n    Solution(int n_rows, int n_cols) {\n        nr = n_rows, nc = n_cols, rem = nr * nc;\n    }\n\n    vector<int> flip() {\n        int r = randint(--rem);\n        int x = V.count(r) ? V[r] : V[r] = r;\n        V[r] = V.count(rem) ? V[rem] : V[rem] = rem;\n        return {x / nc, x % nc};\n    }\n\n    void reset() {\n        V.clear();\n        rem = nr*nc;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n\n    Map<Integer, Integer> V = new HashMap<>();\n    int nr, nc, rem;\n    Random rand = new Random();\n\n    public Solution(int n_rows, int n_cols) {\n        nr = n_rows;\n        nc = n_cols;\n        rem = nr * nc;\n    }\n\n    public int[] flip() {\n        int r = rand.nextInt(rem--);\n        int x = V.getOrDefault(r, r);\n        V.put(r, V.getOrDefault(rem, rem));\n        return new int[]{x / nc, x % nc};\n    }\n\n    public void reset() {\n        V.clear();\n        rem = nr * nc;\n    }\n}"}, {"lang": "C++", "code": "class Solution {\npublic:\n\n    int nr, nc, rem, b_size;\n    vector<unordered_set<int>> buckets;\n\n    //c++11 random integer generation\n    mt19937 rng{random_device{}()};\n    //uniform random integer in [0, bound)\n    int randint(int bound) {\n        uniform_int_distribution<int> uni(0, bound - 1);\n        return uni(rng);\n    }\n\n    Solution(int n_rows, int n_cols) {\n        nr = n_rows, nc = n_cols, rem = nr * nc;\n        b_size = sqrt(nr * nc);\n        for (int i = 0; i < nr * nc; i += b_size)\n            buckets.push_back({});\n    }\n\n    vector<int> flip() {\n        int c = 0;\n        int c0 = 0;\n        int k = randint(rem);\n        for (auto& b1 : buckets) {\n            if (c0 + b_size - b1.size() > k) {\n                while (true) {\n                    if (!b1.count(c)) {\n                        if (c0 == k) {\n                            b1.insert(c);\n                            rem--;\n                            return {c / nc, c % nc};\n                        }\n                        c0++;\n                    }\n                    c++;\n                }\n            }\n            c += b_size;\n            c0 += b_size - b1.size();\n        }\n    }\n\n    void reset() {\n        for (auto& b1 : buckets)\n            b1.clear();\n        rem = nr * nc;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n\n    int nr, nc, rem, b_size;\n    List<Set<Integer>> buckets = new ArrayList<>();\n    Random rand = new Random();\n\n    public Solution(int n_rows, int n_cols) {\n        nr = n_rows;\n        nc = n_cols;\n        rem = nr * nc;\n        b_size = (int) Math.sqrt(nr * nc);\n        for (int i = 0; i < nr * nc; i+= b_size)\n            buckets.add(new HashSet<Integer>());\n    }\n\n    public int[] flip() {\n        int c = 0;\n        int c0 = 0;\n        int k = rand.nextInt(rem);\n        for (Set<Integer> b1 : buckets) {\n            if (c0 + b_size - b1.size() > k) {\n                while (true) {\n                    if (!b1.contains(c)) {\n                        if (c0 == k) {\n                            b1.add(c);\n                            rem--;\n                            return new int[]{c / nc, c % nc};\n                        }\n                        c0++;\n                    }\n                    c++;\n                }\n            }\n            c += b_size;\n            c0 += b_size - b1.size();\n        }\n        return null;\n    }\n\n    public void reset() {\n        for (Set<Integer> b1 : buckets)\n            b1.clear();\n        rem = nr * nc;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/detect-capital", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-uncommon-subsequence-i", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/continuous-subarray-sum", "source": [{"lang": "Java", "code": "public class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n\n        for (int start = 0; start < nums.length - 1; start++) {\n            for (int end = start + 1; end < nums.length; end++) {\n                int sum = 0;\n                for (int i = start; i <= end; i++)\n                    sum += nums[i];\n                if (sum == k || (k != 0 && sum % k == 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        int[] sum = new int[nums.length];\n        sum[0] = nums[0];\n        for (int i = 1; i < nums.length; i++)\n            sum[i] = sum[i - 1] + nums[i];\n        for (int start = 0; start < nums.length - 1; start++) {\n            for (int end = start + 1; end < nums.length; end++) {\n                int summ = sum[end] - sum[start] + nums[start];\n                if (summ == k || (k != 0 && summ % k == 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        int sum = 0;\n        HashMap < Integer, Integer > map = new HashMap < > ();\n        map.put(0, -1);\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            if (k != 0)\n                sum = sum % k;\n            if (map.containsKey(sum)) {\n                if (i - map.get(sum) > 1)\n                    return true;\n            } else\n                map.put(sum, i);\n        }\n        return false;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting", "source": []}
{"url": "https://leetcode-cn.com/problems/contiguous-array", "source": [{"lang": "Java", "code": "public class Solution {\n\n    public int findMaxLength(int[] nums) {\n        int maxlen = 0;\n        for (int start = 0; start < nums.length; start++) {\n            int zeroes = 0, ones = 0;\n            for (int end = start; end < nums.length; end++) {\n                if (nums[end] == 0) {\n                    zeroes++;\n                } else {\n                    ones++;\n                }\n                if (zeroes == ones) {\n                    maxlen = Math.max(maxlen, end - start + 1);\n                }\n            }\n        }\n        return maxlen;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n\n    public int findMaxLength(int[] nums) {\n        int[] arr = new int[2 * nums.length + 1];\n        Arrays.fill(arr, -2);\n        arr[nums.length] = -1;\n        int maxlen = 0, count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            count = count + (nums[i] == 0 ? -1 : 1);\n            if (arr[count + nums.length] >= -1) {\n                maxlen = Math.max(maxlen, i - arr[count + nums.length]);\n            } else {\n                arr[count + nums.length] = i;\n            }\n\n        }\n        return maxlen;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n\n    public int findMaxLength(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        int maxlen = 0, count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            count = count + (nums[i] == 1 ? 1 : -1);\n            if (map.containsKey(count)) {\n                maxlen = Math.max(maxlen, i - map.get(count));\n            } else {\n                map.put(count, i);\n            }\n        }\n        return maxlen;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/beautiful-arrangement", "source": [{"lang": "Java", "code": "public class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        int[] nums = new int[N];\n        for (int i = 1; i <= N; i++)\n            nums[i - 1] = i;\n        permute(nums, 0);\n        return count;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length - 1) {\n            int i;\n            for (i = 1; i <= nums.length; i++) {\n                if (nums[i - 1] % i != 0 && i % nums[i - 1] != 0)\n                    break;\n            }\n            if (i > nums.length) {\n                count++;\n            }\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        int[] nums = new int[N];\n        for (int i = 1; i <= N; i++)\n            nums[i - 1] = i;\n        permute(nums, 0);\n        return count;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length) {\n            count++;\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            if (nums[l] % (l + 1) == 0 || (l + 1) % nums[l] == 0)\n                permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        boolean[] visited = new boolean[N + 1];\n        calculate(N, 1, visited);\n        return count;\n    }\n    public void calculate(int N, int pos, boolean[] visited) {\n        if (pos > N)\n            count++;\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i] && (pos % i == 0 || i % pos == 0)) {\n                visited[i] = true;\n                calculate(N, pos + 1, visited);\n                visited[i] = false;\n            }\n        }\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/random-pick-with-weight", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    vector<int> psum;\n    int tot = 0;\n    //c++11 random integer generation\n    mt19937 rng{random_device{}()};\n    uniform_int_distribution<int> uni;\n\n    Solution(vector<int> w) {\n        for (int x : w) {\n            tot += x;\n            psum.push_back(tot);\n        }\n        uni = uniform_int_distribution<int>{0, tot - 1};\n    }\n\n    int pickIndex() {\n        int targ = uni(rng);\n\n        int lo = 0, hi = psum.size() - 1;\n        while (lo != hi) {\n            int mid = (lo + hi) / 2;\n            if (targ >= psum[mid]) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n\n    List<Integer> psum = new ArrayList<>();\n    int tot = 0;\n    Random rand = new Random();\n\n    public Solution(int[] w) {\n        for (int x : w) {\n            tot += x;\n            psum.add(tot);\n        }\n    }\n\n    public int pickIndex() {\n        int targ = rand.nextInt(tot);\n\n        int lo = 0;\n        int hi = psum.size() - 1;\n        while (lo != hi) {\n            int mid = (lo + hi) / 2;\n            if (targ >= psum.get(mid)) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/minesweeper", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst", "source": []}
{"url": "https://leetcode-cn.com/problems/k-diff-pairs-in-an-array", "source": []}
{"url": "https://leetcode-cn.com/problems/encode-and-decode-tinyurl", "source": []}
{"url": "https://leetcode-cn.com/problems/complex-number-multiplication", "source": [{"lang": "Java", "code": "public class Solution {\n\n    public String complexNumberMultiply(String a, String b) {\n        String x[] = a.split(\"\\\\+|i\");\n        String y[] = b.split(\"\\\\+|i\");\n        int a_real = Integer.parseInt(x[0]);\n        int a_img = Integer.parseInt(x[1]);\n        int b_real = Integer.parseInt(y[0]);\n        int b_img = Integer.parseInt(y[1]);\n        return (a_real * b_real - a_img * b_img) + \"+\" + (a_real * b_img + a_img * b_real) + \"i\";\n\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/convert-bst-to-greater-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-time-difference", "source": []}
{"url": "https://leetcode-cn.com/problems/single-element-in-a-sorted-array", "source": [{"lang": "Java", "code": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        for (int i = 0; i < nums.length - 1; i+=2) {\n            if (nums[i] != nums[i + 1]) {\n                return nums[i];\n            }\n        }\n        return nums[nums.length - 1];\n    }\n}"}, {"lang": "Python", "code": "def singleNonDuplicate(self, nums: List[int]) -> int:\n    for i in range(0, len(nums) - 2, 2):\n        if nums[i] != nums[i + 1]:\n            return nums[i]\n    return nums[-1]"}, {"lang": "C++", "code": "class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        for (int i = 0; i < nums.size() - 1; i += 2) {\n            if (nums[i] != nums[i + 1]) {\n                return nums[i];\n            }\n        }\n        return nums.back();\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            boolean halvesAreEven = (hi - mid) % 2 == 0;\n            if (nums[mid + 1] == nums[mid]) {\n                if (halvesAreEven) {\n                    lo = mid + 2;\n                } else {\n                    hi = mid - 1;\n                }\n            } else if (nums[mid - 1] == nums[mid]) {\n                if (halvesAreEven) {\n                    hi = mid - 2;\n                } else {\n                    lo = mid + 1;\n                }\n            } else {\n                return nums[mid];\n            }\n        }\n        return nums[lo];\n    }\n}"}, {"lang": "Python", "code": "def singleNonDuplicate(self, nums: List[int]) -> int:\n    lo = 0\n    hi = len(nums) - 1   \n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        halves_are_even = (hi - mid) % 2 == 0\n        if nums[mid + 1] == nums[mid]:\n            if halves_are_even:\n                lo = mid + 2\n            else:\n                hi = mid - 1\n        elif nums[mid - 1] == nums[mid]:\n            if halves_are_even:\n                hi = mid - 2\n            else:\n                lo = mid + 1\n        else:\n            return nums[mid]\n    return nums[lo]"}, {"lang": "C++", "code": "class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int lo = 0;\n        int hi = nums.size() - 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            bool halvesAreEven = (hi - mid) % 2 == 0;\n            if (nums[mid + 1] == nums[mid]) {\n                if (halvesAreEven) {\n                    lo = mid + 2;\n                } else {\n                    hi = mid - 1;\n                }\n            } else if (nums[mid - 1] == nums[mid]) {\n                if (halvesAreEven) {\n                    hi = mid - 2;\n                } else {\n                    lo = mid + 1;\n                }\n            } else {\n                return nums[mid];\n            }\n        }\n        return nums[lo];\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (mid % 2 == 1) mid--;\n            if (nums[mid] == nums[mid + 1]) {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        }\n        return nums[lo];\n    }\n}"}, {"lang": "Python", "code": "def singleNonDuplicate(self, nums: List[int]) -> int:\n    lo = 0\n    hi = len(nums) - 1\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            lo = mid + 2\n        else:\n            hi = mid\n    return nums[lo]"}, {"lang": "C++", "code": "class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int lo = 0;\n        int hi = nums.size() - 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (mid % 2 == 1) mid--;\n            if (nums[mid] == nums[mid + 1]) {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        }\n        return nums[lo];\n    }\n};"}]}
{"url": "https://leetcode-cn.com/problems/reverse-string-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/01-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/diameter-of-binary-tree", "source": [{"lang": "python", "code": "class Solution(object):\n    def diameterOfBinaryTree(self, root):\n        self.ans = 1\n        def depth(node):\n            if not node: return 0\n            L = depth(node.left)\n            R = depth(node.right)\n            self.ans = max(self.ans, L+R+1)\n            return max(L, R) + 1\n\n        depth(root)\n        return self.ans - 1"}, {"lang": "java", "code": "class Solution {\n    int ans;\n    public int diameterOfBinaryTree(TreeNode root) {\n        ans = 1;\n        depth(root);\n        return ans - 1;\n    }\n    public int depth(TreeNode node) {\n        if (node == null) return 0;\n        int L = depth(node.left);\n        int R = depth(node.right);\n        ans = Math.max(ans, L+R+1);\n        return Math.max(L, R) + 1;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/remove-boxes", "source": [{"lang": "Java", "code": "public class Solution {\n    public int removeBoxes(int[] boxes) {\n        return remove(boxes);\n    }\n    public int remove(int[] boxes)\n    {\n        if(boxes.length==0)\n            return 0;\n        int res=0;\n        for(int i=0,j=i+1;i<boxes.length;i++)\n        {\n            while(j<boxes.length && boxes[i]==boxes[j])\n                j++;\n            int[] newboxes=new int[boxes.length-(j-i)];\n            for(int k=0,p=0;k<boxes.length;k++)\n            {\n                if(k==i)\n                    k=j;\n                if(k<boxes.length)\n                    newboxes[p++]=boxes[k];\n            }\n            res=Math.max(res,remove(newboxes)+(j-i)*(j-i));\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "class Solution {\n\n    public int removeBoxes(int[] boxes) {\n        int[][][] dp = new int[100][100][100];\n        return calculatePoints(boxes, dp, 0, boxes.length - 1, 0);\n    }\n\n    public int calculatePoints(int[] boxes, int[][][] dp, int l, int r, int k) {\n        if (l > r) return 0;\n        if (dp[l][r][k] != 0) return dp[l][r][k];\n        while (r > l && boxes[r] == boxes[r - 1]) {\n            r--;\n            k++;\n        }\n        dp[l][r][k] = calculatePoints(boxes, dp, l, r - 1, 0) + (k + 1) * (k + 1);\n        for (int i = l; i < r; i++) {\n            if (boxes[i] == boxes[r]) {\n                dp[l][r][k] = Math.max(dp[l][r][k], calculatePoints(boxes, dp, l, i, k + 1) + calculatePoints(boxes, dp, i + 1, r - 1, 0));\n            }\n        }\n        return dp[l][r][k];\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/friend-circles", "source": [{"lang": "Java", "code": "M= [1 1 0 0 0 0\n    1 1 0 0 0 0\n    0 0 1 1 1 0\n    0 0 1 1 0 0\n    0 0 1 0 1 0\n    0 0 0 0 0 1]"}, {"lang": "Java", "code": "public class Solution {\n    public void dfs(int[][] M, int[] visited, int i) {\n        for (int j = 0; j < M.length; j++) {\n            if (M[i][j] == 1 && visited[j] == 0) {\n                visited[j] = 1;\n                dfs(M, visited, j);\n            }\n        }\n    }\n    public int findCircleNum(int[][] M) {\n        int[] visited = new int[M.length];\n        int count = 0;\n        for (int i = 0; i < M.length; i++) {\n            if (visited[i] == 0) {\n                dfs(M, visited, i);\n                count++;\n            }\n        }\n        return count;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int findCircleNum(int[][] M) {\n        int[] visited = new int[M.length];\n        int count = 0;\n        Queue < Integer > queue = new LinkedList < > ();\n        for (int i = 0; i < M.length; i++) {\n            if (visited[i] == 0) {\n                queue.add(i);\n                while (!queue.isEmpty()) {\n                    int s = queue.remove();\n                    visited[s] = 1;\n                    for (int j = 0; j < M.length; j++) {\n                        if (M[s][j] == 1 && visited[j] == 0)\n                            queue.add(j);\n                    }\n                }\n                count++;\n            }\n        }\n        return count;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/student-attendance-record-i", "source": []}
{"url": "https://leetcode-cn.com/problems/student-attendance-record-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/optimal-division", "source": [{"lang": "Java", "code": "public class Solution {\n    public String optimalDivision(int[] nums) {\n        T t = optimal(nums, 0, nums.length - 1, \"\");\n        return t.max_str;\n    }\n    class T {\n        float max_val, min_val;\n        String min_str, max_str;\n    }\n    public T optimal(int[] nums, int start, int end, String res) {\n        T t = new T();\n        if (start == end) {\n            t.max_val = nums[start];\n            t.min_val = nums[start];\n            t.min_str = \"\" + nums[start];\n            t.max_str = \"\" + nums[start];\n            return t;\n        }\n        t.min_val = Float.MAX_VALUE;\n        t.max_val = Float.MIN_VALUE;\n        t.min_str = t.max_str = \"\";\n        for (int i = start; i < end; i++) {\n            T left = optimal(nums, start, i, \"\");\n            T right = optimal(nums, i + 1, end, \"\");\n            if (t.min_val > left.min_val / right.max_val) {\n                t.min_val = left.min_val / right.max_val;\n                t.min_str = left.min_str + \"/\" + (i + 1 != end ? \"(\" : \"\") + right.max_str + (i + 1 != end ? \")\" : \"\");\n            }\n            if (t.max_val < left.max_val / right.min_val) {\n                t.max_val = left.max_val / right.min_val;\n                t.max_str = left.max_str + \"/\" + (i + 1 != end ? \"(\" : \"\") + right.min_str + (i + 1 != end ? \")\" : \"\");\n            }\n        }\n        return t;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    class T {\n        float max_val, min_val;\n        String min_str, max_str;\n    }\n    public String optimalDivision(int[] nums) {\n        T[][] memo = new T[nums.length][nums.length];\n        T t = optimal(nums, 0, nums.length - 1, \"\", memo);\n        return t.max_str;\n    }\n    public T optimal(int[] nums, int start, int end, String res, T[][] memo) {\n        if (memo[start][end] != null)\n            return memo[start][end];\n        T t = new T();\n        if (start == end) {\n            t.max_val = nums[start];\n            t.min_val = nums[start];\n            t.min_str = \"\" + nums[start];\n            t.max_str = \"\" + nums[start];\n            memo[start][end] = t;\n            return t;\n        }\n        t.min_val = Float.MAX_VALUE;\n        t.max_val = Float.MIN_VALUE;\n        t.min_str = t.max_str = \"\";\n        for (int i = start; i < end; i++) {\n            T left = optimal(nums, start, i, \"\", memo);\n            T right = optimal(nums, i + 1, end, \"\", memo);\n            if (t.min_val > left.min_val / right.max_val) {\n                t.min_val = left.min_val / right.max_val;\n                t.min_str = left.min_str + \"/\" + (i + 1 != end ? \"(\" : \"\") + right.max_str + (i + 1 != end ? \")\" : \"\");\n            }\n            if (t.max_val < left.max_val / right.min_val) {\n                t.max_val = left.max_val / right.min_val;\n                t.max_str = left.max_str + \"/\" + (i + 1 != end ? \"(\" : \"\") + right.min_str + (i + 1 != end ? \")\" : \"\");\n            }\n        }\n        memo[start][end] = t;\n        return t;\n    }\n}"}, {"lang": "Java", "code": "b/(c/d)        (b/c)/d = b/c/d\n(b*d)/c        b/(d*c)\nd/c            1/(d*c)"}]}
{"url": "https://leetcode-cn.com/problems/brick-wall", "source": [{"lang": "Java", "code": "public class Solution {\n    public int leastBricks(List < List < Integer >> wall) {\n        int[] pos = new int[wall.size()];\n        int c = 0, sum = 0, res = Integer.MAX_VALUE;\n        for (int el: wall.get(0))\n            sum += el;\n        while (sum != 0) {\n            int count = 0;\n            for (int i = 0; i < wall.size(); i++) {\n                List < Integer > row = wall.get(i);\n                if (row.get(pos[i]) != 0)\n                    count++;\n                else\n                    pos[i]++;\n                row.set(pos[i], row.get(pos[i]) - 1);\n            }\n            sum--;\n            res = Math.min(res, count);\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "[[100, 50, 50],\n[50, 100],\n[150]]"}, {"lang": "Java", "code": "public class Solution {\n    public int leastBricks(List < List < Integer >> wall) {\n        int[] pos = new int[wall.size()];\n        int sum = 0, res = Integer.MAX_VALUE;\n        for (int el: wall.get(0))\n            sum += el;\n        while (sum != 0) {\n            int count = 0, mini = Integer.MAX_VALUE;\n            for (int i = 0; i < wall.size(); i++) {\n                List < Integer > row = wall.get(i);\n                if (row.get(pos[i]) != 0) {\n                    count++;\n                } else\n                    pos[i]++;\n                mini = Math.min(mini, row.get(pos[i]));\n            }\n            for (int i = 0; i < wall.size(); i++) {\n                List < Integer > row = wall.get(i);\n                row.set(pos[i], row.get(pos[i]) - mini);\n            }\n            sum -= mini;\n            res = Math.min(res, count);\n        }\n        return res;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/next-greater-element-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-words-in-a-string-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/quad-tree-intersection", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/subarray-sum-equals-k", "source": []}
{"url": "https://leetcode-cn.com/problems/array-partition-i", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-tree-tilt", "source": [{"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\npublic class Solution {\n    int tilt=0;\n    public int findTilt(TreeNode root) {\n        traverse(root);\n        return tilt;\n    }\n    public int traverse(TreeNode root)\n    {\n        if(root==null )\n            return 0;\n        int left=traverse(root.left);\n        int right=traverse(root.right);\n        tilt+=Math.abs(left-right);\n        return left+right+root.val;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/find-the-closest-palindrome", "source": [{"lang": "Java", "code": "public class Solution {\n    public int arrayNesting(int[] nums) {\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int start = nums[i], count = 0;\n            do {\n                start = nums[start];\n                count++;\n            }\n            while (start != nums[i]);\n            res = Math.max(res, count);\n\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public String mirroring(String s) {\n        String x = s.substring(0, (s.length()) / 2);\n        return x + (s.length() % 2 == 1 ? s.charAt(s.length() / 2) : \"\") + new StringBuilder(x).reverse().toString();\n    }\n    public String nearestPalindromic(String n) {\n        if (n.equals(\"1\"))\n            return \"0\";\n\n        String a = mirroring(n);\n        long diff1 = Long.MAX_VALUE;\n        diff1 = Math.abs(Long.parseLong(n) - Long.parseLong(a));\n        if (diff1 == 0)\n            diff1 = Long.MAX_VALUE;\n\n        StringBuilder s = new StringBuilder(n);\n        int i = (s.length() - 1) / 2;\n        while (i >= 0 && s.charAt(i) == '0') {\n            s.replace(i, i + 1, \"9\");\n            i--;\n        }\n        if (i == 0 && s.charAt(i) == '1') {\n            s.delete(0, 1);\n            int mid = (s.length() - 1) / 2;\n            s.replace(mid, mid + 1, \"9\");\n        } else\n            s.replace(i, i + 1, \"\" + (char)(s.charAt(i) - 1));\n        String b = mirroring(s.toString());\n        long diff2 = Math.abs(Long.parseLong(n) - Long.parseLong(b));\n\n\n        s = new StringBuilder(n);\n        i = (s.length() - 1) / 2;\n        while (i >= 0 && s.charAt(i) == '9') {\n            s.replace(i, i + 1, \"0\");\n            i--;\n        }\n        if (i < 0) {\n            s.insert(0, \"1\");\n        } else\n            s.replace(i, i + 1, \"\" + (char)(s.charAt(i) + 1));\n        String c = mirroring(s.toString());\n        long diff3 = Math.abs(Long.parseLong(n) - Long.parseLong(c));\n\n        if (diff2 <= diff1 && diff2 <= diff3)\n            return b;\n        if (diff1 <= diff3 && diff1 <= diff2)\n            return a;\n        else\n            return c;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/array-nesting", "source": [{"lang": "Java", "code": "public class Solution {\n    public int arrayNesting(int[] nums) {\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int start = nums[i], count = 0;\n            do {\n                start = nums[start];\n                count++;\n            }\n            while (start != nums[i]);\n            res = Math.max(res, count);\n\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int arrayNesting(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (!visited[i]) {\n                int start = nums[i], count = 0;\n                do {\n                    start = nums[start];\n                    count++;\n                    visited[start] = true;\n                }\n                while (start != nums[i]);\n                res = Math.max(res, count);\n            }\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int arrayNesting(int[] nums) {\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != Integer.MAX_VALUE) {\n                int start = nums[i], count = 0;\n                while (nums[start] != Integer.MAX_VALUE) {\n                    int temp = start;\n                    start = nums[start];\n                    count++;\n                    nums[temp] = Integer.MAX_VALUE;\n                }\n                res = Math.max(res, count);\n            }\n        }\n        return res;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/reshape-the-matrix", "source": [{"lang": "Java", "code": "public class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int count = 0;\n        Queue < Integer > queue = new LinkedList < > ();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                queue.add(nums[i][j]);\n            }\n        }\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                res[i][j] = queue.remove();\n            }\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int rows = 0, cols = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                res[rows][cols] = nums[i][j];\n                cols++;\n                if (cols == c) {\n                    rows++;\n                    cols = 0;\n                }\n            }\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                res[count / c][count % c] = nums[i][j];\n                count++;\n            }\n        }\n        return res;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/permutation-in-string", "source": [{"lang": "Java", "code": "public class Solution {\n    boolean flag = false;\n    public boolean checkInclusion(String s1, String s2) {\n        permute(s1, s2, 0);\n        return flag;\n    }\n    public String swap(String s, int i0, int i1) {\n        if (i0 == i1)\n            return s;\n        String s1 = s.substring(0, i0);\n        String s2 = s.substring(i0 + 1, i1);\n        String s3 = s.substring(i1 + 1);\n        return s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;\n    }\n    void permute(String s1, String s2, int l) {\n        if (l == s1.length()) {\n            if (s2.indexOf(s1) >= 0)\n                flag = true;\n        } else {\n            for (int i = l; i < s1.length(); i++) {\n                s1 = swap(s1, l, i);\n                permute(s1, s2, l + 1);\n                s1 = swap(s1, l, i);\n            }\n        }\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n\n    public boolean checkInclusion(String s1, String s2) {\n        s1 = sort(s1);\n        for (int i = 0; i <= s2.length() - s1.length(); i++) {\n            if (s1.equals(sort(s2.substring(i, i + s1.length()))))\n                return true;\n        }\n        return false;\n    }\n    public String sort(String s) {\n        char[] t = s.toCharArray();\n        Arrays.sort(t);\n        return new String(t);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n\n    public boolean checkInclusion(String s1, String s2) {\n        s1 = sort(s1);\n        for (int i = 0; i <= s2.length() - s1.length(); i++) {\n            if (s1.equals(sort(s2.substring(i, i + s1.length()))))\n                return true;\n        }\n        return false;\n    }\n    public String sort(String s) {\n        char[] t = s.toCharArray();\n        Arrays.sort(t);\n        return new String(t);\n    }\n}"}, {"lang": "4", "code": "public class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length())\n            return false;\n        int[] s1map = new int[26];\n        for (int i = 0; i < s1.length(); i++)\n            s1map[s1.charAt(i) - 'a']++;\n        for (int i = 0; i <= s2.length() - s1.length(); i++) {\n            int[] s2map = new int[26];\n            for (int j = 0; j < s1.length(); j++) {\n                s2map[s2.charAt(i + j) - 'a']++;\n            }\n            if (matches(s1map, s2map))\n                return true;\n        }\n        return false;\n    }\n    public boolean matches(int[] s1map, int[] s2map) {\n        for (int i = 0; i < 26; i++) {\n            if (s1map[i] != s2map[i])\n                return false;\n        }\n        return true;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length())\n            return false;\n        int[] s1map = new int[26];\n        int[] s2map = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            s1map[s1.charAt(i) - 'a']++;\n            s2map[s2.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i < s2.length() - s1.length(); i++) {\n            if (matches(s1map, s2map))\n                return true;\n            s2map[s2.charAt(i + s1.length()) - 'a']++;\n            s2map[s2.charAt(i) - 'a']--;\n        }\n        return matches(s1map, s2map);\n    }\n    public boolean matches(int[] s1map, int[] s2map) {\n        for (int i = 0; i < 26; i++) {\n            if (s1map[i] != s2map[i])\n                return false;\n        }\n        return true;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length())\n            return false;\n        int[] s1map = new int[26];\n        int[] s2map = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            s1map[s1.charAt(i) - 'a']++;\n            s2map[s2.charAt(i) - 'a']++;\n        }\n        int count = 0;\n        for (int i = 0; i < 26; i++)\n            if (s1map[i] == s2map[i])\n                count++;\n        for (int i = 0; i < s2.length() - s1.length(); i++) {\n            int r = s2.charAt(i + s1.length()) - 'a', l = s2.charAt(i) - 'a';\n            if (count == 26)\n                return true;\n            s2map[r]++;\n            if (s2map[r] == s1map[r])\n                count++;\n            else if (s2map[r] == s1map[r] + 1)\n                count--;\n            s2map[l]--;\n            if (s2map[l] == s1map[l])\n                count++;\n            else if (s2map[l] == s1map[l] - 1)\n                count--;\n        }\n        return count == 26;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/subtree-of-another-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/distribute-candies", "source": [{"lang": "Java", "code": "public class Solution {\n    int max_kind = 0;\n    public int distributeCandies(int[] nums) {\n        permute(nums, 0);\n        return max_kind;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length - 1) {\n            HashSet < Integer > set = new HashSet < > ();\n            for (int i = 0; i < nums.length / 2; i++) {\n                set.add(nums[i]);\n            }\n            max_kind = Math.max(max_kind, set.size());\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int distributeCandies(int[] candies) {\n        int count = 0;\n        for (int i = 0; i < candies.length && count < candies.length / 2; i++) {\n            if (candies[i] != Integer.MIN_VALUE) {\n                count++;\n                for (int j = i + 1; j < candies.length; j++) {\n                    if (candies[j] == candies[i])\n                        candies[j] = Integer.MIN_VALUE;\n                }\n            }\n        }\n        return count;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int distributeCandies(int[] candies) {\n        Arrays.sort(candies);\n        int count = 1;\n        for (int i = 1; i < candies.length && count < candies.length / 2; i++)\n            if (candies[i] > candies[i - 1])\n                count++;\n        return count;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int distributeCandies(int[] candies) {\n        HashSet < Integer > set = new HashSet < > ();\n        for (int candy: candies) {\n            set.add(candy);\n        }\n        return Math.min(set.size(), candies.length / 2);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/out-of-boundary-paths", "source": []}
{"url": "https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray", "source": [{"lang": "Java", "code": "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i; j <= nums.length; j++) {\n                int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, prev = Integer.MIN_VALUE;\n                for (int k = i; k < j; k++) {\n                    min = Math.min(min, nums[k]);\n                    max = Math.max(max, nums[k]);\n                }\n                if ((i > 0 && nums[i - 1] > min) || (j < nums.length && nums[j] < max))\n                    continue;\n                int k = 0;\n                while (k < i && prev <= nums[k]) {\n                    prev = nums[k];\n                    k++;\n                }\n                if (k != i)\n                    continue;\n                k = j;\n                while (k < nums.length && prev <= nums[k]) {\n                    prev = nums[k];\n                    k++;\n                }\n                if (k == nums.length) {\n                    res = Math.min(res, j - i);\n\n                }\n            }\n        }\n        return res;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int l = nums.length, r = 0;\n        for (int i = 0; i < nums.length - 1; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] < nums[i]) {\n                    r = Math.max(r, j);\n                    l = Math.min(l, i);\n                }\n            }\n        }\n        return r - l < 0 ? 0 : r - l + 1;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int[] snums = nums.clone();\n        Arrays.sort(snums);\n        int start = snums.length, end = 0;\n        for (int i = 0; i < snums.length; i++) {\n            if (snums[i] != nums[i]) {\n                start = Math.min(start, i);\n                end = Math.max(end, i);\n            }\n        }\n        return (end - start >= 0 ? end - start + 1 : 0);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        Stack < Integer > stack = new Stack < Integer > ();\n        int l = nums.length, r = 0;\n        for (int i = 0; i < nums.length; i++) {\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[i])\n                l = Math.min(l, stack.pop());\n            stack.push(i);\n        }\n        stack.clear();\n        for (int i = nums.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[i])\n                r = Math.max(r, stack.pop());\n            stack.push(i);\n        }\n        return r - l > 0 ? r - l + 1 : 0;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        boolean flag = false;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] < nums[i - 1])\n                flag = true;\n            if (flag)\n                min = Math.min(min, nums[i]);\n        }\n        flag = false;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            if (nums[i] > nums[i + 1])\n                flag = true;\n            if (flag)\n                max = Math.max(max, nums[i]);\n        }\n        int l, r;\n        for (l = 0; l < nums.length; l++) {\n            if (min < nums[l])\n                break;\n        }\n        for (r = nums.length - 1; r >= 0; r--) {\n            if (max > nums[r])\n                break;\n        }\n        return r - l < 0 ? 0 : r - l + 1;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/delete-operation-for-two-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/erect-the-fence", "source": [{"lang": "Java", "code": "public class Solution {\n    public int orientation(Point p, Point q, Point r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    }\n    public boolean inBetween(Point p, Point i, Point q) {\n        boolean a = i.x >= p.x && i.x <= q.x || i.x <= p.x && i.x >= q.x;\n        boolean b = i.y >= p.y && i.y <= q.y || i.y <= p.y && i.y >= q.y;\n        return a && b;\n    }\n    public List < Point > outerTrees(Point[] points) {\n        HashSet < Point > hull = new HashSet < > ();\n        if (points.length < 4) {\n            for (Point p: points)\n                hull.add(p);\n            return new ArrayList<Point>(hull);\n        }\n        int left_most = 0;\n        for (int i = 0; i < points.length; i++)\n            if (points[i].x < points[left_most].x)\n                left_most = i;\n        int p = left_most;\n        do {\n            int q = (p + 1) % points.length;\n            for (int i = 0; i < points.length; i++) {\n                if (orientation(points[p], points[i], points[q]) < 0) {\n                    q = i;\n                }\n            }\n            for (int i = 0; i < points.length; i++) {\n                if (i != p && i != q && orientation(points[p], points[i], points[q]) == 0 && inBetween(points[p], points[i], points[q])) {\n                    hull.add(points[i]);\n                }\n            }\n            hull.add(points[q]);\n            p = q;\n        }\n        while (p != left_most);\n        return new ArrayList<Point>(hull);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int orientation(Point p, Point q, Point r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    }\n    public int distance(Point p, Point q) {\n        return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n    }\n    private static Point bottomLeft(Point[] points) {\n        Point bottomLeft = points[0];\n        for (Point p: points)\n            if (p.y < bottomLeft.y)\n                bottomLeft = p;\n        return bottomLeft;\n    }\n    public List < Point > outerTrees(Point[] points) {\n        if (points.length <= 1)\n            return Arrays.asList(points);\n        Point bm = bottomLeft(points);\n        Arrays.sort(points, new Comparator < Point > () {\n            public int compare(Point p, Point q) {\n                double diff = orientation(bm, p, q) - orientation(bm, q, p);\n                if (diff == 0)\n                    return distance(bm, p) - distance(bm, q);\n                else\n                    return diff > 0 ? 1 : -1;\n            }\n        });\n        int i = points.length - 1;\n        while (i >= 0 && orientation(bm, points[points.length - 1], points[i]) == 0)\n            i--;\n        for (int l = i + 1, h = points.length - 1; l < h; l++, h--) {\n            Point temp = points[l];\n            points[l] = points[h];\n            points[h] = temp;\n        }\n        Stack < Point > stack = new Stack < > ();\n        stack.push(points[0]);\n        stack.push(points[1]);\n        for (int j = 2; j < points.length; j++) {\n            Point top = stack.pop();\n            while (orientation(stack.peek(), top, points[j]) > 0)\n                top = stack.pop();\n            stack.push(top);\n            stack.push(points[j]);\n        }\n        return new ArrayList < > (stack);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int orientation(Point p, Point q, Point r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    }\n    public List < Point > outerTrees(Point[] points) {\n        Arrays.sort(points, new Comparator < Point > () {\n            public int compare(Point p, Point q) {\n                return q.x - p.x == 0 ? q.y - p.y : q.x - p.x;\n            }\n        });\n        Stack < Point > hull = new Stack < > ();\n        for (int i = 0; i < points.length; i++) {\n            while (hull.size() >= 2 && orientation(hull.get(hull.size() - 2), hull.get(hull.size() - 1), points[i]) > 0)\n                hull.pop();\n            hull.push(points[i]);\n        }\n        hull.pop();\n        for (int i = points.length - 1; i >= 0; i--) {\n            while (hull.size() >= 2 && orientation(hull.get(hull.size() - 2), hull.get(hull.size() - 1), points[i]) > 0)\n                hull.pop();\n            hull.push(points[i]);\n        }\n        return new ArrayList < > (new HashSet < > (hull));\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/tag-validator", "source": [{"lang": "Java", "code": "public class Solution {\n    Stack < String > stack = new Stack < > ();\n    boolean contains_tag = false;\n    public boolean isValidTagName(String s, boolean ending) {\n        if (s.length() < 1 || s.length() > 9)\n            return false;\n        for (int i = 0; i < s.length(); i++) {\n            if (!Character.isUpperCase(s.charAt(i)))\n                return false;\n        }\n        if (ending) {\n            if (!stack.isEmpty() && stack.peek().equals(s))\n                stack.pop();\n            else\n                return false;\n        } else {\n            contains_tag = true;\n            stack.push(s);\n        }\n        return true;\n    }\n    public boolean isValidCdata(String s) {\n        return s.indexOf(\"[CDATA[\") == 0;\n    }\n    public boolean isValid(String code) {\n        if (code.charAt(0) != '<' || code.charAt(code.length() - 1) != '>')\n            return false;\n        for (int i = 0; i < code.length(); i++) {\n            boolean ending = false;\n            int closeindex;\n            if(stack.isEmpty() && contains_tag)\n                return false;\n            if (code.charAt(i) == '<') {\n                if (!stack.isEmpty() && code.charAt(i + 1) == '!') {\n                    closeindex = code.indexOf(\"]]>\", i + 1);\n                    if (closeindex < 0 || !isValidCdata(code.substring(i + 2, closeindex)))\n                        return false;\n                } else {\n                    if (code.charAt(i + 1) == '/') {\n                        i++;\n                        ending = true;\n                    }\n                    closeindex = code.indexOf('>', i + 1);\n                    if (closeindex < 0 || !isValidTagName(code.substring(i + 1, closeindex), ending))\n                        return false;\n                }\n                i = closeindex;\n            }\n        }\n        return stack.isEmpty() && contains_tag;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/fraction-addition-and-subtraction", "source": [{"lang": "", "code": "public class Solution {\n    public String fractionAddition(String expression) {\n        List < Character > sign = new ArrayList < > ();\n        for (int i = 1; i < expression.length(); i++) {\n            if (expression.charAt(i) == '+' || expression.charAt(i) == '-')\n                sign.add(expression.charAt(i));\n        }\n        List < Integer > num = new ArrayList < > ();\n        List < Integer > den = new ArrayList < > ();\n        for (String sub: expression.split(\"\\\\+\")) {\n            for (String subsub: sub.split(\"-\")) {\n                if (subsub.length() > 0) {\n                    String[] fraction = subsub.split(\"/\");\n                    num.add(Integer.parseInt(fraction[0]));\n                    den.add(Integer.parseInt(fraction[1]));\n                }\n            }\n        }\n        if (expression.charAt(0) == '-')\n            num.set(0, -num.get(0));\n        int lcm = 1;\n        for (int x: den) {\n            lcm = lcm_(lcm, x);\n        }\n\n        int res = lcm / den.get(0) * num.get(0);\n        for (int i = 1; i < num.size(); i++) {\n            if (sign.get(i - 1) == '+')\n                res += lcm / den.get(i) * num.get(i);\n            else\n                res -= lcm / den.get(i) * num.get(i);\n        }\n        int g = gcd(Math.abs(res), Math.abs(lcm));\n        return (res / g) + \"/\" + (lcm / g);\n    }\n    public int lcm_(int a, int b) {\n        return a * b / gcd(a, b);\n    }\n    public int gcd(int a, int b) {\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public String fractionAddition(String expression) {\n        List < Character > sign = new ArrayList < > ();\n        if (expression.charAt(0) != '-')\n            sign.add('+');\n        for (int i = 0; i < expression.length(); i++) {\n            if (expression.charAt(i) == '+' || expression.charAt(i) == '-')\n                sign.add(expression.charAt(i));\n        }\n        int prev_num = 0, prev_den = 1, i = 0;\n        for (String sub: expression.split(\"(\\\\+)|(-)\")) {\n            if (sub.length() > 0) {\n                String[] fraction = sub.split(\"/\");\n                int num = (Integer.parseInt(fraction[0]));\n                int den = (Integer.parseInt(fraction[1]));\n                int g = Math.abs(gcd(den, prev_den));\n                if (sign.get(i++) == '+')\n                    prev_num = prev_num * den / g + num * prev_den / g;\n                else\n                    prev_num = prev_num * den / g - num * prev_den / g;\n                prev_den = den * prev_den / g;\n                g = Math.abs(gcd(prev_den, prev_num));\n                prev_num /= g;\n                prev_den /= g;\n            }\n        }\n        return prev_num + \"/\" + prev_den;\n    }\n    public int gcd(int a, int b) {\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/valid-square", "source": [{"lang": "Java", "code": "public class Solution {\n    public double dist(int[] p1, int[] p2) {\n        return (p2[1] - p1[1]) * (p2[1] - p1[1]) + (p2[0] - p1[0]) * (p2[0] - p1[0]);\n    }\n    public boolean check(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return dist(p1,p2) > 0 && dist(p1, p2) == dist(p2, p3) && dist(p2, p3) == dist(p3, p4) && dist(p3, p4) == dist(p4, p1) && dist(p1, p3) == dist(p2, p4);\n    }\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        int[][] p = {p1,p2,p3,p4};\n        return checkAllPermutations(p, 0);\n    }\n    boolean checkAllPermutations(int[][] p, int l) {\n        if (l == 4) {\n            return check(p[0], p[1], p[2], p[3]);\n        } else {\n            boolean res = false;\n            for (int i = l; i < 4; i++) {\n                swap(p, l, i);\n                res |= checkAllPermutations(p, l + 1);\n                swap(p, l, i);\n            }\n            return res;\n        }\n    }\n    public void swap(int[][] p, int x, int y) {\n        int[] temp = p[x];\n        p[x] = p[y];\n        p[y] = temp;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public double dist(int[] p1, int[] p2) {\n        return (p2[1] - p1[1]) * (p2[1] - p1[1]) + (p2[0] - p1[0]) * (p2[0] - p1[0]);\n    }\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        int[][] p={p1,p2,p3,p4};\n        Arrays.sort(p, (l1, l2) -> l2[0] == l1[0] ? l1[1] - l2[1] : l1[0] - l2[0]);\n        return dist(p[0], p[1]) != 0 && dist(p[0], p[1]) == dist(p[1], p[3]) && dist(p[1], p[3]) == dist(p[3], p[2]) && dist(p[3], p[2]) == dist(p[2], p[0])   && dist(p[0],p[3])==dist(p[1],p[2]);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public double dist(int[] p1, int[] p2) {\n        return (p2[1] - p1[1]) * (p2[1] - p1[1]) + (p2[0] - p1[0]) * (p2[0] - p1[0]);\n    }\n    public boolean check(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return dist(p1,p2) > 0 && dist(p1, p2) == dist(p2, p3) && dist(p2, p3) == dist(p3, p4) && dist(p3, p4) == dist(p4, p1) && dist(p1, p3) == dist(p2, p4);\n    }\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return check(p1, p2, p3, p4) || check(p1, p3, p2, p4) || check(p1, p2, p4, p3);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/longest-harmonious-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/range-addition-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists", "source": []}
{"url": "https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones", "source": []}
{"url": "https://leetcode-cn.com/problems/can-place-flowers", "source": []}
{"url": "https://leetcode-cn.com/problems/construct-string-from-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/find-duplicate-file-in-system", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-triangle-number", "source": [{"lang": "Java", "code": "public class Solution {\n    public int triangleNumber(int[] nums) {\n        int count = 0;\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k++) {\n                    if (nums[i] + nums[j] > nums[k] && nums[i] + nums[k] > nums[j] && nums[j] + nums[k] > nums[i])\n                        count++;\n                }\n            }\n        } I\n        return count;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    int binarySearch(int nums[], int l, int r, int x) {\n        while (r >= l && r < nums.length) {\n            int mid = (l + r) / 2;\n            if (nums[mid] >= x)\n                r = mid - 1;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n    public int triangleNumber(int[] nums) {\n        int count = 0;\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            int k = i + 2;\n            for (int j = i + 1; j < nums.length - 1 && nums[i] != 0; j++) {\n                k = binarySearch(nums, k, nums.length - 1, nums[i] + nums[j]);\n                count += k - j - 1;\n            }\n        }\n        return count;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/merge-two-binary-trees", "source": [{"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null)\n            return t2;\n        if (t2 == null)\n            return t1;\n        t1.val += t2.val;\n        t1.left = mergeTrees(t1.left, t2.left);\n        t1.right = mergeTrees(t1.right, t2.right);\n        return t1;\n    }\n}"}, {"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null)\n            return t2;\n        Stack < TreeNode[] > stack = new Stack < > ();\n        stack.push(new TreeNode[] {t1, t2});\n        while (!stack.isEmpty()) {\n            TreeNode[] t = stack.pop();\n            if (t[0] == null || t[1] == null) {\n                continue;\n            }\n            t[0].val += t[1].val;\n            if (t[0].left == null) {\n                t[0].left = t[1].left;\n            } else {\n                stack.push(new TreeNode[] {t[0].left, t[1].left});\n            }\n            if (t[0].right == null) {\n                t[0].right = t[1].right;\n            } else {\n                stack.push(new TreeNode[] {t[0].right, t[1].right});\n            }\n        }\n        return t1;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/task-scheduler", "source": [{"lang": "Java", "code": "public class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] map = new int[26];\n        for (char c: tasks)\n            map[c - 'A']++;\n        Arrays.sort(map);\n        int time = 0;\n        while (map[25] > 0) {\n            int i = 0;\n            while (i <= n) {\n                if (map[25] == 0)\n                    break;\n                if (i < 26 && map[25 - i] > 0)\n                    map[25 - i]--;\n                time++;\n                i++;\n            }\n            Arrays.sort(map);\n        }\n        return time;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] map = new int[26];\n        for (char c: tasks)\n            map[c - 'A']++;\n        PriorityQueue < Integer > queue = new PriorityQueue < > (26, Collections.reverseOrder());\n        for (int f: map) {\n            if (f > 0)\n                queue.add(f);\n        }\n        int time = 0;\n        while (!queue.isEmpty()) {\n            int i = 0;\n            List < Integer > temp = new ArrayList < > ();\n            while (i <= n) {\n                if (!queue.isEmpty()) {\n                    if (queue.peek() > 1)\n                        temp.add(queue.poll() - 1);\n                    else\n                        queue.poll();\n                }\n                time++;\n                if (queue.isEmpty() && temp.size() == 0)\n                    break;\n                i++;\n            }\n            for (int l: temp)\n                queue.add(l);\n        }\n        return time;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] map = new int[26];\n        for (char c: tasks)\n            map[c - 'A']++;\n        Arrays.sort(map);\n        int max_val = map[25] - 1, idle_slots = max_val * n;\n        for (int i = 24; i >= 0 && map[i] > 0; i--) {\n            idle_slots -= Math.min(map[i], max_val);\n        }\n        return idle_slots > 0 ? idle_slots + tasks.length : tasks.length;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/design-circular-queue", "source": []}
{"url": "https://leetcode-cn.com/problems/add-one-row-to-tree", "source": [{"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode addOneRow(TreeNode t, int v, int d) {\n        if (d == 1) {\n            TreeNode n = new TreeNode(v);\n            n.left = t;\n            return n;\n        }\n        insert(v, t, 1, d);\n        return t;\n    }\n\n    public void insert(int val, TreeNode node, int depth, int n) {\n        if (node == null)\n            return;\n        if (depth == n - 1) {\n            TreeNode t = node.left;\n            node.left = new TreeNode(val);\n            node.left.left = t;\n            t = node.right;\n            node.right = new TreeNode(val);\n            node.right.right = t;\n        } else {\n            insert(val, node.left, depth + 1, n);\n            insert(val, node.right, depth + 1, n);\n        }\n    }\n}"}, {"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    class Node{\n        Node(TreeNode n,int d){\n            node=n;\n            depth=d;\n        }\n        TreeNode node;\n        int depth;\n    }\n    public TreeNode addOneRow(TreeNode t, int v, int d) {\n        if (d == 1) {\n            TreeNode n = new TreeNode(v);\n            n.left = t;\n            return n;\n        } \n        Stack<Node> stack=new Stack<>();\n        stack.push(new Node(t,1));\n        while(!stack.isEmpty())\n        {\n            Node n=stack.pop();\n            if(n.node==null)\n                continue;\n            if (n.depth == d - 1 ) {\n                TreeNode temp = n.node.left;\n                n.node.left = new TreeNode(v);\n                n.node.left.left = temp;\n                temp = n.node.right;\n                n.node.right = new TreeNode(v);\n                n.node.right.right = temp;\n                \n            } else{\n                stack.push(new Node(n.node.left, n.depth + 1));\n                stack.push(new Node(n.node.right, n.depth + 1));\n            }\n        }\n        return t;\n    }\n}"}, {"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode addOneRow(TreeNode t, int v, int d) {\n        if (d == 1) {\n            TreeNode n = new TreeNode(v);\n            n.left = t;\n            return n;\n        }\n        Queue < TreeNode > queue = new LinkedList < > ();\n        queue.add(t);\n        int depth = 1;\n        while (depth < d - 1) {\n            Queue < TreeNode > temp = new LinkedList < > ();\n            while (!queue.isEmpty()) {\n                TreeNode node = queue.remove();\n                if (node.left != null) temp.add(node.left);\n                if (node.right != null) temp.add(node.right);\n            }\n            queue = temp;\n            depth++;\n        }\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.remove();\n            TreeNode temp = node.left;\n            node.left = new TreeNode(v);\n            node.left.left = temp;\n            temp = node.right;\n            node.right = new TreeNode(v);\n            node.right.right = temp;\n        }\n        return t;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/maximum-product-of-three-numbers", "source": [{"lang": "Java", "code": "public class Solution {\n    public int maximumProduct(int[] nums) {\n        Arrays.sort(nums);\n        return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int maximumProduct(int[] nums) {\n        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\n        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;\n        for (int n: nums) {\n            if (n <= min1) {\n                min2 = min1;\n                min1 = n;\n            } else if (n <= min2) {     // n lies between min1 and min2\n                min2 = n;\n            }\n            if (n >= max1) {            // n is greater than max1, max2 and max3\n                max3 = max2;\n                max2 = max1;\n                max1 = n;\n            } else if (n >= max2) {     // n lies betweeen max1 and max2\n                max3 = max2;\n                max2 = n;\n            } else if (n >= max3) {     // n lies betwen max2 and max3\n                max3 = n;\n            }\n        }\n        return Math.max(min1 * min2 * max1, max1 * max2 * max3);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/k-inverse-pairs-array", "source": []}
{"url": "https://leetcode-cn.com/problems/course-schedule-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists", "source": [{"lang": "Java", "code": "public class Solution {\n    public int[] smallestRange(int[][] nums) {\n        int minx = 0, miny = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        int[] next = new int[nums.length];\n        boolean flag = true;\n        PriorityQueue < Integer > min_queue = new PriorityQueue < Integer > ((i, j) -> nums[i][next[i]] - nums[j][next[j]]);\n        for (int i = 0; i < nums.length; i++) {\n            min_queue.offer(i);\n            max = Math.max(max, nums[i][0]);\n        }\n        for (int i = 0; i < nums.length && flag; i++) {\n            for (int j = 0; j < nums[i].length && flag; j++) {\n                int min_i = min_queue.poll();\n                if (miny - minx > max - nums[min_i][next[min_i]]) {\n                    minx = nums[min_i][next[min_i]];\n                    miny = max;\n                }\n                next[min_i]++;\n                if (next[min_i] == nums[min_i].length) {\n                    flag = false;\n                    break;\n                }\n                min_queue.offer(min_i);\n                max = Math.max(max, nums[min_i][next[min_i]]);\n            }\n        }\n        return new int[] { minx, miny};\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/sum-of-square-numbers", "source": [{"lang": "Java", "code": "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            int b = c - (int)(a * a);\n            if (binary_search(0, b, b))\n                return true;\n        }\n        return false;\n    }\n    public boolean binary_search(long s, long e, int n) {\n        if (s > e)\n            return false;\n        long mid = s + (e - s) / 2;\n        if (mid * mid == n)\n            return true;\n        if (mid * mid > n)\n            return binary_search(s, mid - 1, n);\n        return binary_search(mid + 1, e, n);\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            double b = Math.sqrt(c - a * a);\n            if (b == (int) b)\n                return true;\n        }\n        return false;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (int i = 2; i * i <= c; i++) {\n            int count = 0;\n            if (c % i == 0) {\n                while (c % i == 0) {\n                    count++;\n                    c /= i;\n                }\n                if (i % 4 == 3 && count % 2 != 0)\n                    return false;\n            }\n        }\n        return c % 4 != 3;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/exclusive-time-of-functions", "source": [{"lang": "Java", "code": "public class Solution {\n    public int[] exclusiveTime(int n, List < String > logs) {\n        Stack < Integer > stack = new Stack < > ();\n        int[] res = new int[n];\n        String[] s = logs.get(0).split(\":\");\n        stack.push(Integer.parseInt(s[0]));\n        int i = 1, prev = Integer.parseInt(s[2]);\n        while (i < logs.size()) {\n            s = logs.get(i).split(\":\");\n            if (s[1].equals(\"start\")) {\n                if (!stack.isEmpty())\n                    res[stack.peek()] += Integer.parseInt(s[2]) - prev;\n                stack.push(Integer.parseInt(s[0]));\n                prev = Integer.parseInt(s[2]);\n            } else {\n                res[stack.peek()] += Integer.parseInt(s[2]) - prev + 1;\n                stack.pop();\n                prev = Integer.parseInt(s[2]) + 1;\n            }\n            i++;\n        }\n        return res;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/average-of-levels-in-binary-tree", "source": [{"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List < Double > averageOfLevels(TreeNode root) {\n        List < Integer > count = new ArrayList < > ();\n        List < Double > res = new ArrayList < > ();\n        average(root, 0, res, count);\n        for (int i = 0; i < res.size(); i++)\n            res.set(i, res.get(i) / count.get(i));\n        return res;\n    }\n    public void average(TreeNode t, int i, List < Double > sum, List < Integer > count) {\n        if (t == null)\n            return;\n        if (i < sum.size()) {\n            sum.set(i, sum.get(i) + t.val);\n            count.set(i, count.get(i) + 1);\n        } else {\n            sum.add(1.0 * t.val);\n            count.add(1);\n        }\n        average(t.left, i + 1, sum, count);\n        average(t.right, i + 1, sum, count);\n    }\n}"}, {"lang": "Java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List < Double > averageOfLevels(TreeNode root) {\n        List < Double > res = new ArrayList < > ();\n        Queue < TreeNode > queue = new LinkedList < > ();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            long sum = 0, count = 0;\n            Queue < TreeNode > temp = new LinkedList < > ();\n            while (!queue.isEmpty()) {\n                TreeNode n = queue.remove();\n                sum += n.val;\n                count++;\n                if (n.left != null)\n                    temp.add(n.left);\n                if (n.right != null)\n                    temp.add(n.right);\n            }\n            queue = temp;\n            res.add(sum * 1.0 / count);\n        }\n        return res;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/shopping-offers", "source": [{"lang": "Java", "code": "public class Solution {\n    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        return shopping(price, special, needs);\n    }\n    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        int j = 0, res = dot(needs, price);\n        for (List < Integer > s: special) {\n            ArrayList < Integer > clone = new ArrayList < > (needs);\n            for (j = 0; j < needs.size(); j++) {\n                int diff = clone.get(j) - s.get(j);\n                if (diff < 0)\n                    break;\n                clone.set(j, diff);\n            }\n            if (j == needs.size())\n                res = Math.min(res, s.get(j) + shopping(price, special, clone));\n        }\n        return res;\n    }\n    public int dot(List < Integer > a, List < Integer > b) {\n        int sum = 0;\n        for (int i = 0; i < a.size(); i++) {\n            sum += a.get(i) * b.get(i);\n        }\n        return sum;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        Map < List < Integer > , Integer > map = new HashMap();\n        return shopping(price, special, needs, map);\n    }\n    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs, Map < List < Integer > , Integer > map) {\n        if (map.containsKey(needs))\n            return map.get(needs);\n        int j = 0, res = dot(needs, price);\n        for (List < Integer > s: special) {\n            ArrayList < Integer > clone = new ArrayList < > (needs);\n            for (j = 0; j < needs.size(); j++) {\n                int diff = clone.get(j) - s.get(j);\n                if (diff < 0)\n                    break;\n                clone.set(j, diff);\n            }\n            if (j == needs.size())\n                res = Math.min(res, s.get(j) + shopping(price, special, clone, map));\n        }\n        map.put(needs, res);\n        return res;\n    }\n    public int dot(List < Integer > a, List < Integer > b) {\n        int sum = 0;\n        for (int i = 0; i < a.size(); i++) {\n            sum += a.get(i) * b.get(i);\n        }\n        return sum;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/decode-ways-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/solve-the-equation", "source": [{"lang": "Java", "code": "public class Solution {\n    public String coeff(String x) {\n        if (x.length() > 1 && x.charAt(x.length() - 2) >= '0' && x.charAt(x.length() - 2) <= '9')\n            return x.replace(\"x\", \"\");\n        return x.replace(\"x\", \"1\");\n    }\n    public String solveEquation(String equation) {\n        String[] lr = equation.split(\"=\");\n        int lhs = 0, rhs = 0;\n        for (String x: breakIt(lr[0])) {\n            if (x.indexOf(\"x\") >= 0) {\n                lhs += Integer.parseInt(coeff(x));\n            } else\n                rhs -= Integer.parseInt(x);\n        }\n        for (String x: breakIt(lr[1])) {\n            if (x.indexOf(\"x\") >= 0)\n                lhs -= Integer.parseInt(coeff(x));\n            else\n                rhs += Integer.parseInt(x);\n        }\n        if (lhs == 0) {\n            if (rhs == 0)\n                return \"Infinite solutions\";\n            else\n                return \"No solution\";\n        }\n        return \"x=\" + rhs / lhs;\n    }\n    public List < String > breakIt(String s) {\n        List < String > res = new ArrayList < > ();\n        String r = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '+' || s.charAt(i) == '-') {\n                if (r.length() > 0)\n                    res.add(r);\n                r = \"\" + s.charAt(i);\n            } else\n                r += s.charAt(i);\n        }\n        res.add(r);\n        return res;\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public String coeff(String x) {\n        if (x.length() > 1 && x.charAt(x.length() - 2) >= '0' && x.charAt(x.length() - 2) <= '9')\n            return x.replace(\"x\", \"\");\n        return x.replace(\"x\", \"1\");\n    }\n    public String solveEquation(String equation) {\n        String[] lr = equation.split(\"=\");\n        int lhs = 0, rhs = 0;\n        for (String x: lr[0].split(\"(?=\\\\+)|(?=-)\")) {\n            if (x.indexOf(\"x\") >= 0) {\n\n                lhs += Integer.parseInt(coeff(x));\n            } else\n                rhs -= Integer.parseInt(x);\n        }\n        for (String x: lr[1].split(\"(?=\\\\+)|(?=-)\")) {\n            if (x.indexOf(\"x\") >= 0)\n                lhs -= Integer.parseInt(coeff(x));\n            else\n                rhs += Integer.parseInt(x);\n        }\n        if (lhs == 0) {\n            if (rhs == 0)\n                return \"Infinite solutions\";\n            else\n                return \"No solution\";\n        } else\n            return \"x=\" + rhs / lhs;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/design-circular-deque", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-average-subarray-i", "source": []}
{"url": "https://leetcode-cn.com/problems/set-mismatch", "source": [{"lang": "Java", "code": "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int dup = -1, missing = -1;\n        for (int i = 1; i <= nums.length; i++) {\n            int count = 0;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j] == i)\n                    count++;\n            }\n            if (count == 2)\n                dup = i;\n            else if (count == 0)\n                missing = i;\n        }\n        return new int[] {dup, missing};\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int dup = -1, missing = -1;;\n        for (int i = 1; i <= nums.length; i++) {\n            int count = 0;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j] == i)\n                    count++;\n            }\n            if (count == 2)\n                dup = i;\n            else if (count == 0)\n                missing = i;\n            if (dup > 0 && missing > 0)\n                break;\n        }\n        return new int[] {dup, missing};\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        Arrays.sort(nums);\n        int dup = -1, missing = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == nums[i - 1])\n                dup = nums[i];\n            else if (nums[i] > nums[i - 1] + 1)\n                missing = nums[i - 1] + 1;\n        }\n        return new int[] {dup, nums[nums.length - 1] != nums.length ? nums.length : missing};\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        Map < Integer, Integer > map = new HashMap();\n        int dup = -1, missing = 1;\n        for (int n: nums) {\n            map.put(n, map.getOrDefault(n, 0) + 1);\n        }\n        for (int i = 1; i <= nums.length; i++) {\n            if (map.containsKey(i)) {\n                if (map.get(i) == 2)\n                    dup = i;\n            } else\n                missing = i;\n        }\n        return new int[]{dup, missing};\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int[] arr = new int[nums.length + 1];\n        int dup = -1, missing = 1;\n        for (int i = 0; i < nums.length; i++) {\n            arr[nums[i]] += 1;\n        }\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] == 0)\n                missing = i;\n            else if (arr[i] == 2)\n                dup = i;\n        }\n        return new int[]{dup, missing};\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int dup = -1, missing = 1;\n        for (int n: nums) {\n            if (nums[Math.abs(n) - 1] < 0)\n                dup = Math.abs(n);\n            else\n                nums[Math.abs(n) - 1] *= -1;\n        }\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > 0)\n                missing = i + 1;\n        }\n        return new int[]{dup, missing};\n    }\n}"}, {"lang": "Java", "code": "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int xor = 0, xor0 = 0, xor1 = 0;\n        for (int n: nums)\n            xor ^= n;\n        for (int i = 1; i <= nums.length; i++)\n            xor ^= i;\n        int rightmostbit = xor & ~(xor - 1);\n        for (int n: nums) {\n            if ((n & rightmostbit) != 0)\n                xor1 ^= n;\n            else\n                xor0 ^= n;\n        }\n        for (int i = 1; i <= nums.length; i++) {\n            if ((i & rightmostbit) != 0)\n                xor1 ^= i;\n            else\n                xor0 ^= i;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == xor0)\n                return new int[]{xor0, xor1};\n        }\n        return new int[]{xor1, xor0};\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/maximum-length-of-pair-chain", "source": []}
{"url": "https://leetcode-cn.com/problems/palindromic-substrings", "source": [{"lang": "Python", "code": "class Solution(object):\n    def countSubstrings(self, S):\n        N = len(S)\n        ans = 0\n        for center in xrange(2*N - 1):\n            left = center / 2\n            right = left + center % 2\n            while left >= 0 and right < N and S[left] == S[right]:\n                ans += 1\n                left -= 1\n                right += 1\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int countSubstrings(String S) {\n        int N = S.length(), ans = 0;\n        for (int center = 0; center <= 2*N-1; ++center) {\n            int left = center / 2;\n            int right = left + center % 2;\n            while (left >= 0 && right < N && S.charAt(left) == S.charAt(right)) {\n                ans++;\n                left--;\n                right++;\n            }\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "def countSubstrings(self, S):\n    def manachers(S):\n        A = '@#' + '#'.join(S) + '#$'\n        Z = [0] * len(A)\n        center = right = 0\n        for i in xrange(1, len(A) - 1):\n            if i < right:\n                Z[i] = min(right - i, Z[2 * center - i])\n            while A[i + Z[i] + 1] == A[i - Z[i] - 1]:\n                Z[i] += 1\n            if i + Z[i] > right:\n                center, right = i, i + Z[i]\n        return Z\n\n    return sum((v+1)/2 for v in manachers(S))"}, {"lang": "Java", "code": "class Solution {\n    public int countSubstrings(String S) {\n        char[] A = new char[2 * S.length() + 3];\n        A[0] = '@';\n        A[1] = '#';\n        A[A.length - 1] = '$';\n        int t = 2;\n        for (char c: S.toCharArray()) {\n            A[t++] = c;\n            A[t++] = '#';\n        }\n\n        int[] Z = new int[A.length];\n        int center = 0, right = 0;\n        for (int i = 1; i < Z.length - 1; ++i) {\n            if (i < right)\n                Z[i] = Math.min(right - i, Z[2 * center - i]);\n            while (A[i + Z[i] + 1] == A[i - Z[i] - 1])\n                Z[i]++;\n            if (i + Z[i] > right) {\n                center = i;\n                right = i + Z[i];\n            }\n        }\n        int ans = 0;\n        for (int v: Z) ans += (v + 1) / 2;\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/replace-words", "source": [{"lang": "Python", "code": "def replaceWords(self, roots, sentence):\n    rootset = set(roots)\n\n    def replace(word):\n        for i in xrange(1, len(word)):\n            if word[:i] in rootset:\n                return word[:i]\n        return word\n\n    return \" \".join(map(replace, sentence.split()))"}, {"lang": "Java", "code": "class Solution {\n    public String replaceWords(List<String> roots, String sentence) {\n        Set<String> rootset = new HashSet();\n        for (String root: roots) rootset.add(root);\n\n        StringBuilder ans = new StringBuilder();\n        for (String word: sentence.split(\"\\\\s+\")) {\n            String prefix = \"\";\n            for (int i = 1; i <= word.length(); ++i) {\n                prefix = word.substring(0, i);\n                if (rootset.contains(prefix)) break;\n            }\n            if (ans.length() > 0) ans.append(\" \");\n            ans.append(prefix);\n        }\n        return ans.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def replaceWords(self, roots, sentence):\n        Trie = lambda: collections.defaultdict(Trie)\n        trie = Trie()\n        END = True\n\n        for root in roots:\n            reduce(dict.__getitem__, root, trie)[END] = root\n\n        def replace(word):\n            cur = trie\n            for letter in word:\n                if letter not in cur or END in cur: break\n                cur = cur[letter]\n            return cur.get(END, word)\n\n        return \" \".join(map(replace, sentence.split()))"}, {"lang": "Java", "code": "class Solution {\n    public String replaceWords(List<String> roots, String sentence) {\n        TrieNode trie = new TrieNode();\n        for (String root: roots) {\n            TrieNode cur = trie;\n            for (char letter: root.toCharArray()) {\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n            }\n            cur.word = root;\n        }\n\n        StringBuilder ans = new StringBuilder();\n\n        for (String word: sentence.split(\"\\\\s+\")) {\n            if (ans.length() > 0)\n                ans.append(\" \");\n\n            TrieNode cur = trie;\n            for (char letter: word.toCharArray()) {\n                if (cur.children[letter - 'a'] == null || cur.word != null)\n                    break;\n                cur = cur.children[letter - 'a'];\n            }\n            ans.append(cur.word != null ? cur.word : word);\n        }\n        return ans.toString();\n    }\n}\n\nclass TrieNode {\n    TrieNode[] children;\n    String word;\n    TrieNode() {\n        children = new TrieNode[26];\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/dota2-senate", "source": []}
{"url": "https://leetcode-cn.com/problems/2-keys-keyboard", "source": [{"lang": "Python", "code": "class Solution(object):\n    def minSteps(self, n):\n        ans = 0\n        d = 2\n        while n > 1:\n            while n % d == 0:\n                ans += d\n                n /= d\n            d += 1\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int minSteps(int n) {\n        int ans = 0, d = 2;\n        while (n > 1) {\n            while (n % d == 0) {\n                ans += d;\n                n /= d;\n            }\n            d++;\n        }\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/find-duplicate-subtrees", "source": []}
{"url": "https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-binary-tree", "source": [{"lang": "Java", "code": "public class Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        return construct(nums, 0, nums.length);\n    }\n    public TreeNode construct(int[] nums, int l, int r) {\n        if (l == r)\n            return null;\n        int max_i = max(nums, l, r);\n        TreeNode root = new TreeNode(nums[max_i]);\n        root.left = construct(nums, l, max_i);\n        root.right = construct(nums, max_i + 1, r);\n        return root;\n    }\n    public int max(int[] nums, int l, int r) {\n        int max_i = l;\n        for (int i = l; i < r; i++) {\n            if (nums[max_i] < nums[i])\n                max_i = i;\n        }\n        return max_i;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/print-binary-tree", "source": [{"lang": "Java", "code": "public class Solution {\n    public List<List<String>> printTree(TreeNode root) {\n        int height = getHeight(root);\n        String[][] res = new String[height][(1 << height) - 1];\n        for(String[] arr:res)\n            Arrays.fill(arr,\"\");\n        List<List<String>> ans = new ArrayList<>();\n        fill(res, root, 0, 0, res[0].length);\n        for(String[] arr:res)\n            ans.add(Arrays.asList(arr));\n        return ans;\n    }\n    public void fill(String[][] res, TreeNode root, int i, int l, int r) {\n        if (root == null)\n            return;\n        res[i][(l + r) / 2] = \"\" + root.val;\n        fill(res, root.left, i + 1, l, (l + r) / 2);\n        fill(res, root.right, i + 1, (l + r + 1) / 2, r);\n    }\n    public int getHeight(TreeNode root) {\n        if (root == null)\n            return 0;\n        return 1 + Math.max(getHeight(root.left), getHeight(root.right));\n    }\n}"}, {"lang": "Java", "code": "public class Solution\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    class Params {\n        Params(TreeNode n, int ii, int ll, int rr) {\n            root = n;\n            i = ii;\n            l = ll;\n            r = rr;\n        }\n        TreeNode root;\n        int i, l, r;\n    }\n    public List < List < String >> printTree(TreeNode root) {\n        int height = getHeight(root);\n        System.out.println(height);\n        String[][] res = new String[height][(1 << height) - 1];\n        for (String[] arr: res)\n            Arrays.fill(arr, \"\");\n        List < List < String >> ans = new ArrayList < > ();\n        fill(res, root, 0, 0, res[0].length);\n        for (String[] arr: res)\n            ans.add(Arrays.asList(arr));\n        return ans;\n    }\n    public void fill(String[][] res, TreeNode root, int i, int l, int r) {\n        Queue < Params > queue = new LinkedList();\n        queue.add(new Params(root, 0, 0, res[0].length));\n        while (!queue.isEmpty()) {\n            Params p = queue.remove();\n            res[p.i][(p.l + p.r) / 2] = \"\" + p.root.val;\n            if (p.root.left != null)\n                queue.add(new Params(p.root.left, p.i + 1, p.l, (p.l + p.r) / 2));\n            if (p.root.right != null)\n                queue.add(new Params(p.root.right, p.i + 1, (p.l + p.r + 1) / 2, p.r));\n        }\n    }\n    public int getHeight(TreeNode root) {\n        Queue < TreeNode > queue = new LinkedList();\n        queue.add(root);\n        int height = 0;\n        while (!queue.isEmpty()) {\n            height++;\n            Queue < TreeNode > temp = new LinkedList();\n            while (!queue.isEmpty()) {\n                TreeNode node = queue.remove();\n                if (node.left != null)\n                    temp.add(node.left);\n                if (node.right != null)\n                    temp.add(node.right);\n            }\n            queue = temp;\n        }\n        return height;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/robot-return-to-origin", "source": [{"lang": "Python", "code": "class Solution(object):\n    def judgeCircle(self, moves):\n        x = y = 0\n        for move in moves:\n            if move == 'U': y -= 1\n            elif move == 'D': y += 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0"}, {"lang": "Java", "code": "class Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for (char move: moves.toCharArray()) {\n            if (move == 'U') y--;\n            else if (move == 'D') y++;\n            else if (move == 'L') x--;\n            else if (move == 'R') x++;\n        }\n        return x == 0 && y == 0;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/find-k-closest-elements", "source": []}
{"url": "https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences", "source": [{"lang": "Python", "code": "class Solution(object):\n    def isPossible(self, nums):\n        prev, prev_count = None, 0\n        starts = collections.deque()\n        for t, grp in itertools.groupby(nums):\n            count = len(list(grp))\n            if prev is not None and t - prev != 1:\n                for _ in xrange(prev_count):\n                    if prev < starts.popleft() + 2:\n                        return False\n                prev, prev_count = None, 0\n\n            if prev is None or t - prev == 1:\n                if count > prev_count:\n                    for _ in xrange(count - prev_count):\n                        starts.append(t)\n                elif count < prev_count:\n                    for _ in xrange(prev_count - count):\n                        if t-1 < starts.popleft() + 2:\n                            return False\n\n            prev, prev_count = t, count\n\n        return all(nums[-1] >= x+2 for x in starts)"}, {"lang": "Java", "code": "class Solution {\n    public boolean isPossible(int[] nums) {\n        Integer prev = null;\n        int prevCount = 0;\n        Queue<Integer> starts = new LinkedList();\n        int anchor = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            int t = nums[i];\n            if (i == nums.length - 1 || nums[i+1] != t) {\n                int count = i - anchor + 1;\n                if (prev != null && t - prev != 1) {\n                    while (prevCount-- > 0)\n                        if (prev < starts.poll() + 2) return false;\n                    prev = null;\n                }\n\n                if (prev == null || t - prev == 1) {\n                    while (prevCount > count) {\n                        prevCount--;\n                        if (t-1 < starts.poll() + 2)\n                            return false;\n                    }\n                    while (prevCount++ < count)\n                        starts.add(t);\n                }\n                prev = t;\n                prevCount = count;\n                anchor = i+1;\n            }\n        }\n\n        while (prevCount-- > 0)\n            if (nums[nums.length - 1] < starts.poll() + 2)\n                return false;\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isPossible(self, nums):\n        count = collections.Counter(nums)\n        tails = collections.Counter()\n        for x in nums:\n            if count[x] == 0:\n                continue\n            elif tails[x] > 0:\n                tails[x] -= 1\n                tails[x+1] += 1\n            elif count[x+1] > 0 and count[x+2] > 0:\n                count[x+1] -= 1\n                count[x+2] -= 1\n                tails[x+3] += 1\n            else:\n                return False\n            count[x] -= 1\n        return True"}, {"lang": "Java", "code": "class Solution {\n    public boolean isPossible(int[] nums) {\n        Counter count = new Counter();\n        Counter tails = new Counter();\n        for (int x: nums) count.add(x, 1);\n\n        for (int x: nums) {\n            if (count.get(x) == 0) {\n                continue;\n            } else if (tails.get(x) > 0) {\n                tails.add(x, -1);\n                tails.add(x+1, 1);\n            } else if (count.get(x+1) > 0 && count.get(x+2) > 0) {\n                count.add(x+1, -1);\n                count.add(x+2, -1);\n                tails.add(x+3, 1);\n            } else {\n                return false;\n            }\n            count.add(x, -1);\n        }\n        return true;\n    }\n}\n\nclass Counter extends HashMap<Integer, Integer> {\n    public int get(int k) {\n        return containsKey(k) ? super.get(k) : 0;\n    }\n\n    public void add(int k, int v) {\n        put(k, get(k) + v);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/image-smoother", "source": [{"lang": "Python", "code": "class Solution(object):\n    def imageSmoother(self, M):\n        R, C = len(M), len(M[0])\n        ans = [[0] * C for _ in M]\n\n        for r in xrange(R):\n            for c in xrange(C):\n                count = 0\n                for nr in (r-1, r, r+1):\n                    for nc in (c-1, c, c+1):\n                        if 0 <= nr < R and 0 <= nc < C:\n                            ans[r][c] += M[nr][nc]\n                            count += 1\n                ans[r][c] /= count\n\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int[][] imageSmoother(int[][] M) {\n        int R = M.length, C = M[0].length;\n        int[][] ans = new int[R][C];\n\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                int count = 0;\n                for (int nr = r-1; nr <= r+1; ++nr)\n                    for (int nc = c-1; nc <= c+1; ++nc) {\n                        if (0 <= nr && nr < R && 0 <= nc && nc < C) {\n                            ans[r][c] += M[nr][nc];\n                            count++;\n                        }\n                    }\n                ans[r][c] /= count;\n            }\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/maximum-width-of-binary-tree", "source": [{"lang": "Python", "code": "def widthOfBinaryTree(self, root):\n    queue = [(root, 0, 0)]\n    cur_depth = left = ans = 0\n    for node, depth, pos in queue:\n        if node:\n            queue.append((node.left, depth+1, pos*2))\n            queue.append((node.right, depth+1, pos*2 + 1))\n            if cur_depth != depth:\n                cur_depth = depth\n                left = pos\n            ans = max(pos - left + 1, ans)\n\n    return ans"}, {"lang": "Java", "code": "class Solution {\n    public int widthOfBinaryTree(TreeNode root) {\n        Queue<AnnotatedNode> queue = new LinkedList();\n        queue.add(new AnnotatedNode(root, 0, 0));\n        int curDepth = 0, left = 0, ans = 0;\n        while (!queue.isEmpty()) {\n            AnnotatedNode a = queue.poll();\n            if (a.node != null) {\n                queue.add(new AnnotatedNode(a.node.left, a.depth + 1, a.pos * 2));\n                queue.add(new AnnotatedNode(a.node.right, a.depth + 1, a.pos * 2 + 1));\n                if (curDepth != a.depth) {\n                    curDepth = a.depth;\n                    left = a.pos;\n                }\n                ans = Math.max(ans, a.pos - left + 1);\n            }\n        }\n        return ans;\n    }\n}\n\nclass AnnotatedNode {\n    TreeNode node;\n    int depth, pos;\n    AnnotatedNode(TreeNode n, int d, int p) {\n        node = n;\n        depth = d;\n        pos = p;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def widthOfBinaryTree(self, root):\n        self.ans = 0\n        left = {}\n        def dfs(node, depth = 0, pos = 0):\n            if node:\n                left.setdefault(depth, pos)\n                self.ans = max(self.ans, pos - left[depth] + 1)\n                dfs(node.left, depth + 1, pos * 2)\n                dfs(node.right, depth + 1, pos * 2 + 1)\n\n        dfs(root)\n        return self.ans"}, {"lang": "Java", "code": "class Solution {\n    int ans;\n    Map<Integer, Integer> left;\n    public int widthOfBinaryTree(TreeNode root) {\n        ans = 0;\n        left = new HashMap();\n        dfs(root, 0, 0);\n        return ans;\n    }\n    public void dfs(TreeNode root, int depth, int pos) {\n        if (root == null) return;\n        left.computeIfAbsent(depth, x-> pos);\n        ans = Math.max(ans, pos - left.get(depth) + 1);\n        dfs(root.left, depth + 1, 2 * pos);\n        dfs(root.right, depth + 1, 2 * pos + 1);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/strange-printer", "source": [{"lang": "Python", "code": "def strangePrinter(self, S):\n    memo = {}\n    def dp(i, j):\n        if i > j: return 0\n        if (i, j) not in memo:\n            ans = dp(i+1, j) + 1\n            for k in xrange(i+1, j+1):\n                if S[k] == S[i]:\n                    ans = min(ans, dp(i, k-1) + dp(k+1, j))\n            memo[i, j] = ans\n        return memo[i, j]\n\n    return dp(0, len(S) - 1)"}, {"lang": "Java", "code": "class Solution {\n    int[][] memo;\n    public int strangePrinter(String s) {\n        int N = s.length();\n        memo = new int[N][N];\n        return dp(s, 0, N - 1);\n    }\n    public int dp(String s, int i, int j) {\n        if (i > j) return 0;\n        if (memo[i][j] == 0) {\n            int ans = dp(s, i+1, j) + 1;\n            for (int k = i+1; k <= j; ++k)\n                if (s.charAt(k) == s.charAt(i))\n                    ans = Math.min(ans, dp(s, i, k-1) + dp(s, k+1, j));\n            memo[i][j] = ans;\n        }\n        return memo[i][j];\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/non-decreasing-array", "source": []}
{"url": "https://leetcode-cn.com/problems/beautiful-arrangement-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table", "source": []}
{"url": "https://leetcode-cn.com/problems/trim-a-binary-search-tree", "source": [{"lang": "Java", "code": "class Solution {\n    public TreeNode trimBST(TreeNode root, int L, int R) {\n        if (root == null) return root;\n        if (root.val > R) return trimBST(root.left, L, R);\n        if (root.val < L) return trimBST(root.right, L, R);\n\n        root.left = trimBST(root.left, L, R);\n        root.right = trimBST(root.right, L, R);\n        return root;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def trimBST(self, root, L, R):\n        def trim(node):\n            if not node:\n                return None\n            elif node.val > R:\n                return trim(node.left)\n            elif node.val < L:\n                return trim(node.right)\n            else:\n                node.left = trim(node.left)\n                node.right = trim(node.right)\n                return node\n\n        return trim(root)"}]}
{"url": "https://leetcode-cn.com/problems/maximum-swap", "source": []}
{"url": "https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/bulb-switcher-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/cut-off-trees-for-golf-event", "source": [{"lang": "Python", "code": "class Solution(object):\n    def cutOffTree(self, forest):\n        trees = sorted((v, r, c) for r, row in enumerate(forest)\n                       for c, v in enumerate(row) if v > 1)\n        sr = sc = ans = 0\n        for _, tr, tc in trees:\n            d = dist(forest, sr, sc, tr, tc)\n            if d < 0: return -1\n            ans += d\n            sr, sc = tr, tc\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    int[] dr = {-1, 1, 0, 0};\n    int[] dc = {0, 0, -1, 1};\n\n    public int cutOffTree(List<List<Integer>> forest) {\n        List<int[]> trees = new ArrayList();\n        for (int r = 0; r < forest.size(); ++r) {\n            for (int c = 0; c < forest.get(0).size(); ++c) {\n                int v = forest.get(r).get(c);\n                if (v > 1) trees.add(new int[]{v, r, c});\n            }\n        }\n\n        Collections.sort(trees, (a, b) -> Integer.compare(a[0], b[0]));\n\n        int ans = 0, sr = 0, sc = 0;\n        for (int[] tree: trees) {\n            int d = dist(forest, sr, sc, tree[1], tree[2]);\n            if (d < 0) return -1;\n            ans += d;\n            sr = tree[1]; sc = tree[2];\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "def bfs(forest, sr, sc, tr, tc):\n    R, C = len(forest), len(forest[0])\n    queue = collections.deque([(sr, sc, 0)])\n    seen = {(sr, sc)}\n    while queue:\n        r, c, d = queue.popleft()\n        if r == tr and c == tc:\n            return d\n        for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n            if (0 <= nr < R and 0 <= nc < C and\n                    (nr, nc) not in seen and forest[nr][nc]):\n                seen.add((nr, nc))\n                queue.append((nr, nc, d+1))\n    return -1"}, {"lang": "Java", "code": "public int bfs(List<List<Integer>> forest, int sr, int sc, int tr, int tc) {\n    int R = forest.size(), C = forest.get(0).size();\n    Queue<int[]> queue = new LinkedList();\n    queue.add(new int[]{sr, sc, 0});\n    boolean[][] seen = new boolean[R][C];\n    seen[sr][sc] = true;\n    while (!queue.isEmpty()) {\n        int[] cur = queue.poll();\n        if (cur[0] == tr && cur[1] == tc) return cur[2];\n        for (int di = 0; di < 4; ++di) {\n            int r = cur[0] + dr[di];\n            int c = cur[1] + dc[di];\n            if (0 <= r && r < R && 0 <= c && c < C &&\n                    !seen[r][c] && forest.get(r).get(c) > 0) {\n                seen[r][c] = true;\n                queue.add(new int[]{r, c, cur[2]+1});\n            }\n        }\n    }\n    return -1;\n}"}, {"lang": "Python", "code": "def astar(forest, sr, sc, tr, tc):\n    R, C = len(forest), len(forest[0])\n    heap = [(0, 0, sr, sc)]\n    cost = {(sr, sc): 0}\n    while heap:\n        f, g, r, c = heapq.heappop(heap)\n        if r == tr and c == tc: return g\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < R and 0 <= nc < C and forest[nr][nc]:\n                ncost = g + 1 + abs(nr - tr) + abs(nc - tc)\n                if ncost < cost.get((nr, nc), 9999):\n                    cost[nr, nc] = ncost\n                    heapq.heappush(heap, (ncost, g+1, nr, nc))\n    return -1"}, {"lang": "Java", "code": "public int cutOffTree(List<List<Integer>> forest, int sr, int sc, int tr, int tc) {\n    int R = forest.size(), C = forest.get(0).size();\n    PriorityQueue<int[]> heap = new PriorityQueue<int[]>(\n        (a, b) -> Integer.compare(a[0], b[0]));\n    heap.offer(new int[]{0, 0, sr, sc});\n\n    HashMap<Integer, Integer> cost = new HashMap();\n    cost.put(sr * C + sc, 0);\n\n    while (!heap.isEmpty()) {\n        int[] cur = heap.poll();\n        int g = cur[1], r = cur[2], c = cur[3];\n        if (r == tr && c == tc) return g;\n        for (int di = 0; di < 4; ++di) {\n            int nr = r + dr[di], nc = c + dc[di];\n            if (0 <= nr && nr < R && 0 <= nc && nc < C && forest.get(nr).get(nc) > 0) {\n                int ncost = g + 1 + Math.abs(nr-tr) + Math.abs(nc-tr);\n                if (ncost < cost.getOrDefault(nr * C + nc, 9999)) {\n                    cost.put(nr * C + nc, ncost);\n                    heap.offer(new int[]{ncost, g+1, nr, nc});\n                }\n            }\n        }\n    }\n    return -1;\n}"}, {"lang": "Python", "code": "def hadlocks(forest, sr, sc, tr, tc):\n    R, C = len(forest), len(forest[0])\n    processed = set()\n    deque = collections.deque([(0, sr, sc)])\n    while deque:\n        detours, r, c = deque.popleft()\n        if (r, c) not in processed:\n            processed.add((r, c))\n            if r == tr and c == tc:\n                return abs(sr-tr) + abs(sc-tc) + 2*detours\n            for nr, nc, closer in ((r-1, c, r > tr), (r+1, c, r < tr),\n                                   (r, c-1, c > tc), (r, c+1, c < tc)):\n                if 0 <= nr < R and 0 <= nc < C and forest[nr][nc]:\n                    if closer:\n                        deque.appendleft((detours, nr, nc))\n                    else:\n                        deque.append((detours+1, nr, nc))\n    return -1"}, {"lang": "Java", "code": "public int hadlocks(List<List<Integer>> forest, int sr, int sc, int tr, int tc) {\n    int R = forest.size(), C = forest.get(0).size();\n    Set<Integer> processed = new HashSet();\n    Deque<int[]> deque = new ArrayDeque();\n    deque.offerFirst(new int[]{0, sr, sc});\n    while (!deque.isEmpty()) {\n        int[] cur = deque.pollFirst();\n        int detours = cur[0], r = cur[1], c = cur[2];\n        if (!processed.contains(r*C + c)) {\n            processed.add(r*C + c);\n            if (r == tr && c == tc) {\n                return Math.abs(sr-tr) + Math.abs(sc-tc) + 2 * detours;\n            }\n            for (int di = 0; di < 4; ++di) {\n                int nr = r + dr[di];\n                int nc = c + dc[di];\n                boolean closer;\n                if (di <= 1) closer = di == 0 ? r > tr : r < tr;\n                else closer = di == 2 ? c > tc : c < tc;\n                if (0 <= nr && nr < R && 0 <= nc && nc < C && forest.get(nr).get(nc) > 0) {\n                    if (closer) deque.offerFirst(new int[]{detours, nr, nc});\n                    else deque.offerLast(new int[]{detours+1, nr, nc});\n                }\n            }\n        }\n    }\n    return -1;\n}"}]}
{"url": "https://leetcode-cn.com/problems/implement-magic-dictionary", "source": [{"lang": "Python", "code": "class MagicDictionary(object):\n    def __init__(self):\n        self.buckets = collections.defaultdict(list)\n\n    def buildDict(self, words):\n        for word in words:\n            self.buckets[len(word)].append(word)\n\n    def search(self, word):\n        return any(sum(a!=b for a,b in zip(word, candidate)) == 1\n                   for candidate in self.buckets[len(word)])"}, {"lang": "Java", "code": "class MagicDictionary {\n    Map<Integer, ArrayList<String>> buckets;\n    public MagicDictionary() {\n        buckets = new HashMap();\n    }\n\n    public void buildDict(String[] words) {\n        for (String word: words) {\n            buckets.computeIfAbsent(word.length(), x -> new ArrayList()).add(word);\n        }\n    }\n\n    public boolean search(String word) {\n        if (!buckets.containsKey(word.length())) return false;\n        for (String candidate: buckets.get(word.length())) {\n            int mismatch = 0;\n            for (int i = 0; i < word.length(); ++i) {\n                if (word.charAt(i) != candidate.charAt(i)) {\n                    if (++mismatch > 1) break;\n                }\n            }\n            if (mismatch == 1) return true;\n        }\n        return false;\n    }\n}"}, {"lang": "Python", "code": "class MagicDictionary(object):\n    def _genneighbors(self, word):\n        for i in xrange(len(word)):\n            yield word[:i] + '*' + word[i+1:]\n\n    def buildDict(self, words):\n        self.words = set(words)\n        self.count = collections.Counter(nei for word in words\n                                        for nei in self._genneighbors(word))\n\n    def search(self, word):\n        return any(self.count[nei] > 1 or\n                   self.count[nei] == 1 and word not in self.words\n                   for nei in self._genneighbors(word))"}, {"lang": "Java", "code": "public class MagicDictionary {\n    Set<String> words;\n    Map<String, Integer> count;\n\n    public MagicDictionary() {\n        words = new HashSet();\n        count = new HashMap();\n    }\n\n    private ArrayList<String> generalizedNeighbors(String word) {\n        ArrayList<String> ans = new ArrayList();\n        char[] ca = word.toCharArray();\n        for (int i = 0; i < word.length(); ++i) {\n            char letter = ca[i];\n            ca[i] = '*';\n            String magic = new String(ca);\n            ans.add(magic);\n            ca[i] = letter;\n        }\n        return ans;\n    }\n\n    public void buildDict(String[] words) {\n        for (String word: words) {\n            this.words.add(word);\n            for (String nei: generalizedNeighbors(word)) {\n                count.put(nei, count.getOrDefault(nei, 0) + 1);\n            }\n        }\n    }\n\n    public boolean search(String word) {\n        for (String nei: generalizedNeighbors(word)) {\n            int c = count.getOrDefault(nei, 0);\n            if (c > 1 || c == 1 && !words.contains(word)) return true;\n        }\n        return false;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/map-sum-pairs", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-parenthesis-string", "source": []}
{"url": "https://leetcode-cn.com/problems/24-game", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-palindrome-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/baseball-game", "source": [{"lang": "Java", "code": "class Solution {\n    public int calPoints(String[] ops) {\n        Stack<Integer> stack = new Stack();\n\n        for(String op : ops) {\n            if (op.equals(\"+\")) {\n                int top = stack.pop();\n                int newtop = top + stack.peek();\n                stack.push(top);\n                stack.push(newtop);\n            } else if (op.equals(\"C\")) {\n                stack.pop();\n            } else if (op.equals(\"D\")) {\n                stack.push(2 * stack.peek());\n            } else {\n                stack.push(Integer.valueOf(op));\n            }\n        }\n\n        int ans = 0;\n        for(int score : stack) ans += score;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def calPoints(self, ops):\n        stack = []\n        for op in ops:\n            if op == '+':\n                stack.append(stack[-1] + stack[-2])\n            elif op == 'C':\n                stack.pop()\n            elif op == 'D':\n                stack.append(2 * stack[-1])\n            else:\n                stack.append(int(op))\n\n        return sum(stack)"}]}
{"url": "https://leetcode-cn.com/problems/redundant-connection", "source": []}
{"url": "https://leetcode-cn.com/problems/redundant-connection-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/repeated-string-match", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-univalue-path", "source": []}
{"url": "https://leetcode-cn.com/problems/knight-probability-in-chessboard", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays", "source": []}
{"url": "https://leetcode-cn.com/problems/employee-importance", "source": [{"lang": "Python", "code": "class Solution(object):\n    def getImportance(self, employees, query_id):\n        emap = {e.id: e for e in employees}\n        def dfs(eid):\n            employee = emap[eid]\n            return (employee.importance +\n                    sum(dfs(eid) for eid in employee.subordinates))\n        return dfs(query_id)"}, {"lang": "Java", "code": "class Solution {\n    Map<Integer, Employee> emap;\n    public int getImportance(List<Employee> employees, int queryid) {\n        emap = new HashMap();\n        for (Employee e: employees) emap.put(e.id, e);\n        return dfs(queryid);\n    }\n    public int dfs(int eid) {\n        Employee employee = emap.get(eid);\n        int ans = employee.importance;\n        for (Integer subid: employee.subordinates)\n            ans += dfs(subid);\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/stickers-to-spell-word", "source": []}
{"url": "https://leetcode-cn.com/problems/top-k-frequent-words", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-number-with-alternating-bits", "source": []}
{"url": "https://leetcode-cn.com/problems/max-area-of-island", "source": []}
{"url": "https://leetcode-cn.com/problems/count-binary-substrings", "source": [{"lang": "Python", "code": "class Solution(object):\n    def countBinarySubstrings(self, s):\n        groups = [1]\n        for i in xrange(1, len(s)):\n            if s[i-1] != s[i]:\n                groups.append(1)\n            else:\n                groups[-1] += 1\n\n        ans = 0\n        for i in xrange(1, len(groups)):\n            ans += min(groups[i-1], groups[i])\n        return ans"}, {"lang": "Java", "code": "class Solution(object):\n    def countBinarySubstrings(self, s):\n        groups = [len(list(v)) for _, v in itertools.groupby(s)]\n        return sum(min(a, b) for a, b in zip(groups, groups[1:]))"}, {"lang": "Python", "code": "class Solution {\n    public int countBinarySubstrings(String s) {\n        int[] groups = new int[s.length()];\n        int t = 0;\n        groups[0] = 1;\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i-1) != s.charAt(i)) {\n                groups[++t] = 1;\n            } else {\n                groups[t]++;\n            }\n        }\n\n        int ans = 0;\n        for (int i = 1; i <= t; i++) {\n            ans += Math.min(groups[i-1], groups[i]);\n        }\n        return ans;\n    }\n}"}, {"lang": "Java", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/degree-of-an-array", "source": [{"lang": "Python", "code": "class Solution(object):\n    def findShortestSubArray(self, nums):\n        left, right, count = {}, {}, {}\n        for i, x in enumerate(nums):\n            if x not in left: left[x] = i\n            right[x] = i\n            count[x] = count.get(x, 0) + 1\n\n        ans = len(nums)\n        degree = max(count.values())\n        for x in count:\n            if count[x] == degree:\n                ans = min(ans, right[x] - left[x] + 1)\n\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int findShortestSubArray(int[] nums) {\n        Map<Integer, Integer> left = new HashMap(),\n            right = new HashMap(), count = new HashMap();\n\n        for (int i = 0; i < nums.length; i++) {\n            int x = nums[i];\n            if (left.get(x) == null) left.put(x, i);\n            right.put(x, i);\n            count.put(x, count.getOrDefault(x, 0) + 1);\n        }\n\n        int ans = nums.length;\n        int degree = Collections.max(count.values());\n        for (int x: count.keySet()) {\n            if (count.get(x) == degree) {\n                ans = Math.min(ans, right.get(x) - left.get(x) + 1);\n            }\n        }\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets", "source": []}
{"url": "https://leetcode-cn.com/problems/falling-squares", "source": []}
{"url": "https://leetcode-cn.com/problems/search-in-a-binary-search-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/insert-into-a-binary-search-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/kth-largest-element-in-a-stream", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-search", "source": [{"lang": "Python", "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot = left + (right - left) // 2\n            if nums[pivot] == target:\n                return pivot\n            if target < nums[pivot]:\n                right = pivot - 1\n            else:\n                left = pivot + 1\n        return -1"}, {"lang": "Java", "code": "class Solution {\n  public int search(int[] nums, int target) {\n    int pivot, left = 0, right = nums.length - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (nums[pivot] == target) return pivot;\n      if (target < nums[pivot]) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    return -1;\n  }\n}"}, {"lang": "C++", "code": "class Solution {\n  public:\n  int search(vector<int>& nums, int target) {\n    int pivot, left = 0, right = nums.size() - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (nums[pivot] == target) return pivot;\n      if (target < nums[pivot]) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    return -1;\n  }\n};"}]}
{"url": "https://leetcode-cn.com/problems/design-hashset", "source": []}
{"url": "https://leetcode-cn.com/problems/design-hashmap", "source": []}
{"url": "https://leetcode-cn.com/problems/design-linked-list", "source": [{"lang": "Python", "code": "class MyLinkedList:\n    def __init__(self):\n        self.size = 0\n        self.head = ListNode(0)  # sentinel node as pseudo-head"}, {"lang": "Java", "code": "class MyLinkedList {\n  int size;\n  ListNode head;  // sentinel node as pseudo-head\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n  }\n}"}, {"lang": "Python", "code": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None"}, {"lang": "Java", "code": "public class ListNode {\n  int val;\n  ListNode next;\n  ListNode(int x) { val = x; }\n}"}, {"lang": "Python", "code": "to_add.next = pred.next\npred.next = to_add"}, {"lang": "Java", "code": "toAdd.next = pred.next;\npred.next = toAdd;"}, {"lang": "Python", "code": "# delete pred.next \npred.next = pred.next.next"}, {"lang": "Java", "code": "// delete pred.next \npred.next = pred.next.next;"}, {"lang": "Python", "code": "# index steps needed \n# to move from sentinel node to wanted index\nfor _ in range(index + 1):\n    curr = curr.next\nreturn curr.val"}, {"lang": "Java", "code": "// index steps needed \n// to move from sentinel node to wanted index\nfor(int i = 0; i < index + 1; ++i) curr = curr.next;\nreturn curr.val;"}, {"lang": "Python", "code": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass MyLinkedList:\n    def __init__(self):\n        self.size = 0\n        self.head = ListNode(0)  # sentinel node as pseudo-head\n        \n\n    def get(self, index: int) -> int:\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        \"\"\"\n        # if index is invalid\n        if index < 0 or index >= self.size:\n            return -1\n        \n        curr = self.head\n        # index steps needed \n        # to move from sentinel node to wanted index\n        for _ in range(index + 1):\n            curr = curr.next\n        return curr.val\n            \n\n    def addAtHead(self, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n        \"\"\"\n        self.addAtIndex(0, val)\n        \n\n    def addAtTail(self, val: int) -> None:\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        \"\"\"\n        self.addAtIndex(self.size, val)\n        \n\n    def addAtIndex(self, index: int, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n        \"\"\"\n        # If index is greater than the length, \n        # the node will not be inserted.\n        if index > self.size:\n            return\n        \n        # [so weird] If index is negative, \n        # the node will be inserted at the head of the list.\n        if index < 0:\n            index = 0\n        \n        self.size += 1\n        # find predecessor of the node to be added\n        pred = self.head\n        for _ in range(index):\n            pred = pred.next\n            \n        # node to be added\n        to_add = ListNode(val)\n        # insertion itself\n        to_add.next = pred.next\n        pred.next = to_add\n        \n\n    def deleteAtIndex(self, index: int) -> None:\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        \"\"\"\n        # if the index is invalid, do nothing\n        if index < 0 or index >= self.size:\n            return\n        \n        self.size -= 1\n        # find predecessor of the node to be deleted\n        pred = self.head\n        for _ in range(index):\n            pred = pred.next\n            \n        # delete pred.next \n        pred.next = pred.next.next"}, {"lang": "Java", "code": "public class ListNode {\n  int val;\n  ListNode next;\n  ListNode(int x) { val = x; }\n}\n\nclass MyLinkedList {\n  int size;\n  ListNode head;  // sentinel node as pseudo-head\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n  }\n\n  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n  public int get(int index) {\n    // if index is invalid\n    if (index < 0 || index >= size) return -1;\n\n    ListNode curr = head;\n    // index steps needed \n    // to move from sentinel node to wanted index\n    for(int i = 0; i < index + 1; ++i) curr = curr.next;\n    return curr.val;\n  }\n\n  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n  public void addAtHead(int val) {\n    addAtIndex(0, val);\n  }\n\n  /** Append a node of value val to the last element of the linked list. */\n  public void addAtTail(int val) {\n    addAtIndex(size, val);\n  }\n\n  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n  public void addAtIndex(int index, int val) {\n    // If index is greater than the length, \n    // the node will not be inserted.\n    if (index > size) return;\n\n    // [so weird] If index is negative, \n    // the node will be inserted at the head of the list.\n    if (index < 0) index = 0;\n\n    ++size;\n    // find predecessor of the node to be added\n    ListNode pred = head;\n    for(int i = 0; i < index; ++i) pred = pred.next;\n\n    // node to be added\n    ListNode toAdd = new ListNode(val);\n    // insertion itself\n    toAdd.next = pred.next;\n    pred.next = toAdd;\n  }\n\n  /** Delete the index-th node in the linked list, if the index is valid. */\n  public void deleteAtIndex(int index) {\n    // if the index is invalid, do nothing\n    if (index < 0 || index >= size) return;\n\n    size--;\n    // find predecessor of the node to be deleted\n    ListNode pred = head;\n    for(int i = 0; i < index; ++i) pred = pred.next;\n\n    // delete pred.next \n    pred.next = pred.next.next;\n  }\n}"}, {"lang": "Python", "code": "class MyLinkedList:\n    def __init__(self):\n        self.size = 0\n        # sentinel nodes as pseudo-head and pseudo-tail\n        self.head, self.tail = ListNode(0), ListNode(0) \n        self.head.next = self.tail\n        self.tail.prev = self.head"}, {"lang": "Java", "code": "class MyLinkedList {\n  int size;\n  // sentinel nodes as pseudo-head and pseudo-tail\n  ListNode head, tail;\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n    tail = new ListNode(0);\n    head.next = tail;\n    tail.prev = head;\n  }\n}"}, {"lang": "Python", "code": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.prev = None"}, {"lang": "Java", "code": "public class ListNode {\n  int val;\n  ListNode next;\n  ListNode prev;\n  ListNode(int x) { val = x; }\n}"}, {"lang": "Python", "code": "to_add.prev = pred\nto_add.next = succ\npred.next = to_add\nsucc.prev = to_add"}, {"lang": "Java", "code": "toAdd.prev = pred\ntoAdd.next = succ\npred.next = toAdd\nsucc.prev = toAdd"}, {"lang": "Python", "code": "pred.next = succ\nsucc.prev = pred"}, {"lang": "Java", "code": "pred.next = succ\nsucc.prev = pred"}, {"lang": "Python", "code": "# choose the fastest way: to move from the head\n# or to move from the tail\nif index + 1 < self.size - index:\n    curr = self.head\n    for _ in range(index + 1):\n        curr = curr.next\nelse:\n    curr = self.tail\n    for _ in range(self.size - index):\n        curr = curr.prev"}, {"lang": "Java", "code": "// choose the fastest way: to move from the head\n// or to move from the tail\nListNode curr = head;\nif (index + 1 < size - index)\n  for(int i = 0; i < index + 1; ++i) curr = curr.next;\nelse {\n  curr = tail;\n  for(int i = 0; i < size - index; ++i) curr = curr.prev;\n}"}, {"lang": "Python", "code": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next, self.prev = None, None\n\nclass MyLinkedList:\n    def __init__(self):\n        self.size = 0\n        # sentinel nodes as pseudo-head and pseudo-tail\n        self.head, self.tail = ListNode(0), ListNode(0) \n        self.head.next = self.tail\n        self.tail.prev = self.head\n        \n\n    def get(self, index: int) -> int:\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        \"\"\"\n        # if index is invalid\n        if index < 0 or index >= self.size:\n            return -1\n        \n        # choose the fastest way: to move from the head\n        # or to move from the tail\n        if index + 1 < self.size - index:\n            curr = self.head\n            for _ in range(index + 1):\n                curr = curr.next\n        else:\n            curr = self.tail\n            for _ in range(self.size - index):\n                curr = curr.prev\n                \n        return curr.val\n            \n\n    def addAtHead(self, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n        \"\"\"\n        pred, succ = self.head, self.head.next\n        \n        self.size += 1\n        to_add = ListNode(val)\n        to_add.prev = pred\n        to_add.next = succ\n        pred.next = to_add\n        succ.prev = to_add\n        \n\n    def addAtTail(self, val: int) -> None:\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        \"\"\"\n        succ, pred = self.tail, self.tail.prev\n        \n        self.size += 1\n        to_add = ListNode(val)\n        to_add.prev = pred\n        to_add.next = succ\n        pred.next = to_add\n        succ.prev = to_add\n        \n\n    def addAtIndex(self, index: int, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n        \"\"\"\n        # If index is greater than the length, \n        # the node will not be inserted.\n        if index > self.size:\n            return\n        \n        # [so weird] If index is negative, \n        # the node will be inserted at the head of the list.\n        if index < 0:\n            index = 0\n        \n        # find predecessor and successor of the node to be added\n        if index < self.size - index:\n            pred = self.head\n            for _ in range(index):\n                pred = pred.next\n            succ = pred.next\n        else:\n            succ = self.tail\n            for _ in range(self.size - index):\n                succ = succ.prev\n            pred = succ.prev\n        \n        # insertion itself\n        self.size += 1\n        to_add = ListNode(val)\n        to_add.prev = pred\n        to_add.next = succ\n        pred.next = to_add\n        succ.prev = to_add\n        \n\n    def deleteAtIndex(self, index: int) -> None:\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        \"\"\"\n        # if the index is invalid, do nothing\n        if index < 0 or index >= self.size:\n            return\n        \n        # find predecessor and successor of the node to be deleted\n        if index < self.size - index:\n            pred = self.head\n            for _ in range(index):\n                pred = pred.next\n            succ = pred.next.next\n        else:\n            succ = self.tail\n            for _ in range(self.size - index - 1):\n                succ = succ.prev\n            pred = succ.prev.prev\n            \n        # delete pred.next \n        self.size -= 1\n        pred.next = succ\n        succ.prev = pred"}, {"lang": "Java", "code": "public class ListNode {\n  int val;\n  ListNode next;\n  ListNode prev;\n  ListNode(int x) { val = x; }\n}\n\nclass MyLinkedList {\n  int size;\n  // sentinel nodes as pseudo-head and pseudo-tail\n  ListNode head, tail;\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n    tail = new ListNode(0);\n    head.next = tail;\n    tail.prev = head;\n  }\n\n  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n  public int get(int index) {\n    // if index is invalid\n    if (index < 0 || index >= size) return -1;\n\n    // choose the fastest way: to move from the head\n    // or to move from the tail\n    ListNode curr = head;\n    if (index + 1 < size - index)\n      for(int i = 0; i < index + 1; ++i) curr = curr.next;\n    else {\n      curr = tail;\n      for(int i = 0; i < size - index; ++i) curr = curr.prev;\n    }\n\n    return curr.val;\n  }\n\n  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n  public void addAtHead(int val) {\n    ListNode pred = head, succ = head.next;\n\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n  /** Append a node of value val to the last element of the linked list. */\n  public void addAtTail(int val) {\n    ListNode succ = tail, pred = tail.prev;\n\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n  public void addAtIndex(int index, int val) {\n    // If index is greater than the length, \n    // the node will not be inserted.\n    if (index > size) return;\n\n    // [so weird] If index is negative, \n    // the node will be inserted at the head of the list.\n    if (index < 0) index = 0;\n\n    // find predecessor and successor of the node to be added\n    ListNode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index; ++i) succ = succ.prev;\n      pred = succ.prev;\n    }\n\n    // insertion itself\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n  /** Delete the index-th node in the linked list, if the index is valid. */\n  public void deleteAtIndex(int index) {\n    // if the index is invalid, do nothing\n    if (index < 0 || index >= size) return;\n\n    // find predecessor and successor of the node to be deleted\n    ListNode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index - 1; ++i) succ = succ.prev;\n      pred = succ.prev.prev;\n    }\n\n    // delete pred.next \n    --size;\n    pred.next = succ;\n    succ.prev = pred;\n  }\n}"}]}
{"url": "https://leetcode-cn.com/problems/to-lower-case", "source": []}
{"url": "https://leetcode-cn.com/problems/random-pick-with-blacklist", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/subarray-product-less-than-k", "source": []}
{"url": "https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee", "source": []}
{"url": "https://leetcode-cn.com/problems/range-module", "source": []}
{"url": "https://leetcode-cn.com/problems/1-bit-and-2-bit-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray", "source": []}
{"url": "https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-word-in-dictionary", "source": []}
{"url": "https://leetcode-cn.com/problems/accounts-merge", "source": [{"lang": "Python", "code": "class Solution(object):\n    def accountsMerge(self, accounts):\n        em_to_name = {}\n        graph = collections.defaultdict(set)\n        for acc in accounts:\n            name = acc[0]\n            for email in acc[1:]:\n                graph[acc[1]].add(email)\n                graph[email].add(acc[1])\n                em_to_name[email] = name\n\n        seen = set()\n        ans = []\n        for email in graph:\n            if email not in seen:\n                seen.add(email)\n                stack = [email]\n                component = []\n                while stack:\n                    node = stack.pop()\n                    component.append(node)\n                    for nei in graph[node]:\n                        if nei not in seen:\n                            seen.add(nei)\n                            stack.append(nei)\n                ans.append([em_to_name[email]] + sorted(component))\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        Map<String, String> emailToName = new HashMap();\n        Map<String, ArrayList<String>> graph = new HashMap();\n        for (List<String> account: accounts) {\n            String name = \"\";\n            for (String email: account) {\n                if (name == \"\") {\n                    name = email;\n                    continue;\n                }\n                graph.computeIfAbsent(email, x-> new ArrayList<String>()).add(account.get(1));\n                graph.computeIfAbsent(account.get(1), x-> new ArrayList<String>()).add(email);\n                emailToName.put(email, name);\n            }\n        }\n\n        Set<String> seen = new HashSet();\n        List<List<String>> ans = new ArrayList();\n        for (String email: graph.keySet()) {\n            if (!seen.contains(email)) {\n                seen.add(email);\n                Stack<String> stack = new Stack();\n                stack.push(email);\n                List<String> component = new ArrayList();\n                while (!stack.empty()) {\n                    String node = stack.pop();\n                    component.add(node);\n                    for (String nei: graph.get(node)) {\n                        if (!seen.contains(nei)) {\n                            seen.add(nei);\n                            stack.push(nei);\n                        }\n                    }\n                }\n                Collections.sort(component);\n                component.add(0, emailToName.get(email));\n                ans.add(component);\n            }\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class DSU:\n    def __init__(self):\n        self.p = range(10001)\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    def union(self, x, y):\n        self.p[self.find(x)] = self.find(y)\n\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        dsu = DSU()\n        em_to_name = {}\n        em_to_id = {}\n        i = 0\n        for acc in accounts:\n            name = acc[0]\n            for email in acc[1:]:\n                em_to_name[email] = name\n                if email not in em_to_id:\n                    em_to_id[email] = i\n                    i += 1\n                dsu.union(em_to_id[acc[1]], em_to_id[email])\n\n        ans = collections.defaultdict(list)\n        for email in em_to_name:\n            ans[dsu.find(em_to_id[email])].append(email)\n\n        return [[em_to_name[v[0]]] + sorted(v) for v in ans.values()]"}, {"lang": "Java", "code": "class Solution {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        DSU dsu = new DSU();\n        Map<String, String> emailToName = new HashMap();\n        Map<String, Integer> emailToID = new HashMap();\n        int id = 0;\n        for (List<String> account: accounts) {\n            String name = \"\";\n            for (String email: account) {\n                if (name == \"\") {\n                    name = email;\n                    continue;\n                }\n                emailToName.put(email, name);\n                if (!emailToID.containsKey(email)) {\n                    emailToID.put(email, id++);\n                }\n                dsu.union(emailToID.get(account.get(1)), emailToID.get(email));\n            }\n        }\n\n        Map<Integer, List<String>> ans = new HashMap();\n        for (String email: emailToName.keySet()) {\n            int index = dsu.find(emailToID.get(email));\n            ans.computeIfAbsent(index, x-> new ArrayList()).add(email);\n        }\n        for (List<String> component: ans.values()) {\n            Collections.sort(component);\n            component.add(0, emailToName.get(component.get(0)));\n        }\n        return new ArrayList(ans.values());\n    }\n}\nclass DSU {\n    int[] parent;\n    public DSU() {\n        parent = new int[10001];\n        for (int i = 0; i <= 10000; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/remove-comments", "source": [{"lang": "Python", "code": "class Solution(object):\n    def removeComments(self, source):\n        in_block = False\n        ans = []\n        for line in source:\n            i = 0\n            if not in_block:\n                newline = []\n            while i < len(line):\n                if line[i:i+2] == '/*' and not in_block:\n                    in_block = True\n                    i += 1\n                elif line[i:i+2] == '*/' and in_block:\n                    in_block = False\n                    i += 1\n                elif not in_block and line[i:i+2] == '//':\n                    break\n                elif not in_block:\n                    newline.append(line[i])\n                i += 1\n            if newline and not in_block:\n                ans.append(\"\".join(newline))\n\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public List<String> removeComments(String[] source) {\n        boolean inBlock = false;\n        StringBuilder newline = new StringBuilder();\n        List<String> ans = new ArrayList();\n        for (String line: source) {\n            int i = 0;\n            char[] chars = line.toCharArray();\n            if (!inBlock) newline = new StringBuilder();\n            while (i < line.length()) {\n                if (!inBlock && i+1 < line.length() && chars[i] == '/' && chars[i+1] == '*') {\n                    inBlock = true;\n                    i++;\n                } else if (inBlock && i+1 < line.length() && chars[i] == '*' && chars[i+1] == '/') {\n                    inBlock = false;\n                    i++;\n                } else if (!inBlock && i+1 < line.length() && chars[i] == '/' && chars[i+1] == '/') {\n                    break;\n                } else if (!inBlock) {\n                    newline.append(chars[i]);\n                }\n                i++;\n            }\n            if (!inBlock && newline.length() > 0) {\n                ans.add(new String(newline));\n            }\n        }\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/find-pivot-index", "source": [{"lang": "Python", "code": "class Solution(object):\n    def pivotIndex(self, nums):\n        S = sum(nums)\n        leftsum = 0\n        for i, x in enumerate(nums):\n            if leftsum == (S - leftsum - x):\n                return i\n            leftsum += x\n        return -1"}, {"lang": "Java", "code": "class Solution {\n    public int pivotIndex(int[] nums) {\n        int sum = 0, leftsum = 0;\n        for (int x: nums) sum += x;\n        for (int i = 0; i < nums.length; ++i) {\n            if (leftsum == sum - leftsum - nums[i]) return i;\n            leftsum += nums[i];\n        }\n        return -1;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/split-linked-list-in-parts", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-atoms", "source": [{"lang": "Python", "code": "class Solution(object):\n    def countOfAtoms(self, formula):\n        def parse():\n            N = len(formula)\n            count = collections.Counter()\n            while (self.i < N and formula[self.i] != ')'):\n                if (formula[self.i] == '('):\n                    self.i += 1\n                    for name, v in parse().items():\n                        count[name] += v\n                else:\n                    i_start = self.i\n                    self.i += 1\n                    while (self.i < N and formula[self.i].islower()):\n                        self.i += 1\n                    name = formula[i_start: self.i]\n                    i_start = self.i\n                    while (self.i < N and formula[self.i].isdigit()):\n                        self.i += 1\n                    count[name] += int(formula[i_start: self.i] or 1)\n            self.i += 1\n            i_start = self.i\n            while (self.i < N and formula[self.i].isdigit()):\n                self.i += 1\n            if (i_start < self.i):\n                multiplicity = int(formula[i_start: self.i])\n                for name in count:\n                    count[name] *= multiplicity\n\n            return count\n\n        self.i = 0\n        ans = []\n        count = parse()\n        for name in sorted(count):\n            ans.append(name)\n            multiplicity = count[name]\n            if multiplicity > 1:\n                ans.append(str(multiplicity))\n        return \"\".join(ans)"}, {"lang": "Java", "code": "class Solution {\n    int i;\n    public String countOfAtoms(String formula) {\n        StringBuilder ans = new StringBuilder();\n        i = 0;\n        Map<String, Integer> count = parse(formula);\n        for (String name: count.keySet()) {\n            ans.append(name);\n            int multiplicity = count.get(name);\n            if (multiplicity > 1) ans.append(\"\" + multiplicity);\n        }\n        return new String(ans);\n    }\n\n    public Map<String, Integer> parse(String formula) {\n        int N = formula.length();\n        Map<String, Integer> count = new TreeMap();\n        while (i < N && formula.charAt(i) != ')') {\n            if (formula.charAt(i) == '(') {\n                i++;\n                for (Map.Entry<String, Integer> entry: parse(formula).entrySet()) {\n                    count.put(entry.getKey(), count.getOrDefault(entry.getKey(), 0) + entry.getValue());\n                }\n            } else {\n                int iStart = i++;\n                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                int multiplicity = iStart < i ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                count.put(name, count.getOrDefault(name, 0) + multiplicity);\n            }\n        }\n        int iStart = ++i;\n        while (i < N && Character.isDigit(formula.charAt(i))) i++;\n        if (iStart < i) {\n            int multiplicity = Integer.parseInt(formula.substring(iStart, i));\n            for (String key: count.keySet()) {\n                count.put(key, count.get(key) * multiplicity);\n            }\n        }\n        return count;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def countOfAtoms(self, formula):\n        N = len(formula)\n        stack = [collections.Counter()]\n        i = 0\n        while i < N:\n            if formula[i] == '(':\n                stack.append(collections.Counter())\n                i += 1\n            elif formula[i] == ')':\n                top = stack.pop()\n                i += 1\n                i_start = i\n                while i < N and formula[i].isdigit(): i += 1\n                multiplicity = int(formula[i_start: i] or 1)\n                for name, v in top.items():\n                    stack[-1][name] += v * multiplicity\n            else:\n                i_start = i\n                i += 1\n                while i < N and formula[i].islower(): i += 1\n                name = formula[i_start: i]\n                i_start = i\n                while i < N and formula[i].isdigit(): i += 1\n                multiplicity = int(formula[i_start: i] or 1)\n                stack[-1][name] += multiplicity\n\n        return \"\".join(name + (str(stack[-1][name]) if stack[-1][name] > 1 else '')\n                       for name in sorted(stack[-1]))"}, {"lang": "Java", "code": "class Solution {\n    public String countOfAtoms(String formula) {\n        int N = formula.length();\n        Stack<Map<String, Integer>> stack = new Stack();\n        stack.push(new TreeMap());\n\n        for (int i = 0; i < N;) {\n            if (formula.charAt(i) == '(') {\n                stack.push(new TreeMap());\n                i++;\n            } else if (formula.charAt(i) == ')') {\n                Map<String, Integer> top = stack.pop();\n                int iStart = ++i, multiplicity = 1;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                if (i > iStart) multiplicity = Integer.parseInt(formula.substring(iStart, i));\n                for (String c: top.keySet()) {\n                    int v = top.get(c);\n                    stack.peek().put(c, stack.peek().getOrDefault(c, 0) + v * multiplicity);\n                }\n            } else {\n                int iStart = i++;\n                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                int multiplicity = i > iStart ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            int multiplicity = stack.peek().get(name);\n            if (multiplicity > 1) ans.append(\"\" + multiplicity);\n        }\n        return new String(ans);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def countOfAtoms(self, formula):\n        parse = re.findall(r\"([A-Z][a-z]*)(\\d*)|(\\()|(\\))(\\d*)\", formula)\n        stack = [collections.Counter()]\n        for name, m1, left_open, right_open, m2 in parse:\n            if name:\n              stack[-1][name] += int(m1 or 1)\n            if left_open:\n              stack.append(collections.Counter())\n            if right_open:\n                top = stack.pop()\n                for k in top:\n                  stack[-1][k] += top[k] * int(m2 or 1)\n\n        return \"\".join(name + (str(stack[-1][name]) if stack[-1][name] > 1 else '')\n                       for name in sorted(stack[-1]))"}, {"lang": "Java", "code": "import java.util.regex.*;\n\nclass Solution {\n    public String countOfAtoms(String formula) {\n        Matcher matcher = Pattern.compile(\"([A-Z][a-z]*)(\\\\d*)|(\\\\()|(\\\\))(\\\\d*)\").matcher(formula);\n        Stack<Map<String, Integer>> stack = new Stack();\n        stack.push(new TreeMap());\n\n        while (matcher.find()) {\n            String match = matcher.group();\n            if (match.equals(\"(\")) {\n                stack.push(new TreeMap());\n            } else if (match.startsWith(\")\")) {\n                Map<String, Integer> top = stack.pop();\n                int multiplicity = match.length() > 1 ? Integer.parseInt(match.substring(1, match.length())) : 1;\n                for (String name: top.keySet()) {\n                    stack.peek().put(name, stack.peek().getOrDefault(name, 0) + top.get(name) * multiplicity);\n                }\n            } else {\n                int i = 1;\n                while (i < match.length() && Character.isLowerCase(match.charAt(i))) {\n                    i++;\n                }\n                String name = match.substring(0, i);\n                int multiplicity = i < match.length() ? Integer.parseInt(match.substring(i, match.length())) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            final int count = stack.peek().get(name);\n            if (count > 1) ans.append(String.valueOf(count));\n        }\n        return ans.toString();\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/self-dividing-numbers", "source": [{"lang": "Python", "code": "class Solution(object):\n    def selfDividingNumbers(self, left, right):\n        def self_dividing(n):\n            for d in str(n):\n                if d == '0' or n % int(d) > 0:\n                    return False\n            return True\n        \"\"\"\n        Alternate implementation of self_dividing:\n        def self_dividing(n):\n            x = n\n            while x > 0:\n                x, d = divmod(x, 10)\n                if d == 0 or n % d > 0:\n                    return False\n            return True\n        \"\"\"\n        ans = []\n        for n in range(left, right + 1):\n            if self_dividing(n):\n                ans.append(n)\n        return ans #Equals filter(self_dividing, range(left, right+1))"}, {"lang": "Java", "code": "class Solution {\n    public List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> ans = new ArrayList();\n        for (int n = left; n <= right; ++n) {\n            if (selfDividing(n)) ans.add(n);\n        }\n        return ans;\n    }\n    public boolean selfDividing(int n) {\n        for (char c: String.valueOf(n).toCharArray()) {\n            if (c == '0' || (n % (c - '0') > 0))\n                return false;\n        }\n        return true;\n    }\n    /*\n    Alternate implementation of selfDividing:\n    public boolean selfDividing(int n) {\n        int x = n;\n        while (x > 0) {\n            int d = x % 10;\n            x /= 10;\n            if (d == 0 || (n % d) > 0) return false;\n        }\n        return true;\n    */\n}"}]}
{"url": "https://leetcode-cn.com/problems/my-calendar-i", "source": []}
{"url": "https://leetcode-cn.com/problems/count-different-palindromic-subsequences", "source": [{"lang": "Java", "code": "class Solution {\npublic:\n  int countPalindromicSubsequences(string S) {\n    int n = S.size();\n    int mod = 1000000007;\n    auto dp_ptr = new vector<vector<vector<int>>>(4, vector<vector<int>>(n, vector<int>(n)));\n    auto& dp = *dp_ptr;\n\n    for (int i = n-1; i >= 0; --i) {\n      for (int j = i; j < n; ++j) {\n        for (int k = 0; k < 4; ++k) {\n          char c = 'a' + k;\n          if (j == i) {\n            if (S[i] == c) dp[k][i][j] = 1;\n            else dp[k][i][j] = 0;\n          } else { // j > i\n            if (S[i] != c) dp[k][i][j] = dp[k][i+1][j];\n            else if (S[j] != c) dp[k][i][j] = dp[k][i][j-1];\n            else { // S[i] == S[j] == c\n              if (j == i+1) dp[k][i][j] = 2; // \"aa\" : {\"a\", \"aa\"}\n              else { // length is > 2\n                dp[k][i][j] = 2;\n                for (int m = 0; m < 4; ++m) { // count each one within subwindows [i+1][j-1]\n                  dp[k][i][j] += dp[m][i+1][j-1];\n                  dp[k][i][j] %= mod;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    int ans = 0;\n    for (int k = 0; k < 4; ++k) {\n      ans += dp[k][0][n-1];\n      ans %= mod;\n    }\n\n    return ans;\n  }\n};"}, {"lang": "Java", "code": "class Solution {\n  public int countPalindromicSubsequences(String S) {\n    int n = S.length();\n    int mod = 1000000007;\n    int[][][] dp = new int[4][n][n];\n\n    for (int i = n-1; i >= 0; --i) {\n      for (int j = i; j < n; ++j) {\n        for (int k = 0; k < 4; ++k) {\n          char c = (char) ('a' + k);\n          if (j == i) {\n            if (S.charAt(i) == c) dp[k][i][j] = 1;\n            else dp[k][i][j] = 0;\n          } else { // j > i\n            if (S.charAt(i) != c) dp[k][i][j] = dp[k][i+1][j];\n            else if (S.charAt(j) != c) dp[k][i][j] = dp[k][i][j-1];\n            else { // S[i] == S[j] == c\n              if (j == i+1) dp[k][i][j] = 2; // \"aa\" : {\"a\", \"aa\"}\n              else { // length is > 2\n                dp[k][i][j] = 2;\n                for (int m = 0; m < 4; ++m) { // count each one within subwindows [i+1][j-1]\n                  dp[k][i][j] += dp[m][i+1][j-1];\n                  dp[k][i][j] %= mod;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    int ans = 0;\n    for (int k = 0; k < 4; ++k) {\n      ans += dp[k][0][n-1];\n      ans %= mod;\n    }\n\n    return ans;\n  }\n}"}, {"lang": "Python", "code": "class Solution:\n  def countPalindromicSubsequences(self, S):\n    n = len(S)\n    mod = 1000000007\n    dp = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(4)]\n\n    for i in range(n-1, -1, -1):\n      for j in range(i, n):\n        for k in range(4):\n          c = chr(ord('a') + k)\n          if j == i:\n            if S[i] == c: dp[k][i][j] = 1\n            else: dp[k][i][j] = 0\n          else: # j > i\n            if S[i] != c: dp[k][i][j] = dp[k][i+1][j]\n            elif S[j] != c: dp[k][i][j] = dp[k][i][j-1]\n            else: # S[i] == S[j] == c\n              if j == i+1: dp[k][i][j] = 2 # \"aa\" : {\"a\", \"aa\"}\n              else: # length is > 2\n                dp[k][i][j] = 2\n                for m in range(4): # count each one within subwindows [i+1][j-1]\n                  dp[k][i][j] += dp[m][i+1][j-1]\n                  dp[k][i][j] %= mod\n\n    ans = 0\n    for k in range(4):\n      ans += dp[k][0][n-1]\n      ans %= mod\n\n    return ans"}, {"lang": "Python", "code": "class Solution(object):\n    def countPalindromicSubsequences(self, S):\n        N = len(S)\n        A = [ord(c) - ord('a') for c in S]\n        prv = [None] * N\n        nxt = [None] * N\n\n        last = [None] * 4\n        for i in xrange(N):\n            last[A[i]] = i\n            prv[i] = tuple(last)\n\n        last = [None] * 4\n        for i in xrange(N-1, -1, -1):\n            last[A[i]] = i\n            nxt[i] = tuple(last)\n\n        MOD = 10**9 + 7\n        memo = [[None] * N for _ in xrange(N)]\n        def dp(i, j):\n            if memo[i][j] is not None:\n                return memo[i][j]\n            ans = 1\n            if i <= j:\n                for x in xrange(4):\n                    i0 = nxt[i][x]\n                    j0 = prv[j][x]\n                    if i <= i0 <= j:\n                        ans += 1\n                    if None < i0 < j0:\n                        ans += dp(i0+1, j0-1)\n            ans %= MOD\n            memo[i][j] = ans\n            return ans\n\n        return dp(0, N-1) - 1"}, {"lang": "Java", "code": "class Solution {\n    int[][] memo, prv, nxt;\n    byte[] A;\n    int MOD = 1_000_000_007;\n\n    public int countPalindromicSubsequences(String S) {\n        int N = S.length();\n        prv = new int[N][4];\n        nxt = new int[N][4];\n        memo = new int[N][N];\n        for (int[] row: prv) Arrays.fill(row, -1);\n        for (int[] row: nxt) Arrays.fill(row, -1);\n\n        A = new byte[N];\n        int ix = 0;\n        for (char c: S.toCharArray()) {\n            A[ix++] = (byte) (c - 'a');\n        }\n\n        int[] last = new int[4];\n        Arrays.fill(last, -1);\n        for (int i = 0; i < N; ++i) {\n            last[A[i]] = i;\n            for (int k = 0; k < 4; ++k)\n                prv[i][k] = last[k];\n        }\n\n        Arrays.fill(last, -1);\n        for (int i = N-1; i >= 0; --i) {\n            last[A[i]] = i;\n            for (int k = 0; k < 4; ++k)\n                nxt[i][k] = last[k];\n        }\n\n        return dp(0, N-1) - 1;\n    }\n\n    public int dp(int i, int j) {\n        if (memo[i][j] > 0) return memo[i][j];\n        int ans = 1;\n        if (i <= j) {\n            for (int k = 0; k < 4; ++k) {\n                int i0 = nxt[i][k];\n                int j0 = prv[j][k];\n                if (i <= i0 && i0 <= j) ans++;\n                if (-1 < i0 && i0 < j0) ans += dp(i0 + 1, j0 - 1);\n                if (ans >= MOD) ans -= MOD;\n            }\n        }\n        memo[i][j] = ans;\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/my-calendar-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/my-calendar-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/flood-fill", "source": [{"lang": "Python", "code": "class Solution(object):\n    def floodFill(self, image, sr, sc, newColor):\n        R, C = len(image), len(image[0])\n        color = image[sr][sc]\n        if color == newColor: return image\n        def dfs(r, c):\n            if image[r][c] == color:\n                image[r][c] = newColor\n                if r >= 1: dfs(r-1, c)\n                if r+1 < R: dfs(r+1, c)\n                if c >= 1: dfs(r, c-1)\n                if c+1 < C: dfs(r, c+1)\n\n        dfs(sr, sc)\n        return image"}, {"lang": "Java", "code": "class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        int color = image[sr][sc];\n        if (color != newColor) dfs(image, sr, sc, color, newColor);\n        return image;\n    }\n    public void dfs(int[][] image, int r, int c, int color, int newColor) {\n        if (image[r][c] == color) {\n            image[r][c] = newColor;\n            if (r >= 1) dfs(image, r-1, c, color, newColor);\n            if (c >= 1) dfs(image, r, c-1, color, newColor);\n            if (r+1 < image.length) dfs(image, r+1, c, color, newColor);\n            if (c+1 < image[0].length) dfs(image, r, c+1, color, newColor);\n        }\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/asteroid-collision", "source": [{"lang": "Java", "code": "class Solution(object):\n    def asteroidCollision(self, asteroids):\n        ans = []\n        for new in asteroids:\n            while ans and new < 0 < ans[-1]:\n                if ans[-1] < -new:\n                    ans.pop()\n                    continue\n                elif ans[-1] == -new:\n                    ans.pop()\n                break\n            else:\n                ans.append(new)\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/parse-lisp-expression", "source": []}
{"url": "https://leetcode-cn.com/problems/monotone-increasing-digits", "source": [{"lang": "Python", "code": "class Solution(object):\n    def monotoneIncreasingDigits(self, N):\n        digits = []\n        A = map(int, str(N))\n        for i in xrange(len(A)):\n            for d in xrange(1, 10):\n                if digits + [d] * (len(A)-i) > A:\n                    digits.append(d-1)\n                    break\n            else:\n                digits.append(9)\n\n        return int(\"\".join(map(str, digits)))"}, {"lang": "Java", "code": "class Solution {\n    public int monotoneIncreasingDigits(int N) {\n        String S = String.valueOf(N);\n        String ans = \"\";\n        search: for (int i = 0; i < S.length(); ++i) {\n            for (char d = '1'; d <= '9'; ++d) {\n                if (S.compareTo(ans + repeat(d, S.length() - i)) < 0) {\n                    ans += (char) (d - 1);\n                    continue search;\n                }\n            }\n            ans += '9';\n        }\n        return Integer.parseInt(ans);\n    }\n\n    public String repeat(char c, int count) {\n        StringBuilder sb = new StringBuilder(count);\n        for (int i = 0; i < count; ++i) sb.append(c);\n        return sb.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def monotoneIncreasingDigits(self, N):\n        S = list(str(N))\n        i = 1\n        while i < len(S) and S[i-1] <= S[i]:\n            i += 1\n        while 0 < i < len(S) and S[i-1] > S[i]:\n            S[i-1] = str(int(S[i-1]) - 1)\n            i -= 1\n        S[i+1:] = '9' * (len(S) - i-1)\n        return int(\"\".join(S))"}, {"lang": "Java", "code": "class Solution {\n    public int monotoneIncreasingDigits(int N) {\n        char[] S = String.valueOf(N).toCharArray();\n        int i = 1;\n        while (i < S.length && S[i-1] <= S[i]) i++;\n        while (0 < i && i < S.length && S[i-1] > S[i]) S[--i]--;\n        for (int j = i+1; j < S.length; ++j) S[j] = '9';\n\n        return Integer.parseInt(String.valueOf(S));\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/daily-temperatures", "source": [{"lang": "Python", "code": "class Solution(object):\n    def dailyTemperatures(self, T):\n        nxt = [float('inf')] * 102\n        ans = [0] * len(T)\n        for i in xrange(len(T) - 1, -1, -1):\n            #Use 102 so min(nxt[t]) has a default value\n            warmer_index = min(nxt[t] for t in xrange(T[i]+1, 102))\n            if warmer_index < float('inf'):\n                ans[i] = warmer_index - i\n            nxt[T[i]] = i\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int[] ans = new int[T.length];\n        int[] next = new int[101];\n        Arrays.fill(next, Integer.MAX_VALUE);\n        for (int i = T.length - 1; i >= 0; --i) {\n            int warmer_index = Integer.MAX_VALUE;\n            for (int t = T[i] + 1; t <= 100; ++t) {\n                if (next[t] < warmer_index)\n                    warmer_index = next[t];\n            }\n            if (warmer_index < Integer.MAX_VALUE)\n                ans[i] = warmer_index - i;\n            next[T[i]] = i;\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def dailyTemperatures(self, T):\n        ans = [0] * len(T)\n        stack = [] #indexes from hottest to coldest\n        for i in xrange(len(T) - 1, -1, -1):\n            while stack and T[i] >= T[stack[-1]]:\n                stack.pop()\n            if stack:\n                ans[i] = stack[-1] - i\n            stack.append(i)\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int[] ans = new int[T.length];\n        Stack<Integer> stack = new Stack();\n        for (int i = T.length - 1; i >= 0; --i) {\n            while (!stack.isEmpty() && T[i] >= T[stack.peek()]) stack.pop();\n            ans[i] = stack.isEmpty() ? 0 : stack.peek() - i;\n            stack.push(i);\n        }\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/delete-and-earn", "source": [{"lang": "Python", "code": "class Solution(object):\n    def deleteAndEarn(self, nums):\n        count = collections.Counter(nums)\n        prev = None\n        avoid = using = 0\n        for k in sorted(count):\n            if k - 1 != prev:\n                avoid, using = max(avoid, using), k * count[k] + max(avoid, using)\n            else:\n                avoid, using = max(avoid, using), k * count[k] + avoid\n            prev = k\n        return max(avoid, using)"}, {"lang": "Java", "code": "class Solution {\n    public int deleteAndEarn(int[] nums) {\n        int[] count = new int[10001];\n        for (int x: nums) count[x]++;\n        int avoid = 0, using = 0, prev = -1;\n\n        for (int k = 0; k <= 10000; ++k) if (count[k] > 0) {\n            int m = Math.max(avoid, using);\n            if (k - 1 != prev) {\n                using = k * count[k] + m;\n                avoid = m;\n            } else {\n                using = k * count[k] + avoid;\n                avoid = m;\n            }\n            prev = k;\n        }\n        return Math.max(avoid, using);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/cherry-pickup", "source": [{"lang": "Python", "code": "11100\n00101\n10100\n00100\n00111"}, {"lang": "Java", "code": ""}, {"lang": "Python", "code": "class Solution {\n    public int cherryPickup(int[][] grid) {\n        int ans = 0;\n        int[][] path = bestPath(grid);\n        if (path == null) return 0;\n        for (int[] step: path) {\n            ans += grid[step[0]][step[1]];\n            grid[step[0]][step[1]] = 0;\n        }\n\n        for (int[] step: bestPath(grid))\n            ans += grid[step[0]][step[1]];\n\n        return ans;\n    }\n\n    public int[][] bestPath(int[][] grid) {\n        int N = grid.length;\n        int[][] dp = new int[N][N];\n        for (int[] row: dp) Arrays.fill(row, Integer.MIN_VALUE);\n        dp[N-1][N-1] = grid[N-1][N-1];\n        for (int i = N-1; i >= 0; --i) {\n            for (int j = N-1; j >= 0; --j) {\n                if (grid[i][j] >= 0 && (i != N-1 || j != N-1)) {\n                    dp[i][j] = Math.max(i+1 < N ? dp[i+1][j] : Integer.MIN_VALUE,\n                                        j+1 < N ? dp[i][j+1] : Integer.MIN_VALUE);\n                    dp[i][j] += grid[i][j];\n                }\n            }\n        }\n        if (dp[0][0] < 0) return null;\n        int[][] ans = new int[2*N - 1][2];\n        int i = 0, j = 0, t = 0;\n        while (i != N-1 || j != N-1) {\n            if (j+1 == N || i+1 < N && dp[i+1][j] >= dp[i][j+1]) i++;\n            else j++;\n\n            ans[t][0] = i;\n            ans[t][1] = j;\n            t++;\n        }\n        return ans;\n    }\n}"}, {"lang": "Java", "code": ""}, {"lang": "Python", "code": "class Solution {\n    int[][][] memo;\n    int[][] grid;\n    int N;\n    public int cherryPickup(int[][] grid) {\n        this.grid = grid;\n        N = grid.length;\n        memo = new int[N][N][N];\n        for (int[][] layer: memo)\n            for (int[] row: layer)\n                Arrays.fill(row, Integer.MIN_VALUE);\n        return Math.max(0, dp(0, 0, 0));\n    }\n    public int dp(int r1, int c1, int c2) {\n        int r2 = r1 + c1 - c2;\n        if (N == r1 || N == r2 || N == c1 || N == c2 ||\n                grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n            return -999999;        \n        } else if (r1 == N-1 && c1 == N-1) {\n            return grid[r1][c1];\n        } else if (memo[r1][c1][c2] != Integer.MIN_VALUE) {\n            return memo[r1][c1][c2];\n        } else {\n            int ans = grid[r1][c1];\n            if (c1 != c2) ans += grid[r2][c2];\n            ans += Math.max(Math.max(dp(r1, c1+1, c2+1), dp(r1+1, c1, c2+1)),\n                            Math.max(dp(r1, c1+1, c2), dp(r1+1, c1, c2)));\n            memo[r1][c1][c2] = ans;\n            return ans;\n        }\n    }\n}"}, {"lang": "Java", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/network-delay-time", "source": [{"lang": "Python", "code": "class Solution(object):\n    def networkDelayTime(self, times, N, K):\n        graph = collections.defaultdict(list)\n        for u, v, w in times:\n            graph[u].append((w, v))\n\n        dist = {node: float('inf') for node in xrange(1, N+1)}\n\n        def dfs(node, elapsed):\n            if elapsed >= dist[node]: return\n            dist[node] = elapsed\n            for time, nei in sorted(graph[node]):\n                dfs(nei, elapsed + time)\n\n        dfs(K, 0)\n        ans = max(dist.values())\n        return ans if ans < float('inf') else -1"}, {"lang": "Java", "code": "class Solution {\n    Map<Integer, Integer> dist;\n    public int networkDelayTime(int[][] times, int N, int K) {\n        Map<Integer, List<int[]>> graph = new HashMap();\n        for (int[] edge: times) {\n            if (!graph.containsKey(edge[0]))\n                graph.put(edge[0], new ArrayList<int[]>());\n            graph.get(edge[0]).add(new int[]{edge[2], edge[1]});\n        }\n        for (int node: graph.keySet()) {\n            Collections.sort(graph.get(node), (a, b) -> a[0] - b[0]);\n        }\n        dist = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            dist.put(node, Integer.MAX_VALUE);\n\n        dfs(graph, K, 0);\n        int ans = 0;\n        for (int cand: dist.values()) {\n            if (cand == Integer.MAX_VALUE) return -1;\n            ans = Math.max(ans, cand);\n        }\n        return ans;\n    }\n\n    public void dfs(Map<Integer, List<int[]>> graph, int node, int elapsed) {\n        if (elapsed >= dist.get(node)) return;\n        dist.put(node, elapsed);\n        if (graph.containsKey(node))\n            for (int[] info: graph.get(node))\n                dfs(graph, info[1], elapsed + info[0]);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def networkDelayTime(self, times, N, K):\n        graph = collections.defaultdict(list)\n        for u, v, w in times:\n            graph[u].append((v, w))\n\n        dist = {node: float('inf') for node in xrange(1, N+1)}\n        seen = [False] * (N+1)\n        dist[K] = 0\n\n        while True:\n            cand_node = -1\n            cand_dist = float('inf')\n            for i in xrange(1, N+1):\n                if not seen[i] and dist[i] < cand_dist:\n                    cand_dist = dist[i]\n                    cand_node = i\n\n            if cand_node < 0: break\n            seen[cand_node] = True\n            for nei, d in graph[cand_node]:\n                dist[nei] = min(dist[nei], dist[cand_node] + d)\n\n        ans = max(dist.values())\n        return ans if ans < float('inf') else -1"}, {"lang": "Java", "code": "class Solution {\n    Map<Integer, Integer> dist;\n    public int networkDelayTime(int[][] times, int N, int K) {\n        Map<Integer, List<int[]>> graph = new HashMap();\n        for (int[] edge: times) {\n            if (!graph.containsKey(edge[0]))\n                graph.put(edge[0], new ArrayList<int[]>());\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n        }\n        dist = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            dist.put(node, Integer.MAX_VALUE);\n\n        dist.put(K, 0);\n        boolean[] seen = new boolean[N+1];\n\n        while (true) {\n            int candNode = -1;\n            int candDist = Integer.MAX_VALUE;\n            for (int i = 1; i <= N; ++i) {\n                if (!seen[i] && dist.get(i) < candDist) {\n                    candDist = dist.get(i);\n                    candNode = i;\n                }\n            }\n\n            if (candNode < 0) break;\n            seen[candNode] = true;\n            if (graph.containsKey(candNode))\n                for (int[] info: graph.get(candNode))\n                    dist.put(info[0],\n                             Math.min(dist.get(info[0]), dist.get(candNode) + info[1]));\n        }\n\n        int ans = 0;\n        for (int cand: dist.values()) {\n            if (cand == Integer.MAX_VALUE) return -1;\n            ans = Math.max(ans, cand);\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def networkDelayTime(self, times, N, K):\n        graph = collections.defaultdict(list)\n        for u, v, w in times:\n            graph[u].append((v, w))\n\n        pq = [(0, K)]\n        dist = {}\n        while pq:\n            d, node = heapq.heappop(pq)\n            if node in dist: continue\n            dist[node] = d\n            for nei, d2 in graph[node]:\n                if nei not in dist:\n                    heapq.heappush(pq, (d+d2, nei))\n\n        return max(dist.values()) if len(dist) == N else -1"}, {"lang": "Java", "code": "class Solution {\n    public int networkDelayTime(int[][] times, int N, int K) {\n        Map<Integer, List<int[]>> graph = new HashMap();\n        for (int[] edge: times) {\n            if (!graph.containsKey(edge[0]))\n                graph.put(edge[0], new ArrayList<int[]>());\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n        }\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>(\n                (info1, info2) -> info1[0] - info2[0]);\n        heap.offer(new int[]{0, K});\n\n        Map<Integer, Integer> dist = new HashMap();\n\n        while (!heap.isEmpty()) {\n            int[] info = heap.poll();\n            int d = info[0], node = info[1];\n            if (dist.containsKey(node)) continue;\n            dist.put(node, d);\n            if (graph.containsKey(node))\n                for (int[] edge: graph.get(node)) {\n                    int nei = edge[0], d2 = edge[1];\n                    if (!dist.containsKey(nei))\n                        heap.offer(new int[]{d+d2, nei});\n                }\n        }\n\n        if (dist.size() != N) return -1;\n        int ans = 0;\n        for (int cand: dist.values())\n            ans = Math.max(ans, cand);\n        return ans;\n    }"}]}
{"url": "https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target", "source": []}
{"url": "https://leetcode-cn.com/problems/prefix-and-suffix-search", "source": [{"lang": "Python", "code": "Trie = lambda: collections.defaultdict(Trie)\nWEIGHT = False\n\nclass WordFilter(object):\n    def __init__(self, words):\n        self.trie1 = Trie() #prefix\n        self.trie2 = Trie() #suffix\n        for weight, word in enumerate(words):\n            cur = self.trie1\n            self.addw(cur, weight)\n            for letter in word:\n                cur = cur[letter]\n                self.addw(cur, weight)\n\n            cur = self.trie2\n            self.addw(cur, weight)\n            for letter in word[::-1]:\n                cur = cur[letter]\n                self.addw(cur, weight)\n\n    def addw(self, node, w):\n        if WEIGHT not in node:\n            node[WEIGHT] = {w}\n        else:\n            node[WEIGHT].add(w)\n\n    def f(self, prefix, suffix):\n        cur1 = self.trie1\n        for letter in prefix:\n            if letter not in cur1: return -1\n            cur1 = cur1[letter]\n\n        cur2 = self.trie2\n        for letter in suffix[::-1]:\n            if letter not in cur2: return -1\n            cur2 = cur2[letter]\n\n        return max(cur1[WEIGHT] & cur2[WEIGHT])"}, {"lang": "Java", "code": "class WordFilter {\n    TrieNode trie1, trie2;\n    public WordFilter(String[] words) {\n        trie1 = new TrieNode();\n        trie2 = new TrieNode();\n        int wt = 0;\n        for (String word: words) {\n            char[] ca = word.toCharArray();\n\n            TrieNode cur = trie1;\n            cur.weight.add(wt);\n            for (char letter: ca) {\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n                cur.weight.add(wt);\n            }\n\n            cur = trie2;\n            cur.weight.add(wt);\n            for (int j = ca.length - 1; j >= 0; --j) {\n                char letter = ca[j];\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n                cur.weight.add(wt);\n            }\n            wt++;\n        }\n    }\n\n    public int f(String prefix, String suffix) {\n        TrieNode cur1 = trie1, cur2 = trie2;\n        for (char letter: prefix.toCharArray()) {\n            if (cur1.children[letter - 'a'] == null) return -1;\n            cur1 = cur1.children[letter - 'a'];\n        }\n        char[] ca = suffix.toCharArray();\n        for (int j = ca.length - 1; j >= 0; --j) {\n            char letter = ca[j];\n            if (cur2.children[letter - 'a'] == null) return -1;\n            cur2 = cur2.children[letter - 'a'];\n        }\n\n        int ans = -1;\n        for (int w1: cur1.weight)\n            if (w1 > ans && cur2.weight.contains(w1))\n                ans = w1;\n\n        return ans;\n    }\n}\n\nclass TrieNode {\n    TrieNode[] children;\n    Set<Integer> weight;\n    public TrieNode() {\n        children = new TrieNode[26];\n        weight = new HashSet();\n    }\n}"}, {"lang": "Python", "code": "Trie = lambda: collections.defaultdict(Trie)\nWEIGHT = False\n\nclass WordFilter(object):\n    def __init__(self, words):\n        self.trie = Trie()\n\n        for weight, word in enumerate(words):\n            cur = self.trie\n            cur[WEIGHT] = weight\n            for i, x in enumerate(word):\n                #Put all prefixes and suffixes\n                tmp = cur\n                for letter in word[i:]:\n                    tmp = tmp[letter, None]\n                    tmp[WEIGHT] = weight\n\n                tmp = cur\n                for letter in word[:-i or None][::-1]:\n                    tmp = tmp[None, letter]\n                    tmp[WEIGHT] = weight\n\n                #Advance letters\n                cur = cur[x, word[~i]]\n                cur[WEIGHT] = weight\n\n    def search(self, prefix, suffix):\n        cur = self.trie\n        for a, b in map(None, prefix, suffix[::-1]):\n            if (a, b) not in cur: return -1\n            cur = cur[a, b]\n        return cur[WEIGHT]"}, {"lang": "Java", "code": "class WordFilter {\n    TrieNode trie;\n    public WordFilter(String[] words) {\n        trie = new TrieNode();\n        int wt = 0;\n        for (String word: words) {\n            TrieNode cur = trie;\n            cur.weight = wt;\n            int L = word.length();\n            char[] chars = word.toCharArray();\n            for (int i = 0; i < L; ++i) {\n\n                TrieNode tmp = cur;\n                for (int j = i; j < L; ++j) {\n                    int code = (chars[j] - '`') * 27;\n                    if (tmp.children.get(code) == null)\n                        tmp.children.put(code, new TrieNode());\n                    tmp = tmp.children.get(code);\n                    tmp.weight = wt;\n                }\n\n                tmp = cur;\n                for (int k = L - 1 - i; k >= 0; --k) {\n                    int code = (chars[k] - '`');\n                    if (tmp.children.get(code) == null)\n                        tmp.children.put(code, new TrieNode());\n                    tmp = tmp.children.get(code);\n                    tmp.weight = wt;\n                }\n\n                int code = (chars[i] - '`') * 27 + (chars[L - 1 - i] - '`');\n                if (cur.children.get(code) == null)\n                    cur.children.put(code, new TrieNode());\n                cur = cur.children.get(code);\n                cur.weight = wt;\n\n            }\n            wt++;\n        }\n    }\n\n    public int f(String prefix, String suffix) {\n        TrieNode cur = trie;\n        int i = 0, j = suffix.length() - 1;\n        while (i < prefix.length() || j >= 0) {\n            char c1 = i < prefix.length() ? prefix.charAt(i) : '`';\n            char c2 = j >= 0 ? suffix.charAt(j) : '`';\n            int code = (c1 - '`') * 27 + (c2 - '`');\n            cur = cur.children.get(code);\n            if (cur == null) return -1;\n            i++; j--;\n        }\n        return cur.weight;\n    }\n}\n\nclass TrieNode {\n    Map<Integer, TrieNode> children;\n    int weight;\n    public TrieNode() {\n        children = new HashMap();\n        weight = 0;\n    }\n}"}, {"lang": "Python", "code": "Trie = lambda: collections.defaultdict(Trie)\nWEIGHT = False\n\nclass WordFilter(object):\n    def __init__(self, words):\n        self.trie = Trie()\n\n        for weight, word in enumerate(words):\n            word += '#'\n            for i in xrange(len(word)):\n                cur = self.trie\n                cur[WEIGHT] = weight\n                for j in xrange(i, 2 * len(word) - 1):\n                    cur = cur[word[j % len(word)]]\n                    cur[WEIGHT] = weight\n\n    def f(self, prefix, suffix):\n        cur = self.trie\n        for letter in suffix + '#' + prefix:\n            if letter not in cur:\n                return -1\n            cur = cur[letter]\n        return cur[WEIGHT]"}, {"lang": "Java", "code": "class WordFilter {\n    TrieNode trie;\n    public WordFilter(String[] words) {\n        trie = new TrieNode();\n        for (int weight = 0; weight < words.length; ++weight) {\n            String word = words[weight] + \"{\";\n            for (int i = 0; i < word.length(); ++i) {\n                TrieNode cur = trie;\n                cur.weight = weight;\n                for (int j = i; j < 2 * word.length() - 1; ++j) {\n                    int k = word.charAt(j % word.length()) - 'a';\n                    if (cur.children[k] == null)\n                        cur.children[k] = new TrieNode();\n                    cur = cur.children[k];\n                    cur.weight = weight;\n                }\n            }\n        }\n    }\n    public int f(String prefix, String suffix) {\n        TrieNode cur = trie;\n        for (char letter: (suffix + '{' + prefix).toCharArray()) {\n            if (cur.children[letter - 'a'] == null) return -1;\n            cur = cur.children[letter - 'a'];\n        }\n        return cur.weight;\n    }\n}\n\nclass TrieNode {\n    TrieNode[] children;\n    int weight;\n    public TrieNode() {\n        children = new TrieNode[27];\n        weight = 0;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/min-cost-climbing-stairs", "source": [{"lang": "Python", "code": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        f1 = f2 = 0\n        for x in reversed(cost):\n            f1, f2 = x + min(f1, f2), f1\n        return min(f1, f2)"}, {"lang": "Java", "code": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int f1 = 0, f2 = 0;\n        for (int i = cost.length - 1; i >= 0; --i) {\n            int f0 = cost[i] + Math.min(f1, f2);\n            f2 = f1;\n            f1 = f0;\n        }\n        return Math.min(f1, f2);\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others", "source": []}
{"url": "https://leetcode-cn.com/problems/shortest-completing-word", "source": [{"lang": "Python", "code": "class Solution(object):\n    def shortestCompletingWord(self, licensePlate, words):\n        def count(itera):\n            ans = [0] * 26\n            for letter in itera:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n\n        def dominates(c1, c2):\n            return all(x1 >= x2 for x1, x2 in zip(c1, c2))\n\n        ans = None\n        target = count(c.lower() for c in licensePlate if c.isalpha())\n        for word in words:\n            if ((len(word) < len(ans) or ans is None) and\n                    dominates(count(word.lower()), target)):\n                ans = word\n\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public String shortestCompletingWord(String licensePlate, String[] words) {\n        int[] target = count(licensePlate);\n        String ans = \"\";\n        for (String word: words)\n            if ((word.length() < ans.length() || ans.length() == 0) &&\n                    dominates(count(word.toLowerCase()), target))\n                ans = word;\n        return ans;\n    }\n\n    public boolean dominates(int[] count1, int[] count2) {\n        for (int i = 0; i < 26; ++i)\n            if (count1[i] < count2[i])\n                return false;\n        return true;\n    }\n\n    public int[] count(String word) {\n        int[] ans = new int[26];\n        for (char letter: word.toCharArray()){\n            int index = Character.toLowerCase(letter) - 'a';\n            if (0 <= index && index < 26)\n                ans[index]++;\n        }\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/contain-virus", "source": []}
{"url": "https://leetcode-cn.com/problems/open-the-lock", "source": [{"lang": "Python", "code": "class Solution(object):\n    def openLock(self, deadends, target):\n        def neighbors(node):\n            for i in xrange(4):\n                x = int(node[i])\n                for d in (-1, 1):\n                    y = (x + d) % 10\n                    yield node[:i] + str(y) + node[i+1:]\n\n        dead = set(deadends)\n        queue = collections.deque([('0000', 0)])\n        seen = {'0000'}\n        while queue:\n            node, depth = queue.popleft()\n            if node == target: return depth\n            if node in dead: continue\n            for nei in neighbors(node):\n                if nei not in seen:\n                    seen.add(nei)\n                    queue.append((nei, depth+1))\n        return -1"}, {"lang": "Java", "code": "class Solution {\n    public int openLock(String[] deadends, String target) {\n        Set<String> dead = new HashSet();\n        for (String d: deadends) dead.add(d);\n\n        Queue<String> queue = new LinkedList();\n        queue.offer(\"0000\");\n        queue.offer(null);\n\n        Set<String> seen = new HashSet();\n        seen.add(\"0000\");\n\n        int depth = 0;\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node == null) {\n                depth++;\n                if (queue.peek() != null)\n                    queue.offer(null);\n            } else if (node.equals(target)) {\n                return depth;\n            } else if (!dead.contains(node)) {\n                for (int i = 0; i < 4; ++i) {\n                    for (int d = -1; d <= 1; d += 2) {\n                        int y = ((node.charAt(i) - '0') + d + 10) % 10;\n                        String nei = node.substring(0, i) + (\"\" + y) + node.substring(i+1);\n                        if (!seen.contains(nei)) {\n                            seen.add(nei);\n                            queue.offer(nei);\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/cracking-the-safe", "source": [{"lang": "Python", "code": "class Solution(object):\n    def crackSafe(self, n, k):\n        seen = set()\n        ans = []\n        def dfs(node):\n            for x in map(str, range(k)):\n                nei = node + x\n                if nei not in seen:\n                    seen.add(nei)\n                    dfs(nei[1:])\n                    ans.append(x)\n\n        dfs(\"0\" * (n-1))\n        return \"\".join(ans) + \"0\" * (n-1)"}, {"lang": "Java", "code": "class Solution {\n    Set<String> seen;\n    StringBuilder ans;\n\n    public String crackSafe(int n, int k) {\n        if (n == 1 && k == 1) return \"0\";\n        seen = new HashSet();\n        ans = new StringBuilder();\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n-1; ++i)\n            sb.append(\"0\");\n        String start = sb.toString();\n\n        dfs(start, k);\n        ans.append(start);\n        return new String(ans);\n    }\n\n    public void dfs(String node, int k) {\n        for (int x = 0; x < k; ++x) {\n            String nei = node + x;\n            if (!seen.contains(nei)) {\n                seen.add(nei);\n                dfs(nei.substring(1), k);\n                ans.append(x);\n            }\n        }\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/reach-a-number", "source": [{"lang": "Python", "code": "class Solution(object):\n    def reachNumber(self, target):\n        target = abs(target)\n        k = 0\n        while target > 0:\n            k += 1\n            target -= k\n\n        return k if target % 2 == 0 else k + 1 + k%2"}, {"lang": "Java", "code": "class Solution {\n    public int reachNumber(int target) {\n        target = Math.abs(target);\n        int k = 0;\n        while (target > 0)\n            target -= ++k;\n        return target % 2 == 0 ? k : k + 1 + k%2;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/pyramid-transition-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/set-intersection-size-at-least-two", "source": [{"lang": "Python", "code": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        intervals.sort(key = lambda (s, e): (s, -e))\n        todo = [2] * len(intervals)\n        ans = 0\n        while intervals:\n            (s, e), t = intervals.pop(), todo.pop()\n            for p in xrange(s, s+t):\n                for i, (s0, e0) in enumerate(intervals):\n                    if todo[i] and p <= e0:\n                        todo[i] -= 1\n                ans += 1\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int intersectionSizeTwo(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) ->\n                    a[0] != b[0] ? a[0]-b[0] : b[1]-a[1]);\n        int[] todo = new int[intervals.length];\n        Arrays.fill(todo, 2);\n        int ans = 0, t = intervals.length;\n        while (--t >= 0) {\n            int s = intervals[t][0];\n            int e = intervals[t][1];\n            int m = todo[t];\n            for (int p = s; p < s+m; ++p) {\n                for (int i = 0; i <= t; ++i)\n                    if (todo[i] > 0 && p <= intervals[i][1])\n                        todo[i]--;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/special-binary-string", "source": []}
{"url": "https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation", "source": []}
{"url": "https://leetcode-cn.com/problems/partition-labels", "source": [{"lang": "Python", "code": "class Solution(object):\n    def partitionLabels(self, S):\n        last = {c: i for i, c in enumerate(S)}\n        j = anchor = 0\n        ans = []\n        for i, c in enumerate(S):\n            j = max(j, last[c])\n            if i == j:\n                ans.append(i - anchor + 1)\n                anchor = i + 1\n            \n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public List<Integer> partitionLabels(String S) {\n        int[] last = new int[26];\n        for (int i = 0; i < S.length(); ++i)\n            last[S.charAt(i) - 'a'] = i;\n        \n        int j = 0, anchor = 0;\n        List<Integer> ans = new ArrayList();\n        for (int i = 0; i < S.length(); ++i) {\n            j = Math.max(j, last[S.charAt(i) - 'a']);\n            if (i == j) {\n                ans.add(i - anchor + 1);\n                anchor = i + 1;\n            }\n        }\n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/largest-plus-sign", "source": [{"lang": "Python", "code": "class Solution(object):\n    def orderOfLargestPlusSign(self, N, mines):\n        banned = {tuple(mine) for mine in mines}\n        ans = 0\n        for r in xrange(N):\n            for c in xrange(N):\n                k = 0\n                while (k <= r < N-k and k <= c < N-k and\n                        (r-k, c) not in banned and\n                        (r+k, c) not in banned and\n                        (r, c-k) not in banned and\n                        (r, c+k) not in banned):\n                    k += 1\n                ans = max(ans, k)\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\n        Set<Integer> banned = new HashSet();\n        for (int[] mine: mines)\n            banned.add(mine[0] * N + mine[1]);\n            \n        int ans = 0;\n        for (int r = 0; r < N; ++r) for (int c = 0; c < N; ++c) {\n            int k = 0;\n            while (k <= r && r < N-k && k <= c && c < N-k &&\n                    !banned.contains((r-k)*N + c) &&\n                    !banned.contains((r+k)*N + c) &&\n                    !banned.contains(r*N + c-k) &&\n                    !banned.contains(r*N + c+k))\n                k++;\n            \n            ans = Math.max(ans, k);\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def orderOfLargestPlusSign(self, N, mines):\n        banned = {tuple(mine) for mine in mines}\n        dp = [[0] * N for _ in xrange(N)]\n        ans = 0\n        \n        for r in xrange(N):\n            count = 0\n            for c in xrange(N):\n                count = 0 if (r,c) in banned else count+1\n                dp[r][c] = count\n            \n            count = 0\n            for c in xrange(N-1, -1, -1):\n                count = 0 if (r,c) in banned else count+1\n                if count < dp[r][c]: dp[r][c] = count\n        \n        for c in xrange(N):\n            count = 0\n            for r in xrange(N):\n                count = 0 if (r,c) in banned else count+1\n                if count < dp[r][c]: dp[r][c] = count\n            \n            count = 0\n            for r in xrange(N-1, -1, -1):\n                count = 0 if (r, c) in banned else count+1\n                if count < dp[r][c]: dp[r][c] = count\n                if dp[r][c] > ans: ans = dp[r][c]\n        \n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\n        Set<Integer> banned = new HashSet();\n        int[][] dp = new int[N][N];\n        \n        for (int[] mine: mines)\n            banned.add(mine[0] * N + mine[1]);\n        int ans = 0, count;\n        \n        for (int r = 0; r < N; ++r) {\n            count = 0;\n            for (int c = 0; c < N; ++c) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = count;\n            }\n            \n            count = 0;\n            for (int c = N-1; c >= 0; --c) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n            }\n        }\n        \n        for (int c = 0; c < N; ++c) {\n            count = 0;\n            for (int r = 0; r < N; ++r) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n            }\n            \n            count = 0;\n            for (int r = N-1; r >= 0; --r) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n                ans = Math.max(ans, dp[r][c]);\n            }\n        }\n        \n        return ans;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/couples-holding-hands", "source": []}
{"url": "https://leetcode-cn.com/problems/toeplitz-matrix", "source": [{"lang": "Python", "code": "class Solution(object):\n    def isToeplitzMatrix(self, matrix):\n        groups = {}\n        for r, row in enumerate(matrix):\n            for c, val in enumerate(row):\n                if r-c not in groups:\n                    groups[r-c] = val\n                elif groups[r-c] != val:\n                    return False\n        return True"}, {"lang": "Java", "code": "class Solution {\n    public boolean isToeplitzMatrix(int[][] matrix) {\n        Map<Integer, Integer> groups = new HashMap();\n        for (int r = 0; r < matrix.length; ++r) {\n            for (int c = 0; c < matrix[0].length; ++c) {\n                if (!groups.containsKey(r-c))\n                    groups.put(r-c, matrix[r][c]);\n                else if (groups.get(r-c) != matrix[r][c])\n                    return False;\n            }\n        }\n        return True;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isToeplitzMatrix(self, matrix):\n        return all(r == 0 or c == 0 or matrix[r-1][c-1] == val\n                   for r, row in enumerate(matrix)\n                   for c, val in enumerate(row))"}, {"lang": "Java", "code": "class Solution {\n    public boolean isToeplitzMatrix(int[][] matrix) {\n        for (int r = 0; r < matrix.length; ++r)\n            for (int c = 0; c < matrix[0].length; ++c)\n                if (r > 0 && c > 0 && matrix[r-1][c-1] != matrix[r][c])\n                    return false;\n        return true;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/reorganize-string", "source": [{"lang": "Python", "code": "class Solution(object):\n    def reorganizeString(self, S):\n        N = len(S)\n        A = []\n        for c, x in sorted((S.count(x), x) for x in set(S)):\n            if c > (N+1)/2: return \"\"\n            A.extend(c * x)\n        ans = [None] * N\n        ans[::2], ans[1::2] = A[N/2:], A[:N/2]\n        return \"\".join(ans)"}, {"lang": "Java", "code": "class Solution {\n    public String reorganizeString(String S) {\n        int N = S.length();\n        int[] counts = new int[26];\n        for (char c: S.toCharArray()) counts[c-'a'] += 100;\n        for (int i = 0; i < 26; ++i) counts[i] += i;\n        //Encoded counts[i] = 100*(actual count) + (i)\n        Arrays.sort(counts);\n\n        char[] ans = new char[N];\n        int t = 1;\n        for (int code: counts) {\n            int ct = code / 100;\n            char ch = (char) ('a' + (code % 100));\n            if (ct > (N+1) / 2) return \"\";\n            for (int i = 0; i < ct; ++i) {\n                if (t >= N) t = 0;\n                ans[t] = ch;\n                t += 2;\n            }\n        }\n\n        return String.valueOf(ans);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def reorganizeString(self, S):\n        pq = [(-S.count(x), x) for x in set(S)]\n        heapq.heapify(pq)\n        if any(-nc > (len(S) + 1) / 2 for nc, x in pq):\n            return \"\"\n\n        ans = []\n        while len(pq) >= 2:\n            nct1, ch1 = heapq.heappop(pq)\n            nct2, ch2 = heapq.heappop(pq)\n            #This code turns out to be superfluous, but explains what is happening\n            #if not ans or ch1 != ans[-1]:\n            #    ans.extend([ch1, ch2])\n            #else:\n            #    ans.extend([ch2, ch1])\n            ans.extend([ch1, ch2])\n            if nct1 + 1: heapq.heappush(pq, (nct1 + 1, ch1))\n            if nct2 + 1: heapq.heappush(pq, (nct2 + 1, ch2))\n\n        return \"\".join(ans) + (pq[0][1] if pq else '')"}, {"lang": "Java", "code": "class Solution {\n    public String reorganizeString(String S) {\n        int N = S.length();\n        int[] count = new int[26];\n        for (char c: S.toCharArray()) count[c-'a']++;\n        PriorityQueue<MultiChar> pq = new PriorityQueue<MultiChar>((a, b) ->\n            a.count == b.count ? a.letter - b.letter : b.count - a.count);\n\n        for (int i = 0; i < 26; ++i) if (count[i] > 0) {\n            if (count[i] > (N + 1) / 2) return \"\";\n            pq.add(new MultiChar(count[i], (char) ('a' + i)));\n        }\n\n        StringBuilder ans = new StringBuilder();\n        while (pq.size() >= 2) {\n            MultiChar mc1 = pq.poll();\n            MultiChar mc2 = pq.poll();\n            /*This code turns out to be superfluous, but explains what is happening\n            if (ans.length() == 0 || mc1.letter != ans.charAt(ans.length() - 1)) {\n                ans.append(mc1.letter);\n                ans.append(mc2.letter);\n            } else {\n                ans.append(mc2.letter);\n                ans.append(mc1.letter);\n            }*/\n            ans.append(mc1.letter);\n            ans.append(mc2.letter);\n            if (--mc1.count > 0) pq.add(mc1);\n            if (--mc2.count > 0) pq.add(mc2);\n            }\n        }\n\n        if (pq.size() > 0) ans.append(pq.poll().letter);\n        return ans.toString();\n    }\n}\nclass MultiChar {\n    int count;\n    char letter;\n    MultiChar(int ct, char ch) {\n        count = ct;\n        letter = ch;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/max-chunks-to-make-sorted", "source": []}
{"url": "https://leetcode-cn.com/problems/basic-calculator-iv", "source": []}
{"url": "https://leetcode-cn.com/problems/jewels-and-stones", "source": [{"lang": "Java", "code": "class Solution {\n    public int numJewelsInStones(String J, String S) {\n        int ans = 0;\n        for (char s: S.toCharArray()) // For each stone...\n            for (char j: J.toCharArray()) // For each jewel...\n                if (j == s) {  // If the stone is a jewel...\n                    ans++;\n                    break; // Stop searching whether this stone 's' is a jewel\n                }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numJewelsInStones(self, J, S):\n        return sum(s in J for s in S)"}, {"lang": "Java", "code": "class Solution {\n    public int numJewelsInStones(String J, String S) {\n        Set<Character> Jset = new HashSet();\n        for (char j: J.toCharArray())\n            Jset.add(j);\n\n        int ans = 0;\n        for (char s: S.toCharArray())\n            if (Jset.contains(s))\n                ans++;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numJewelsInStones(self, J, S):\n        Jset = set(J)\n        return sum(s in Jset for s in S)"}]}
{"url": "https://leetcode-cn.com/problems/sliding-puzzle", "source": [{"lang": "Python", "code": "queue = collections.deque([(start, 0)])\nseen = {start}\nwhile queue:\n    node, depth = queue.popleft()\n    if node == target: return depth\n    for nei in neighbors(node):\n        if nei not in seen:\n            seen.add(nei)\n            queue.append((nei, depth+1))"}, {"lang": "Java", "code": "class Solution {\n    public int slidingPuzzle(int[][] board) {\n        int R = board.length, C = board[0].length;\n        int sr = 0, sc = 0;\n        search:\n            for (sr = 0; sr < R; sr++)\n                for (sc = 0; sc < C; sc++)\n                    if (board[sr][sc] == 0)\n                        break search;\n\n        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        Queue<Node> queue = new ArrayDeque();\n        Node start = new Node(board, sr, sc, 0);\n        queue.add(start);\n\n        Set<String> seen = new HashSet();\n        seen.add(start.boardstring);\n\n        String target = Arrays.deepToString(new int[][]{{1,2,3}, {4,5,0}});\n\n        while (!queue.isEmpty()) {\n            Node node = queue.remove();\n            if (node.boardstring.equals(target))\n                return node.depth;\n\n            for (int[] di: directions) {\n                int nei_r = di[0] + node.zero_r;\n                int nei_c = di[1] + node.zero_c;\n\n                if ((Math.abs(nei_r - node.zero_r) + Math.abs(nei_c - node.zero_c) != 1) ||\n                        nei_r < 0 || nei_r >= R || nei_c < 0 || nei_c >= C)\n                    continue;\n\n                int[][] newboard = new int[R][C];\n                int t = 0;\n                for (int[] row: node.board)\n                    newboard[t++] = row.clone();\n                newboard[node.zero_r][node.zero_c] = newboard[nei_r][nei_c];\n                newboard[nei_r][nei_c] = 0;\n\n                Node nei = new Node(newboard, nei_r, nei_c, node.depth+1);\n                if (seen.contains(nei.boardstring))\n                    continue;\n                queue.add(nei);\n                seen.add(nei.boardstring);\n            }\n        }\n\n        return -1;\n    }\n}\n\nclass Node {\n    int[][] board;\n    String boardstring;\n    int zero_r;\n    int zero_c;\n    int depth;\n    Node(int[][] B, int r, int c, int d) {\n        board = B;\n        boardstring = Arrays.deepToString(board);\n        zero_r = r;\n        zero_c = c;\n        depth = d;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def slidingPuzzle(self, board):\n        R, C = len(board), len(board[0])\n        start = tuple(itertools.chain(*board))\n        queue = collections.deque([(start, start.index(0), 0)])\n        seen = {start}\n\n        target = tuple(range(1, R*C) + [0])\n\n        while queue:\n            board, posn, depth = queue.popleft()\n            if board == target: return depth\n            for d in (-1, 1, -C, C):\n                nei = posn + d\n                if abs(nei/C - posn/C) + abs(nei%C - posn%C) != 1:\n                    continue\n                if 0 <= nei < R*C:\n                    newboard = list(board)\n                    newboard[posn], newboard[nei] = newboard[nei], newboard[posn]\n                    newt = tuple(newboard)\n                    if newt not in seen:\n                        seen.add(newt)\n                        queue.append((newt, nei, depth+1))\n\n        return -1"}, {"lang": "Java", "code": "class Solution {\n    public int slidingPuzzle(int[][] board) {\n        int R = board.length, C = board[0].length;\n        int sr = 0, sc = 0;\n\n        //Find sr, sc\n        search:\n            for (sr = 0; sr < R; sr++)\n                for (sc = 0; sc < C; sc++)\n                    if (board[sr][sc] == 0)\n                        break search;\n\n        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        PriorityQueue<Node> heap = new PriorityQueue<Node>((a, b) ->\n            (a.heuristic + a.depth) - (b.heuristic + b.depth));\n        Node start = new Node(board, sr, sc, 0);\n        heap.add(start);\n\n        Map<String, Integer> cost = new HashMap();\n        cost.put(start.boardstring, 9999999);\n\n        String target = Arrays.deepToString(new int[][]{{1,2,3}, {4,5,0}});\n        String targetWrong = Arrays.deepToString(new int[][]{{1,2,3}, {5,4,0}});\n\n        while (!heap.isEmpty()) {\n            Node node = heap.poll();\n            if (node.boardstring.equals(target))\n                return node.depth;\n            if (node.boardstring.equals(targetWrong))\n                return -1;\n            if (node.depth + node.heuristic > cost.get(node.boardstring))\n                continue;\n\n            for (int[] di: directions) {\n                int nei_r = di[0] + node.zero_r;\n                int nei_c = di[1] + node.zero_c;\n\n                // If the neighbor is not on the board or wraps incorrectly around rows/cols\n                if ((Math.abs(nei_r - node.zero_r) + Math.abs(nei_c - node.zero_c) != 1) ||\n                        nei_r < 0 || nei_r >= R || nei_c < 0 || nei_c >= C)\n                    continue;\n\n                int[][] newboard = new int[R][C];\n                int t = 0;\n                for (int[] row: node.board)\n                    newboard[t++] = row.clone();\n\n                // Swap the elements on the new board\n                newboard[node.zero_r][node.zero_c] = newboard[nei_r][nei_c];\n                newboard[nei_r][nei_c] = 0;\n\n                Node nei = new Node(newboard, nei_r, nei_c, node.depth+1);\n                if (nei.depth + nei.heuristic >= cost.getOrDefault(nei.boardstring, 9999999))\n                    continue;\n                heap.add(nei);\n                cost.put(nei.boardstring, nei.depth + nei.heuristic);\n            }\n        }\n\n        return -1;\n    }\n}\n\nclass Node {\n    int[][] board;\n    String boardstring;\n    int heuristic;\n    int zero_r;\n    int zero_c;\n    int depth;\n    Node(int[][] B, int zr, int zc, int d) {\n        board = B;\n        boardstring = Arrays.deepToString(board);\n\n        //Calculate heuristic\n        heuristic = 0;\n        int R = B.length, C = B[0].length;\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                if (board[r][c] == 0) continue;\n                int v = (board[r][c] + R*C - 1) % (R*C);\n                // v/C, v%C: where board[r][c] should go in a solved puzzle\n                heuristic += Math.abs(r - v/C) + Math.abs(c - v%C);\n            }\n        heuristic /= 2;\n        zero_r = zr;\n        zero_c = zc;\n        depth = d;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def slidingPuzzle(self, board):\n        R, C = len(board), len(board[0])\n        start = tuple(itertools.chain(*board))\n        target = tuple(range(1, R*C) + [0])\n        target_wrong = tuple(range(1, R*C-2) + [R*C-1, R*C-2, 0])\n        pq = [(0, 0, start, start.index(0))]\n        cost = {start: 0}\n\n        expected = {(C*r+c+1) % (R*C) : (r, c)\n                    for r in xrange(R) for c in xrange(C)}\n        def heuristic(board):\n            ans = 0\n            for r in xrange(R):\n                for c in xrange(C):\n                    val = board[C*r + c]\n                    if val == 0: continue\n                    er, ec = expected[val]\n                    ans += abs(r - er) + abs(c - ec)\n            return ans\n\n        while pq:\n            #f = estimated distance (priority)\n            #g = actual distance travelled (depth)\n            f, g, board, zero = heapq.heappop(pq)\n            if board == target: return g\n            if board == target_wrong: return -1\n            if f > cost[board]: continue\n\n            for delta in (-1, 1, -C, C):\n                nei = zero + delta\n                if abs(zero / C - nei / C) + abs(zero % C - nei % C) != 1:\n                    continue\n                if 0 <= nei < R*C:\n                    board2 = list(board)\n                    board2[zero], board2[nei] = board2[nei], board2[zero]\n                    board2t = tuple(board2)\n                    ncost = g + 1 + heuristic(board2t)\n                    if ncost < cost.get(board2t, float('inf')):\n                        cost[board2t] = ncost\n                        heapq.heappush(pq, (ncost, g+1, board2t, nei))\n\n        return -1"}]}
{"url": "https://leetcode-cn.com/problems/global-and-local-inversions", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean isIdealPermutation(int[] A) {\n        int N = A.length;\n        for (int i = 0; i < N; ++i)\n            for (int j = i+2; j < N; ++j)\n                if (A[i] > A[j]) return false;\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isIdealPermutation(self, A):\n        return all(x < A[j]\n                   for i, x in enumerate(A)\n                   for j in xrange(i+2, len(A)))"}, {"lang": "Java", "code": "class Solution {\n    public boolean isIdealPermutation(int[] A) {\n        int N = A.length;\n        int floor = N;\n        for (int i=N-1; i>=2; --i) {\n            floor = Math.min(floor, A[i]);\n            if (A[i-2] > floor) return false;\n        }\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isIdealPermutation(self, A):\n        N = len(A)\n        floor = N\n        for i in xrange(N-1, -1, -1):\n            floor = min(floor, A[i])\n            if i >= 2 and A[i-2] > floor:\n                return False\n        return True"}, {"lang": "Python", "code": "class Solution(object):\n    def isIdealPermutation(self, A):\n        return all(abs(i-x) <= 1 for i,x in enumerate(A))"}, {"lang": "Java", "code": "class Solution {\n    public boolean isIdealPermutation(int[] A) {\n        for (int i = 0; i < A.length; ++i)\n            if (Math.abs(A[i] - i) > 1)\n                return false;\n        return true;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/swap-adjacent-in-lr-string", "source": []}
{"url": "https://leetcode-cn.com/problems/swim-in-rising-water", "source": []}
{"url": "https://leetcode-cn.com/problems/k-th-symbol-in-grammar", "source": []}
{"url": "https://leetcode-cn.com/problems/reaching-points", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        if (sx > tx || sy > ty) return false;\n        if (sx == tx && sy == ty) return true;\n        return reachingPoints(sx+sy, sy, tx, ty) || reachingPoints(sx, sx+sy, tx, ty);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        if sx > tx or sy > ty: return False\n        if sx == tx and sy == ty: return True\n        return self.reachingPoints(sx+sy, sy, tx, ty) or \\\n               self.reachingPoints(sx, sx+sy, tx, ty)"}, {"lang": "Java", "code": "import java.awt.Point;\n\nclass Solution {\n    Set<Point> seen;\n    int tx, ty;\n\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        seen = new HashSet();\n        this.tx = tx;\n        this.ty = ty;\n        search(new Point(sx, sy));\n        return seen.contains(new Point(tx, ty));\n    }\n\n    public void search(Point P) {\n        if (seen.contains(P)) return;\n        if (P.x > tx || P.y > ty) return;\n        seen.add(P);\n        search(new Point(P.x + P.y, P.y));\n        search(new Point(P.x, P.x + P.y));\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        seen = set()\n        def search(x, y):\n            if (x, y) in seen: return\n            if x > tx or y > ty: return\n            seen.add((x, y))\n            search(x+y, y)\n            search(x, x+y)\n\n        search(sx, sy)\n        return (tx, ty) in seen"}, {"lang": "Java", "code": "class Solution {\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        while (tx >= sx && ty >= sy) {\n            if (sx == tx && sy == ty)\n                return true;\n            if (tx > ty) tx -= ty;\n            else ty -= tx;\n        }\n        return false;\n    }\n}"}, {"lang": "Java", "code": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        while tx >= sx and ty >= sy:\n            if sx == tx and sy == ty: return True\n            if tx > ty:\n                tx -= ty\n            else:\n                ty -= tx\n        return False"}, {"lang": "Python", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/rabbits-in-forest", "source": [{"lang": "Java", "code": "class Solution {\n    public int numRabbits(int[] answers) {\n        int[] count = new int[1000];\n        for (int x: answers) count[x]++;\n\n        int ans = 0;\n        for (int k = 0; k < 1000; ++k)\n            ans += Math.floorMod(-count[k], k+1) + count[k];\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numRabbits(self, answers):\n        count = collections.Counter(answers)\n        return sum(-v % (k+1) + v for k, v in count.iteritems())"}]}
{"url": "https://leetcode-cn.com/problems/transform-to-chessboard", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes", "source": []}
{"url": "https://leetcode-cn.com/problems/letter-case-permutation", "source": [{"lang": "Java", "code": "class Solution {\n    public List<String> letterCasePermutation(String S) {\n        List<StringBuilder> ans = new ArrayList();\n        ans.add(new StringBuilder());\n\n        for (char c: S.toCharArray()) {\n            int n = ans.size();\n            if (Character.isLetter(c)) {\n                for (int i = 0; i < n; ++i) {\n                    ans.add(new StringBuilder(ans.get(i)));\n                    ans.get(i).append(Character.toLowerCase(c));\n                    ans.get(n+i).append(Character.toUpperCase(c));\n                }\n            } else {\n                for (int i = 0; i < n; ++i)\n                    ans.get(i).append(c);\n            }\n        }\n\n        List<String> finalans = new ArrayList();\n        for (StringBuilder sb: ans)\n            finalans.add(sb.toString());\n        return finalans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def letterCasePermutation(self, S):\n        ans = [[]]\n\n        for char in S:\n            n = len(ans)\n            if char.isalpha():\n                for i in xrange(n):\n                    ans.append(ans[i][:])\n                    ans[i].append(char.lower())\n                    ans[n+i].append(char.upper())\n            else:\n                for i in xrange(n):\n                    ans[i].append(char)\n\n        return map(\"\".join, ans)"}, {"lang": "Java", "code": "class Solution {\n    public List<String> letterCasePermutation(String S) {\n        int B = 0;\n        for (char c: S.toCharArray())\n            if (Character.isLetter(c))\n                B++;\n\n        List<String> ans = new ArrayList();\n\n        for (int bits = 0; bits < 1<<B; bits++) {\n            int b = 0;\n            StringBuilder word = new StringBuilder();\n            for (char letter: S.toCharArray()) {\n                if (Character.isLetter(letter)) {\n                    if (((bits >> b++) & 1) == 1)\n                        word.append(Character.toLowerCase(letter));\n                    else\n                        word.append(Character.toUpperCase(letter));\n                } else {\n                    word.append(letter);\n                }\n            }\n\n            ans.add(word.toString());\n        }\n\n        return ans;\n\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def letterCasePermutation(self, S):\n        B = sum(letter.isalpha() for letter in S)\n        ans = []\n\n        for bits in xrange(1 << B):\n            b = 0\n            word = []\n            for letter in S:\n                if letter.isalpha():\n                    if (bits >> b) & 1:\n                        word.append(letter.lower())\n                    else:\n                        word.append(letter.upper())\n\n                    b += 1\n                else:\n                    word.append(letter)\n\n            ans.append(\"\".join(word))\n        return ans"}, {"lang": "Python", "code": "class Solution(object):\n    def letterCasePermutation(self, S):\n        f = lambda x: (x.lower(), x.upper()) if x.isalpha() else x\n        return map(\"\".join, itertools.product(*map(f, S)))"}]}
{"url": "https://leetcode-cn.com/problems/is-graph-bipartite", "source": [{"lang": "java", "code": "class Solution {\n    public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        int[] color = new int[n];\n        Arrays.fill(color, -1);\n\n        for (int start = 0; start < n; ++start) {\n            if (color[start] == -1) {\n                Stack<Integer> stack = new Stack();\n                stack.push(start);\n                color[start] = 0;\n\n                while (!stack.empty()) {\n                    Integer node = stack.pop();\n                    for (int nei: graph[node]) {\n                        if (color[nei] == -1) {\n                            stack.push(nei);\n                            color[nei] = color[node] ^ 1;\n                        } else if (color[nei] == color[node]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n}"}, {"lang": "python", "code": "class Solution(object):\n    def isBipartite(self, graph):\n        color = {}\n        for node in xrange(len(graph)):\n            if node not in color:\n                stack = [node]\n                color[node] = 0\n                while stack:\n                    node = stack.pop()\n                    for nei in graph[node]:\n                        if nei not in color:\n                            stack.append(nei)\n                            color[nei] = color[node] ^ 1\n                        elif color[nei] == color[node]:\n                            return False\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/k-th-smallest-prime-fraction", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] kthSmallestPrimeFraction(int[] primes, int K) {\n        double lo = 0, hi = 1;\n        int[] ans = new int[]{0, 1};\n\n        while (hi - lo > 1e-9) {\n            double mi = lo + (hi - lo) / 2.0;\n            int[] res = under(mi, primes);\n            if (res[0] < K) {\n                lo = mi;\n            } else {\n                ans[0] = res[1];\n                ans[1] = res[2];\n                hi = mi;\n            }\n        }\n        return ans;\n    }\n\n    public int[] under(double x, int[] primes) {\n        // Returns {count, numerator, denominator}\n        int numer = 0, denom = 1, count = 0, i = -1;\n        for (int j = 1; j < primes.length; ++j) {\n            // For each j, find the largest i so that primes[i] / primes[j] < x\n            // It has to be at least as big as the previous i, so reuse it (\"two pointer\")\n            while (primes[i+1] < primes[j] * x) ++i;\n\n            // There are i+1 fractions: (primes[0], primes[j]),\n            // (primes[1], primes[j]), ..., (primes[i], primes[j])\n            count += i+1;\n            if (i >= 0 && numer * primes[j] < denom * primes[i]) {\n                numer = primes[i];\n                denom = primes[j];\n            }\n        }\n        return new int[]{count, numer, denom};\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def kthSmallestPrimeFraction(self, primes, K):\n        from fractions import Fraction\n        def under(x):\n            # Return the number of fractions below x,\n            # and the largest such fraction\n            count = best = 0\n            i = -1\n            for j in xrange(1, len(primes)):\n                while primes[i+1] < primes[j] * x:\n                    i += 1\n                count += i+1\n                if i >= 0:\n                    best = max(best, Fraction(primes[i], primes[j]))\n            return count, best\n\n        # Binary search for x such that there are K fractions\n        # below x.\n        lo, hi = 0.0, 1.0\n        while hi - lo > 1e-9:\n            mi = (lo + hi) / 2.0\n            count, best = under(mi)\n            if count < K:\n                lo = mi\n            else:\n                ans = best\n                hi = mi\n\n        return ans.numerator, ans.denominator"}]}
{"url": "https://leetcode-cn.com/problems/cheapest-flights-within-k-stops", "source": []}
{"url": "https://leetcode-cn.com/problems/rotated-digits", "source": [{"lang": "Java", "code": "class Solution {\n    public int rotatedDigits(int N) {\n        // Count how many n in [1, N] are good.\n        int ans = 0;\n        for (int n = 1; n <= N; ++n)\n            if (good(n, false)) ans++;\n        return ans;\n    }\n\n    // Return true if n is good.\n    // The flag is true iff we have an occurrence of 2, 5, 6, 9.\n    public boolean good(int n, boolean flag) {\n        if (n == 0) return flag;\n\n        int d = n % 10;\n        if (d == 3 || d == 4 || d == 7) return false;\n        if (d == 0 || d == 1 || d == 8) return good(n / 10, flag);\n        return good(n / 10, true);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def rotatedDigits(self, N):\n        ans = 0\n        # For each x in [1, N], check whether it's good\n        for x in xrange(1, N+1):\n            S = str(x)\n            # Each x has only rotateable digits, and one of them\n            # rotates to a different digit\n            ans += (all(d not in '347' for d in S)\n                    and any(d in '2569' for d in S))\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int rotatedDigits(int N) {\n        char[] A = String.valueOf(N).toCharArray();\n        int K = A.length;\n\n        int[][][] memo = new int[K+1][2][2];\n        memo[K][0][1] = memo[K][1][1] = 1;\n        for (int i = K - 1; i >= 0; --i) {\n            for (int eqf = 0; eqf <= 1; ++eqf)\n                for (int invf = 0; invf <= 1; ++invf) {\n                    // We will compute ans = memo[i][eqf][invf],\n                    // the number of good numbers with respect to N = A[i:].\n                    // If eqf is true, we must stay below N, otherwise\n                    // we can use any digits.\n                    // Invf becomes true when we write a 2569, and it\n                    // must be true by the end of our writing as all\n                    // good numbers have a digit in 2569.\n                    int ans = 0;\n                    for (char d = '0'; d <= (eqf == 1 ? A[i] : '9'); ++d) {\n                        if (d == '3' || d == '4' || d == '7') continue;\n                        boolean invo = (d == '2' || d == '5' || d == '6' || d == '9');\n                        ans += memo[i+1][d == A[i] ? eqf : 0][invo ? 1 : invf];\n                    }\n                    memo[i][eqf][invf] = ans;\n                }\n        }\n\n        return memo[0][1][0];\n    }\n\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def rotatedDigits(self, N):\n        A = map(int, str(N))\n\n        memo = {}\n        def dp(i, equality_flag, involution_flag):\n            if i == len(A): return +(involution_flag)\n            if (i, equality_flag, involution_flag) not in memo:\n                ans = 0\n                for d in xrange(A[i] + 1 if equality_flag else 10):\n                    if d in {3, 4, 7}: continue\n                    ans += dp(i+1, equality_flag and d == A[i],\n                              involution_flag or d in {2, 5, 6, 9})\n                memo[i, equality_flag, involution_flag] = ans\n            return memo[i, equality_flag, involution_flag]\n\n        return dp(0, True, False)"}]}
{"url": "https://leetcode-cn.com/problems/escape-the-ghosts", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean escapeGhosts(int[][] ghosts, int[] target) {\n        int[] source = new int[]{0, 0};\n        for (int[] ghost: ghosts)\n            if (taxi(ghost, target) <= taxi(source, target))\n                return false;\n        return true;\n    }\n\n    public int taxi(int[] P, int[] Q) {\n        return Math.abs(P[0] - Q[0]) + Math.abs(P[1] - Q[1]);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def escapeGhosts(self, ghosts, target):\n        def taxi(P, Q):\n            return abs(P[0] - Q[0]) + abs(P[1] - Q[1])\n\n        return all(taxi([0, 0], target) < taxi(ghost, target)\n                   for ghost in ghosts)"}]}
{"url": "https://leetcode-cn.com/problems/domino-and-tromino-tiling", "source": [{"lang": "Java", "code": "class Solution {\n    public int numTilings(int N) {\n        int MOD = 1_000_000_007;\n        long[] dp = new long[]{1, 0, 0, 0};\n        for (int i = 0; i < N; ++i) {\n            long[] ndp = new long[4];\n            ndp[0b00] = (dp[0b00] + dp[0b11]) % MOD;\n            ndp[0b01] = (dp[0b00] + dp[0b10]) % MOD;\n            ndp[0b10] = (dp[0b00] + dp[0b01]) % MOD;\n            ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) % MOD;\n            dp = ndp;\n        }\n        return (int) dp[0];\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numTilings(self, N):\n        MOD = 10**9 + 7\n        dp = [1, 0, 0, 0]\n        for _ in xrange(N):\n            ndp = [0, 0, 0, 0]\n            ndp[0b00] = (dp[0b00] + dp[0b11]) % MOD\n            ndp[0b01] = (dp[0b00] + dp[0b10]) % MOD\n            ndp[0b10] = (dp[0b00] + dp[0b01]) % MOD\n            ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) % MOD\n            dp = ndp\n\n        return dp[0]"}, {"lang": "Java", "code": "class Solution {\n    int MOD = 1_000_000_007;\n\n    public int numTilings(int N) {\n        int[][] T = new int[][]{{1,0,0,1},{1,0,1,0},{1,1,0,0},{1,1,1,0}};\n        return matrixExpo(T, N)[0][0];\n    }\n\n    public int[][] matrixMult(int[][] A, int[][] B) {\n        int[][] ans = new int[A.length][A.length];\n        for (int i = 0; i < A.length; i++)\n            for (int j = 0; j < B[0].length; j++) {\n                long entry = 0;\n                for (int k = 0; k < B.length; k++)\n                    entry += (long) A[i][k] * (long) B[k][j] % MOD;\n                ans[i][j] = (int) (entry % MOD);\n            }\n\n        return ans;\n    }\n\n    public int[][] matrixExpo(int[][] A, int pow) {\n        int[][] ans = new int[A.length][A.length];\n        for (int i = 0; i < A.length; i++) ans[i][i] = 1;\n        if (pow == 0) return ans;\n        if (pow == 1) return A;\n        if (pow % 2 == 1) return matrixMult(matrixExpo(A, pow-1), A);\n        int[][] B = matrixExpo(A, pow / 2);\n        return matrixMult(B, B);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numTilings(self, N):\n        MOD = 10**9 + 7\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a * b for a, b in zip(row, col)) % MOD\n                     for col in ZB] for row in A]\n\n        def matrix_expo(A, K):\n            if K == 0:\n                return [[+(i==j) for j in xrange(len(A))]\n                        for i in xrange(len(A))]\n            if K == 1:\n                return A\n            elif K % 2:\n                return matrix_mult(matrix_expo(A, K-1), A)\n            B = matrix_expo(A, K/2)\n            return matrix_mult(B, B)\n\n        T = [[1, 0, 0, 1],\n             [1, 0, 1, 0],\n             [1, 1, 0, 0],\n             [1, 1, 1, 0]]\n\n        return matrix_expo(T, N)[0][0]"}]}
{"url": "https://leetcode-cn.com/problems/custom-sort-string", "source": [{"lang": "Java", "code": "class Solution {\n    public String customSortString(String S, String T) {\n        // count[char] = the number of occurrences of 'char' in T.\n        // This is offset so that count[0] = occurrences of 'a', etc.\n        // 'count' represents the current state of characters\n        // (with multiplicity) we need to write to our answer.\n        int[] count = new int[26];\n        for (char c: T.toCharArray())\n            count[c - 'a']++;\n\n        // ans will be our final answer.  We use StringBuilder to join\n        // the answer so that we more efficiently calculate a\n        // concatenation of strings.\n        StringBuilder ans = new StringBuilder();\n\n        // Write all characters that occur in S, in the order of S.\n        for (char c: S.toCharArray()) {\n            for (int i = 0; i < count[c - 'a']; ++i)\n                ans.append(c);\n            // Setting count[char] to zero to denote that we do\n            // not need to write 'char' into our answer anymore.\n            count[c - 'a'] = 0;\n        }\n\n        // Write all remaining characters that don't occur in S.\n        // That information is specified by 'count'.\n        for (char c = 'a'; c <= 'z'; ++c)\n            for (int i = 0; i < count[c - 'a']; ++i)\n                ans.append(c);\n\n        return ans.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def customSortString(self, S, T):\n        # count[char] will be the number of occurrences of\n        # 'char' in T.\n        count = collections.Counter(T)\n        ans = []\n\n        # Write all characters that occur in S, in the order of S.\n        for c in S:\n            ans.append(c * count[c])\n            # Set count[c] = 0 to denote that we do not need\n            # to write 'c' to our answer anymore.\n            count[c] = 0\n\n        # Write all remaining characters that don't occur in S.\n        # That information is specified by 'count'.\n        for c in count:\n            ans.append(c * count[c])\n\n        return \"\".join(ans)"}]}
{"url": "https://leetcode-cn.com/problems/number-of-matching-subsequences", "source": [{"lang": "Java", "code": "class Solution {\n    char[] ca, cb;\n    public int numMatchingSubseq(String S, String[] words) {\n        int ans = 0;\n        ca = S.toCharArray();\n        for (String word: words)\n            if (subseq(word)) ans++;\n        return ans;\n    }\n\n    public boolean subseq(String word) {\n        int i = 0;\n        cb = word.toCharArray();\n        for (char c: ca) {\n            if (i < cb.length && c == cb[i]) i++;\n        }\n        return (i == cb.length);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numMatchingSubseq(self, S, words):\n        def subseq(word):\n           it = iter(S)\n           return all(x in it for x in word)\n\n        return sum(subseq(word) for word in words)"}, {"lang": "Java", "code": "class Solution {\n    public int numMatchingSubseq(String S, String[] words) {\n        int ans = 0;\n        ArrayList<Node>[] heads = new ArrayList[26];\n        for (int i = 0; i < 26; ++i)\n            heads[i] = new ArrayList<Node>();\n\n        for (String word: words)\n            heads[word.charAt(0) - 'a'].add(new Node(word, 0));\n\n        for (char c: S.toCharArray()) {\n            ArrayList<Node> old_bucket = heads[c - 'a'];\n            heads[c - 'a'] = new ArrayList<Node>();\n\n            for (Node node: old_bucket) {\n                node.index++;\n                if (node.index == node.word.length()) {\n                    ans++;\n                } else {\n                    heads[node.word.charAt(node.index) - 'a'].add(node);\n                }\n            }\n            old_bucket.clear();\n        }\n        return ans;\n    }\n\n}\n\nclass Node {\n    String word;\n    int index;\n    public Node(String w, int i) {\n        word = w;\n        index = i;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numMatchingSubseq(self, S, words):\n        ans = 0\n        heads = [[] for _ in xrange(26)]\n        for word in words:\n            it = iter(word)\n            heads[ord(next(it)) - ord('a')].append(it)\n\n        for letter in S:\n            letter_index = ord(letter) - ord('a')\n            old_bucket = heads[letter_index]\n            heads[letter_index] = []\n\n            while old_bucket:\n                it = old_bucket.pop()\n                nxt = next(it, None)\n                if nxt:\n                    heads[ord(nxt) - ord('a')].append(it)\n                else:\n                    ans += 1\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-tic-tac-toe-state", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean validTicTacToe(String[] board) {\n        int xCount = 0, oCount = 0;\n        for (String row: board)\n            for (char c: row.toCharArray()) {\n                if (c == 'X') xCount++;\n                if (c == 'O') oCount++;\n            }\n\n        if (oCount != xCount && oCount != xCount - 1) return false;\n        if (win(board, 'X') && oCount != xCount - 1) return false;\n        if (win(board, 'O') && oCount != xCount) return false;\n        return true;\n    }\n\n    public boolean win(String[] B, char P) {\n        // B: board, P: player\n        for (int i = 0; i < 3; ++i) {\n            if (P == B[0].charAt(i) && P == B[1].charAt(i) && P == B[2].charAt(i))\n                return true;\n            if (P == B[i].charAt(0) && P == B[i].charAt(1) && P == B[i].charAt(2))\n                return true;\n        }\n        if (P == B[0].charAt(0) && P == B[1].charAt(1) && P == B[2].charAt(2))\n            return true;\n        if (P == B[0].charAt(2) && P == B[1].charAt(1) && P == B[2].charAt(0))\n            return true;\n        return false;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def validTicTacToe(self, board):\n        FIRST, SECOND = 'XO'\n        x_count = sum(row.count(FIRST) for row in board)\n        o_count = sum(row.count(SECOND) for row in board)\n\n        def win(board, player):\n            for i in xrange(3):\n                if all(board[i][j] == player for j in xrange(3)):\n                    return True\n                if all(board[j][i] == player for j in xrange(3)):\n                    return True\n\n            return (player == board[1][1] == board[0][0] == board[2][2] or\n                    player == board[1][1] == board[0][2] == board[2][0])\n\n        if o_count not in {x_count-1, x_count}: return False\n        if win(board, FIRST) and x_count-1 != o_count: return False\n        if win(board, SECOND) and x_count != o_count: return False\n\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum", "source": [{"lang": "Java", "code": "class Solution {\n    public int numSubarrayBoundedMax(int[] A, int L, int R) {\n        return count(A, R) - count(A, L-1);\n    }\n\n    public int count(int[] A, int bound) {\n        int ans = 0, cur = 0;\n        for (int x: A) {\n            cur = x <= bound ? cur + 1 : 0;\n            ans += cur;\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numSubarrayBoundedMax(self, A, L, R):\n        def count(bound):\n            ans = cur = 0\n            for x in A :\n                cur = cur + 1 if x <= bound else 0\n                ans += cur\n            return ans\n\n        return count(R) - count(L - 1)"}]}
{"url": "https://leetcode-cn.com/problems/rotate-string", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean rotateString(String A, String B) {\n        if (A.length() != B.length())\n            return false;\n        if (A.length() == 0)\n            return true;\n\n        search:\n            for (int s = 0; s < A.length(); ++s) {\n                for (int i = 0; i < A.length(); ++i) {\n                    if (A.charAt((s+i) % A.length()) != B.charAt(i))\n                        continue search;\n                }\n                return true;\n            }\n        return false;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def rotateString(self, A, B):\n        if len(A) != len(B):\n            return False\n        if len(A) == 0:\n            return True\n\n        for s in xrange(len(A)):\n            if all(A[(s+i) % len(A)] == B[i] for i in xrange(len(A))):\n                return True\n        return False"}, {"lang": "Java", "code": "class Solution {\n    public boolean rotateString(String A, String B) {\n        return A.length() == B.length() && (A + A).contains(B);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def rotateString(self, A, B):\n        return len(A) == len(B) and B in A+A"}, {"lang": "Java", "code": "import java.math.BigInteger;\nclass Solution {\n    public boolean rotateString(String A, String B) {\n        if (A.equals(B)) return true;\n\n        int MOD = 1_000_000_007;\n        int P = 113;\n        int Pinv = BigInteger.valueOf(P).modInverse(BigInteger.valueOf(MOD)).intValue();\n\n        long hb = 0, power = 1;\n        for (char x: B.toCharArray()) {\n            hb = (hb + power * x) % MOD;\n            power = power * P % MOD;\n        }\n\n        long ha = 0; power = 1;\n        char[] ca = A.toCharArray();\n        for (char x: ca) {\n            ha = (ha + power * x) % MOD;\n            power = power * P % MOD;\n        }\n\n        for (int i = 0; i < ca.length; ++i) {\n            char x = ca[i];\n            ha += power * x - x;\n            ha %= MOD;\n            ha *= Pinv;\n            ha %= MOD;\n            if (ha == hb && (A.substring(i+1) + A.substring(0, i+1)).equals(B))\n                return true;\n\n        }\n        return false;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def rotateString(self, A, B):\n        MOD = 10**9 + 7\n        P = 113\n        Pinv = pow(P, MOD-2, MOD)\n\n        hb = 0\n        power = 1\n        for x in B:\n            code = ord(x) - 96\n            hb = (hb + power * code) % MOD\n            power = power * P % MOD\n\n        ha = 0\n        power = 1\n        for x in A:\n            code = ord(x) - 96\n            ha = (ha + power * code) % MOD\n            power = power * P % MOD\n\n        if ha == hb and A == B: return True\n        for i, x in enumerate(A):\n            code = ord(x) - 96\n            ha += power * code\n            ha -= code\n            ha *= Pinv\n            ha %= MOD\n            if ha == hb and A[i+1:] + A[:i+1] == B:\n                return True\n        return False"}, {"lang": "Java", "code": "class Solution {\n    public boolean rotateString(String A, String B) {\n        int N = A.length();\n        if (N != B.length()) return false;\n        if (N == 0) return true;\n\n        //Compute shift table\n        int[] shifts = new int[N+1];\n        Arrays.fill(shifts, 1);\n        int left = -1;\n        for (int right = 0; right < N; ++right) {\n            while (left >= 0 && (B.charAt(left) != B.charAt(right)))\n                left -= shifts[left];\n            shifts[right + 1] = right - left++;\n        }\n\n        //Find match of B in A+A\n        int matchLen = 0;\n        for (char c: (A+A).toCharArray()) {\n            while (matchLen >= 0 && B.charAt(matchLen) != c)\n                matchLen -= shifts[matchLen];\n            if (++matchLen == N) return true;\n        }\n\n        return false;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def rotateString(self, A, B):\n        N = len(A)\n        if N != len(B): return False\n        if N == 0: return True\n\n        #Compute shift table\n        shifts = [1] * (N+1)\n        left = -1\n        for right in xrange(N):\n            while left >= 0 and B[left] != B[right]:\n                left -= shifts[left]\n            shifts[right + 1] = right - left\n            left += 1\n\n        #Find match of B in A+A\n        match_len = 0\n        for char in A+A:\n            while match_len >= 0 and B[match_len] != char:\n                match_len -= shifts[match_len]\n\n            match_len += 1\n            if match_len == N:\n                return True\n\n        return False"}]}
{"url": "https://leetcode-cn.com/problems/all-paths-from-source-to-target", "source": [{"lang": "Java", "code": "class Solution {\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\n        return solve(graph, 0);\n    }\n\n    public List<List<Integer>> solve(int[][] graph, int node) {\n        int N = graph.length;\n        List<List<Integer>> ans = new ArrayList();\n        if (node == N - 1) {\n            List<Integer> path = new ArrayList();\n            path.add(N-1);\n            ans.add(path);\n            return ans;\n        }\n\n        for (int nei: graph[node]) {\n            for (List<Integer> path: solve(graph, nei)) {\n                path.add(0, node);\n                ans.add(path);\n            }\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def allPathsSourceTarget(self, graph):\n        N = len(graph)\n\n        def solve(node):\n            if node == N-1: return [[N-1]]\n            ans = []\n            for nei in graph[node]:\n                for path in solve(nei):\n                    ans.append([node] + path)\n            return ans\n\n        return solve(0)"}]}
{"url": "https://leetcode-cn.com/problems/smallest-rotation-with-highest-score", "source": [{"lang": "Java", "code": "class Solution {\n    public int bestRotation(int[] A) {\n        int N = A.length;\n        int[] bad = new int[N];\n        for (int i = 0; i < N; ++i) {\n            int left = (i - A[i] + 1 + N) % N;\n            int right = (i + 1) % N;\n            bad[left]--;\n            bad[right]++;\n            if (left > right)\n                bad[0]--;\n        }\n\n        int best = -N;\n        int ans = 0, cur = 0;\n        for (int i = 0; i < N; ++i) {\n            cur += bad[i];\n            if (cur > best) {\n                best = cur;\n                ans = i;\n            }\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def bestRotation(self, A):\n        N = len(A)\n        bad = [0] * N\n        for i, x in enumerate(A):\n            left, right = (i - x + 1) % N, (i + 1) % N\n            bad[left] -= 1\n            bad[right] += 1\n            if left > right:\n                bad[0] -= 1\n\n        best = -N\n        ans = cur = 0\n        for i, score in enumerate(bad):\n            cur += score\n            if cur > best:\n                best = cur\n                ans = i\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/champagne-tower", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing", "source": []}
{"url": "https://leetcode-cn.com/problems/find-eventual-safe-states", "source": []}
{"url": "https://leetcode-cn.com/problems/bricks-falling-when-hit", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] hitBricks(int[][] grid, int[][] hits) {\n        int R = grid.length, C = grid[0].length;\n        int[] dr = {1, 0, -1, 0};\n        int[] dc = {0, 1, 0, -1};\n\n        int[][] A = new int[R][C];\n        for (int r = 0; r < R; ++r)\n            A[r] = grid[r].clone();\n        for (int[] hit: hits)\n            A[hit[0]][hit[1]] = 0;\n\n        DSU dsu = new DSU(R*C + 1);\n        for (int r = 0; r < R; ++r) {\n            for (int c = 0; c < C; ++c) {\n                if (A[r][c] == 1) {\n                    int i = r * C + c;\n                    if (r == 0)\n                        dsu.union(i, R*C);\n                    if (r > 0 && A[r-1][c] == 1)\n                        dsu.union(i, (r-1) *C + c);\n                    if (c > 0 && A[r][c-1] == 1)\n                        dsu.union(i, r * C + c-1);\n                }\n            }\n        }\n        int t = hits.length;\n        int[] ans = new int[t--];\n\n        while (t >= 0) {\n            int r = hits[t][0];\n            int c = hits[t][1];\n            int preRoof = dsu.top();\n            if (grid[r][c] == 0) {\n                t--;\n            } else {\n                int i = r * C + c;\n                for (int k = 0; k < 4; ++k) {\n                    int nr = r + dr[k];\n                    int nc = c + dc[k];\n                    if (0 <= nr && nr < R && 0 <= nc && nc < C && A[nr][nc] == 1)\n                        dsu.union(i, nr * C + nc);\n                }\n                if (r == 0)\n                    dsu.union(i, R*C);\n                A[r][c] = 1;\n                ans[t--] = Math.max(0, dsu.top() - preRoof - 1);\n            }\n        }\n\n        return ans;\n    }\n}\n\nclass DSU {\n    int[] parent;\n    int[] rank;\n    int[] sz;\n\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n        rank = new int[N];\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x), yr = find(y);\n        if (xr == yr) return;\n\n        if (rank[xr] < rank[yr]) {\n            int tmp = yr;\n            yr = xr;\n            xr = tmp;\n        }\n        if (rank[xr] == rank[yr])\n            rank[xr]++;\n\n        parent[yr] = xr;\n        sz[xr] += sz[yr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n\n    public int top() {\n        return size(sz.length - 1) - 1;\n    }\n}"}, {"lang": "Python", "code": "class DSU:\n    def __init__(self, R, C):\n        #R * C is the source, and isn't a grid square\n        self.par = range(R*C + 1)\n        self.rnk = [0] * (R*C + 1)\n        self.sz = [1] * (R*C + 1)\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\n    def top(self):\n        # Size of component at ephemeral \"source\" node at index R*C,\n        # minus 1 to not count the source itself in the size\n        return self.size(len(self.sz) - 1) - 1\n\nclass Solution(object):\n    def hitBricks(self, grid, hits):\n        R, C = len(grid), len(grid[0])\n        def index(r, c):\n            return r * C + c\n\n        def neighbors(r, c):\n            for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                if 0 <= nr < R and 0 <= nc < C:\n                    yield nr, nc\n\n        A = [row[:] for row in grid]\n        for i, j in hits:\n            A[i][j] = 0\n\n        dsu = DSU(R, C)\n        for r, row in enumerate(A):\n            for c, val in enumerate(row):\n                if val:\n                    i = index(r, c)\n                    if r == 0:\n                        dsu.union(i, R*C)\n                    if r and A[r-1][c]:\n                        dsu.union(i, index(r-1, c))\n                    if c and A[r][c-1]:\n                        dsu.union(i, index(r, c-1))\n\n        ans = []\n        for r, c in reversed(hits):\n            pre_roof = dsu.top()\n            if grid[r][c] == 0:\n                ans.append(0)\n            else:\n                i = index(r, c)\n                for nr, nc in neighbors(r, c):\n                    if A[nr][nc]:\n                        dsu.union(i, index(nr, nc))\n                if r == 0:\n                    dsu.union(i, R*C)\n                A[r][c] = 1\n                ans.append(max(0, dsu.top() - pre_roof - 1))\n        return ans[::-1]"}]}
{"url": "https://leetcode-cn.com/problems/unique-morse-code-words", "source": [{"lang": "Java", "code": "class Solution {\n    public int uniqueMorseRepresentations(String[] words) {\n        String[] MORSE = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n\n        Set<String> seen = new HashSet();\n        for (String word: words) {\n            StringBuilder code = new StringBuilder();\n            for (char c: word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def uniqueMorseRepresentations(self, words):\n        MORSE = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\n                 \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\n                 \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\n                 \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n\n        seen = {\"\".join(MORSE[ord(c) - ord('a')] for c in word)\n                for word in words}\n\n        return len(seen)"}]}
{"url": "https://leetcode-cn.com/problems/split-array-with-same-average", "source": [{"lang": "Java", "code": "sum(B) * (N - K) = sum(C) * K\n==> sum(B) * N = (sum(B) + sum(C)) * K\n==> sum(B) / K = (sum(B) + sum(C)) / N\n==> sum(B) / K = sum(A) / N"}, {"lang": "Python", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/number-of-lines-to-write-string", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] numberOfLines(int[] widths, String S) {\n        int lines = 1, width = 0;\n        for (char c: S.toCharArray()) {\n            int w = widths[c - 'a'];\n            width += w;\n            if (width > 100) {\n                lines++;\n                width = w;\n            }\n        }\n\n        return new int[]{lines, width};\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numberOfLines(self, widths, S):\n        lines, width = 1, 0\n        for c in S:\n            w = widths[ord(c) - ord('a')]\n            width += w\n            if width > 100:\n                lines += 1\n                width = w\n\n        return lines, width"}]}
{"url": "https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline", "source": [{"lang": "Java", "code": "class Solution {\n    public int maxIncreaseKeepingSkyline(int[][] grid) {\n        int N = grid.length;\n        int[] rowMaxes = new int[N];\n        int[] colMaxes = new int[N];\n\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c) {\n                rowMaxes[r] = Math.max(rowMaxes[r], grid[r][c]);\n                colMaxes[c] = Math.max(colMaxes[c], grid[r][c]);\n        }\n\n        int ans = 0;\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                ans += Math.min(rowMaxes[r], colMaxes[c]) - grid[r][c];\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maxIncreaseKeepingSkyline(self, grid):\n        row_maxes = [max(row) for row in grid]\n        col_maxes = [max(col) for col in zip(*grid)]\n\n        return sum(min(row_maxes[r], col_maxes[c]) - val\n                   for r, row in enumerate(grid)\n                   for c, val in enumerate(row))"}]}
{"url": "https://leetcode-cn.com/problems/soup-servings", "source": [{"lang": "Java", "code": "dp(i, j) = 1/4 * (dp(i - 4, y) + dp(i - 3, y - 1) + dp(i - 2, y - 2) + dp(i - 1, y - 3))"}, {"lang": "Python", "code": "dp(i, j) = 0.5   if i <= 0 and j <= 0\ndp(i, j) = 1.0   if i <= 0 and j > 0\ndp(i, j) = 0.0   if i > 0 and j <= 0"}]}
{"url": "https://leetcode-cn.com/problems/expressive-words", "source": [{"lang": "Java", "code": "class Solution {\n    public int expressiveWords(String S, String[] words) {\n        RLE R = new RLE(S);\n        int ans = 0;\n\n        search: for (String word: words) {\n            RLE R2 = new RLE(word);\n            if (!R.key.equals(R2.key)) continue;\n            for (int i = 0; i < R.counts.size(); ++i) {\n                int c1 = R.counts.get(i);\n                int c2 = R2.counts.get(i);\n                if (c1 < 3 && c1 != c2 || c1 < c2)\n                    continue search;\n            }\n            ans++;\n        }\n        return ans;\n    }\n}\n\nclass RLE {\n    String key;\n    List<Integer> counts;\n\n    public RLE(String S) {\n        StringBuilder sb = new StringBuilder();\n        counts = new ArrayList();\n\n        char[] ca = S.toCharArray();\n        int N = ca.length;\n        int prev = -1;\n        for (int i = 0; i < N; ++i) {\n            if (i == N-1 || ca[i] != ca[i+1]) {\n                sb.append(ca[i]);\n                counts.add(i - prev);\n                prev = i;\n            }\n        }\n\n        key = sb.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def expressiveWords(self, S, words):\n        def RLE(S):\n            return zip(*[(k, len(list(grp)))\n                         for k, grp in itertools.groupby(S)])\n\n        R, count = RLE(S)\n        ans = 0\n        for word in words:\n            R2, count2 = RLE(word)\n            if R2 != R: continue\n            ans += all(c1 >= max(c2, 3) or c1 == c2\n                       for c1, c2 in zip(count, count2))\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/chalkboard-xor-game", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean xorGame(int[] nums) {\n      int x = 0;\n      for (int v : nums) x ^= v;\n      return x == 0 || nums.length % 2 == 0;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def xorGame(self, nums):\n        return reduce(operator.xor, nums) == 0 or len(nums) % 2 == 0"}]}
{"url": "https://leetcode-cn.com/problems/subdomain-visit-count", "source": [{"lang": "Java", "code": "class Solution {\n    public List<String> subdomainVisits(String[] cpdomains) {\n        Map<String, Integer> counts = new HashMap();\n        for (String domain: cpdomains) {\n            String[] cpinfo = domain.split(\"\\\\s+\");\n            String[] frags = cpinfo[1].split(\"\\\\.\");\n            int count = Integer.valueOf(cpinfo[0]);\n            String cur = \"\";\n            for (int i = frags.length - 1; i >= 0; --i) {\n                cur = frags[i] + (i < frags.length - 1 ? \".\" : \"\") + cur;\n                counts.put(cur, counts.getOrDefault(cur, 0) + count);\n            }\n        }\n\n        List<String> ans = new ArrayList();\n        for (String dom: counts.keySet())\n            ans.add(\"\" + counts.get(dom) + \" \" + dom);\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def subdomainVisits(self, cpdomains):\n        ans = collections.Counter()\n        for domain in cpdomains:\n            count, domain = domain.split()\n            count = int(count)\n            frags = domain.split('.')\n            for i in xrange(len(frags)):\n                ans[\".\".join(frags[i:])] += count\n\n        return [\"{} {}\".format(ct, dom) for dom, ct in ans.items()]"}]}
{"url": "https://leetcode-cn.com/problems/largest-triangle-area", "source": [{"lang": "Java", "code": "class Solution {\n    public double largestTriangleArea(int[][] points) {\n        int N = points.length;\n        double ans = 0;\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                for (int k = j+1; k < N; ++k)\n                    ans = Math.max(ans, area(points[i], points[j], points[k]));\n        return ans;\n    }\n\n    public double area(int[] P, int[] Q, int[] R) {\n        return 0.5 * Math.abs(P[0]*Q[1] + Q[0]*R[1] + R[0]*P[1]\n                             -P[1]*Q[0] - Q[1]*R[0] - R[1]*P[0]);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def largestTriangleArea(self, points):\n        def area(p, q, r):\n            return .5 * abs(p[0]*q[1]+q[0]*r[1]+r[0]*p[1]\n                           -p[1]*q[0]-q[1]*r[0]-r[1]*p[0])\n\n        return max(area(*triangle)\n            for triangle in itertools.combinations(points, 3))"}]}
{"url": "https://leetcode-cn.com/problems/largest-sum-of-averages", "source": [{"lang": "Java", "code": "dp(i, k) = max(dp(j, k - 1) + average(j + 1, i))\ndp(i, 0) = average(0, i)"}, {"lang": "Python", "code": "dp(i, k) = max(dp(j, k - 1) + average(i, j - 1))\ndp(i, 0) = average(i, n - 1)"}]}
{"url": "https://leetcode-cn.com/problems/binary-tree-pruning", "source": [{"lang": "Java", "code": "class Solution {\n    public TreeNode pruneTree(TreeNode root) {\n        return containsOne(root) ? root : null;\n    }\n\n    public boolean containsOne(TreeNode node) {\n        if (node == null) return false;\n        boolean a1 = containsOne(node.left);\n        boolean a2 = containsOne(node.right);\n        if (!a1) node.left = null;\n        if (!a2) node.right = null;\n        return node.val == 1 || a1 || a2;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def pruneTree(self, root):\n        def containsOne(node):\n            if not node: return False\n            a1 = containsOne(node.left)\n            a2 = containsOne(node.right)\n            if not a1: node.left = None\n            if not a2: node.right = None\n            return node.val == 1 or a1 or a2\n\n        return root if containsOne(root) else None"}]}
{"url": "https://leetcode-cn.com/problems/bus-routes", "source": [{"lang": "Java", "code": "import java.awt.Point;\n\nclass Solution {\n    public int numBusesToDestination(int[][] routes, int S, int T) {\n        if (S==T) return 0;\n        int N = routes.length;\n\n        List<List<Integer>> graph = new ArrayList();\n        for (int i = 0; i < N; ++i) {\n            Arrays.sort(routes[i]);\n            graph.add(new ArrayList());\n        }\n        Set<Integer> seen = new HashSet();\n        Set<Integer> targets = new HashSet();\n        Queue<Point> queue = new ArrayDeque();\n\n        // Build the graph.  Two buses are connected if\n        // they share at least one bus stop.\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                if (intersect(routes[i], routes[j])) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n\n        // Initialize seen, queue, targets.\n        // seen represents whether a node has ever been enqueued to queue.\n        // queue handles our breadth first search.\n        // targets is the set of goal states we have.\n        for (int i = 0; i < N; ++i) {\n            if (Arrays.binarySearch(routes[i], S) >= 0) {\n                seen.add(i);\n                queue.offer(new Point(i, 0));\n            }\n            if (Arrays.binarySearch(routes[i], T) >= 0)\n                targets.add(i);\n        }\n\n        while (!queue.isEmpty()) {\n            Point info = queue.poll();\n            int node = info.x, depth = info.y;\n            if (targets.contains(node)) return depth+1;\n            for (Integer nei: graph.get(node)) {\n                if (!seen.contains(nei)) {\n                    seen.add(nei);\n                    queue.offer(new Point(nei, depth+1));\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    public boolean intersect(int[] A, int[] B) {\n        int i = 0, j = 0;\n        while (i < A.length && j < B.length) {\n            if (A[i] == B[j]) return true;\n            if (A[i] < B[j]) i++; else j++;\n        }\n        return false;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numBusesToDestination(self, routes, S, T):\n        if S == T: return 0\n        routes = map(set, routes)\n        graph = collections.defaultdict(set)\n        for i, r1 in enumerate(routes):\n            for j in xrange(i+1, len(routes)):\n                r2 = routes[j]\n                if any(r in r2 for r in r1):\n                    graph[i].add(j)\n                    graph[j].add(i)\n\n        seen, targets = set(), set()\n        for node, route in enumerate(routes):\n            if S in route: seen.add(node)\n            if T in route: targets.add(node)\n\n        queue = [(node, 1) for node in seen]\n        for node, depth in queue:\n            if node in targets: return depth\n            for nei in graph[node]:\n                if nei not in seen:\n                    seen.add(nei)\n                    queue.append((nei, depth+1))\n        return -1"}]}
{"url": "https://leetcode-cn.com/problems/ambiguous-coordinates", "source": [{"lang": "Java", "code": "class Solution { //aw\n    public List<String> ambiguousCoordinates(String S) {\n        List<String> ans = new ArrayList();\n        for (int i = 2; i < S.length()-1; ++i)\n            for (String left: make(S, 1, i))\n                for (String right: make(S, i, S.length()-1))\n                    ans.add(\"(\" + left + \", \" + right + \")\");\n        return ans;\n    }\n\n    public List<String> make(String S, int i, int j) {\n        // Make on S.substring(i, j)\n        List<String> ans = new ArrayList();\n        for (int d = 1; d <= j-i; ++d) {\n            String left = S.substring(i, i+d);\n            String right = S.substring(i+d, j);\n            if ((!left.startsWith(\"0\") || left.equals(\"0\"))\n                    && !right.endsWith(\"0\"))\n                ans.add(left + (d < j-i ? \".\" : \"\") + right);\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def ambiguousCoordinates(self, S):\n        def make(frag):\n            N = len(frag)\n            for d in xrange(1, N+1):\n                left = frag[:d]\n                right = frag[d:]\n                if ((not left.startswith('0') or left == '0')\n                        and (not right.endswith('0'))):\n                    yield left + ('.' if d != N else '') + right\n\n        S = S[1:-1]\n        return [\"({}, {})\".format(*cand)\n                for i in xrange(1, len(S))\n                for cand in itertools.product(make(S[:i]), make(S[i:]))]"}]}
{"url": "https://leetcode-cn.com/problems/linked-list-components", "source": [{"lang": "Java", "code": "class Solution {\n    public int numComponents(ListNode head, int[] G) {\n        Set<Integer> Gset = new HashSet();\n        for (int x: G) Gset.add(x);\n\n        ListNode cur = head;\n        int ans = 0;\n\n        while (cur != null) {\n            if (Gset.contains(cur.val) &&\n                    (cur.next == null || !Gset.contains(cur.next.val)))\n                ans++;\n            cur = cur.next;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numComponents(self, head, G):\n        Gset = set(G)\n        cur = head\n        ans = 0\n        while cur:\n            if (cur.val in Gset and\n                    getattr(cur.next, 'val', None) not in Gset):\n                ans += 1\n            cur = cur.next\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/race-car", "source": [{"lang": "Java", "code": "class Solution {\n    public int racecar(int target) {\n        int K = 33 - Integer.numberOfLeadingZeros(target - 1);\n        int barrier = 1 << K;\n        int[] dist = new int[2 * barrier + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[target] = 0;\n\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(\n            (a, b) -> a.steps - b.steps);\n        pq.offer(new Node(0, target));\n\n        while (!pq.isEmpty()) {\n            Node node = pq.poll();\n            int steps = node.steps, targ1 = node.target;\n            if (dist[Math.floorMod(targ1, dist.length)] > steps) continue;\n\n            for (int k = 0; k <= K; ++k) {\n                int walk = (1 << k) - 1;\n                int targ2 = walk - targ1;\n                int steps2 = steps + k + (targ2 != 0 ? 1 : 0);\n\n                if (Math.abs(targ2) <= barrier && steps2 < dist[Math.floorMod(targ2, dist.length)]) {\n                    pq.offer(new Node(steps2, targ2));\n                    dist[Math.floorMod(targ2, dist.length)] = steps2;\n                }\n            }\n        }\n\n        return dist[0];\n    }\n}\n\nclass Node {\n    int steps, target;\n    Node(int s, int t) {\n        steps = s;\n        target = t;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def racecar(self, target):\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in xrange(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \"R\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]"}, {"lang": "Java", "code": "class Solution {\n    public int racecar(int target) {\n        int[] dp = new int[target + 3];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0; dp[1] = 1; dp[2] = 4;\n\n        for (int t = 3; t <= target; ++t) {\n            int k = 32 - Integer.numberOfLeadingZeros(t);\n            if (t == (1<<k) - 1) {\n                dp[t] = k;\n                continue;\n            }\n            for (int j = 0; j < k-1; ++j)\n                dp[t] = Math.min(dp[t], dp[t - (1<<(k-1)) + (1<<j)] + k-1 + j + 2);\n            if ((1<<k) - 1 - t < t)\n                dp[t] = Math.min(dp[t], dp[(1<<k) - 1 - t] + k + 1);\n        }\n\n        return dp[target];  \n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def racecar(self, target):\n        dp = [0, 1, 4] + [float('inf')] * target\n        for t in xrange(3, target + 1):\n            k = t.bit_length()\n            if t == 2**k - 1:\n                dp[t] = k\n                continue\n            for j in xrange(k - 1):\n                dp[t] = min(dp[t], dp[t - 2**(k - 1) + 2**j] + k - 1 + j + 2)\n            if 2**k - 1 - t < t:\n                dp[t] = min(dp[t], dp[2**k - 1 - t] + k + 1)\n        return dp[target]"}]}
{"url": "https://leetcode-cn.com/problems/most-common-word", "source": [{"lang": "Java", "code": "class Solution {\n    public String mostCommonWord(String paragraph, String[] banned) {\n        paragraph += \".\";\n\n        Set<String> banset = new HashSet();\n        for (String word: banned) banset.add(word);\n        Map<String, Integer> count = new HashMap();\n\n        String ans = \"\";\n        int ansfreq = 0;\n\n        StringBuilder word = new StringBuilder();\n        for (char c: paragraph.toCharArray()) {\n            if (Character.isLetter(c)) {\n                word.append(Character.toLowerCase(c));\n            } else if (word.length() > 0) {\n                String finalword = word.toString();\n                if (!banset.contains(finalword)) {\n                    count.put(finalword, count.getOrDefault(finalword, 0) + 1);\n                    if (count.get(finalword) > ansfreq) {\n                        ans = finalword;\n                        ansfreq = count.get(finalword);\n                    }\n                }\n                word = new StringBuilder();\n            }\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def mostCommonWord(self, paragraph, banned):\n        banset = set(banned)\n        for c in \"!?',;.\":\n            paragraph = paragraph.replace(c, \" \")\n        count = collections.Counter(\n            word for word in paragraph.lower().split())\n\n        ans, best = '', 0\n        for word in count:\n            if count[word] > best and word not in banset:\n                ans, best = word, count[word]\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/short-encoding-of-words", "source": [{"lang": "Java", "code": "class Solution {\n    public int minimumLengthEncoding(String[] words) {\n        Set<String> good = new HashSet(Arrays.asList(words));\n        for (String word: words) {\n            for (int k = 1; k < word.length(); ++k)\n                good.remove(word.substring(k));\n        }\n\n        int ans = 0;\n        for (String word: good)\n            ans += word.length() + 1;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minimumLengthEncoding(self, words):\n        good = set(words)\n        for word in words:\n            for k in range(1, len(word)):\n                good.discard(word[k:])\n\n        return sum(len(word) + 1 for word in good)"}, {"lang": "Java", "code": "class Solution {\n    public int minimumLengthEncoding(String[] words) {\n        TrieNode trie = new TrieNode();\n        Map<TrieNode, Integer> nodes = new HashMap();\n\n        for (int i = 0; i < words.length; ++i) {\n            String word = words[i];\n            TrieNode cur = trie;\n            for (int j = word.length() - 1; j >= 0; --j)\n                cur = cur.get(word.charAt(j));\n            nodes.put(cur, i);\n        }\n\n        int ans = 0;\n        for (TrieNode node: nodes.keySet()) {\n            if (node.count == 0)\n                ans += words[nodes.get(node)].length() + 1;\n        }\n        return ans;\n\n    }\n}\n\nclass TrieNode {\n    TrieNode[] children;\n    int count;\n    TrieNode() {\n        children = new TrieNode[26];\n        count = 0;\n    }\n    public TrieNode get(char c) {\n        if (children[c-'a'] == null) {\n            children[c-'a'] = new TrieNode();\n            count++;\n        }\n        return children[c - 'a'];\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minimumLengthEncoding(self, words):\n        words = list(set(words)) #remove duplicates\n        #Trie is a nested dictionary with nodes created\n        # when fetched entries are missing\n        Trie = lambda: collections.defaultdict(Trie)\n        trie = Trie()\n\n        #reduce(..., S, trie) is trie[S[0]][S[1]][S[2]][...][S[S.length - 1]]\n        nodes = [reduce(dict.__getitem__, word[::-1], trie)\n                 for word in words]\n\n        #Add word to the answer if it's node has no neighbors\n        return sum(len(word) + 1\n                   for i, word in enumerate(words)\n                   if len(nodes[i]) == 0)"}]}
{"url": "https://leetcode-cn.com/problems/shortest-distance-to-a-character", "source": []}
{"url": "https://leetcode-cn.com/problems/card-flipping-game", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-trees-with-factors", "source": [{"lang": "Java", "code": "class Solution {\n    public int numFactoredBinaryTrees(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n        Arrays.sort(A);\n        long[] dp = new long[N];\n        Arrays.fill(dp, 1);\n\n        Map<Integer, Integer> index = new HashMap();\n        for (int i = 0; i < N; ++i)\n            index.put(A[i], i);\n\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < i; ++j) {\n                if (A[i] % A[j] == 0) { // A[j] is left child\n                    int right = A[i] / A[j];\n                    if (index.containsKey(right)) {\n                        dp[i] = (dp[i] + dp[j] * dp[index.get(right)]) % MOD;\n                    }\n                }\n            }\n\n        long ans = 0;\n        for (long x: dp) ans += x;\n        return (int) (ans % MOD);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numFactoredBinaryTrees(self, A):\n        MOD = 10 ** 9 + 7\n        N = len(A)\n        A.sort()\n        dp = [1] * N\n        index = {x: i for i, x in enumerate(A)}\n        for i, x in enumerate(A):\n            for j in xrange(i):\n                if x % A[j] == 0: #A[j] will be left child\n                    right = x / A[j]\n                    if right in index:\n                        dp[i] += dp[j] * dp[index[right]]\n                        dp[i] %= MOD\n\n        return sum(dp) % MOD"}]}
{"url": "https://leetcode-cn.com/problems/goat-latin", "source": [{"lang": "Java", "code": "class Solution {\n    public String toGoatLatin(String S) {\n        Set<Character> vowel = new HashSet();\n        for (char c: new char[]{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'})\n            vowel.add(c);\n\n        int t = 1;\n        StringBuilder ans = new StringBuilder();\n        for (String word: S.split(\" \")) {\n            char first = word.charAt(0);\n            if (vowel.contains(first)) {\n                ans.append(word);\n            } else {\n                ans.append(word.substring(1));\n                ans.append(word.substring(0, 1));\n            }\n            ans.append(\"ma\");\n            for (int i = 0; i < t; i++)\n                ans.append(\"a\");\n            t++;\n            ans.append(\" \");\n        }\n\n        ans.deleteCharAt(ans.length() - 1);\n        return ans.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def toGoatLatin(self, S):\n\n        def convert(word):\n            if word[0] not in 'aeiouAEIOU':\n                word = word[1:] + word[:1]\n            return word + 'ma'\n\n        return \" \".join(convert(word) + 'a' * i\n                        for i, word in enumerate(S.split(), 1))"}]}
{"url": "https://leetcode-cn.com/problems/friends-of-appropriate-ages", "source": []}
{"url": "https://leetcode-cn.com/problems/most-profit-assigning-work", "source": [{"lang": "Java", "code": "import java.awt.Point;\n\nclass Solution {\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\n        int N = difficulty.length;\n        Point[] jobs = new Point[N];\n        for (int i = 0; i < N; ++i)\n            jobs[i] = new Point(difficulty[i], profit[i]);\n        Arrays.sort(jobs, (a, b) -> a.x - b.x);\n        Arrays.sort(worker);\n\n        int ans = 0, i = 0, best = 0;\n        for (int skill: worker) {\n            while (i < N && skill >= jobs[i].x)\n                best = Math.max(best, jobs[i++].y);\n            ans += best;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maxProfitAssignment(self, difficulty, profit, worker):\n        jobs = zip(difficulty, profit)\n        jobs.sort()\n        ans = i = best = 0\n        for skill in sorted(worker):\n            while i < len(jobs) and skill >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            ans += best\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/making-a-large-island", "source": [{"lang": "Java", "code": "class Solution {\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n\n    public int largestIsland(int[][] grid) {\n        int N = grid.length;\n\n        int ans = 0;\n        boolean hasZero = false;\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 0) {\n                    hasZero = true;\n                    grid[r][c] = 1;\n                    ans = Math.max(ans, check(grid, r, c));\n                    grid[r][c] = 0;\n                }\n\n        return hasZero ? ans : N*N;\n    }\n\n    public int check(int[][] grid, int r0, int c0) {\n        int N = grid.length;\n        Stack<Integer> stack = new Stack();\n        Set<Integer> seen = new HashSet();\n        stack.push(r0 * N + c0);\n        seen.add(r0 * N + c0);\n\n        while (!stack.isEmpty()) {\n            int code = stack.pop();\n            int r = code / N, c = code % N;\n            for (int k = 0; k < 4; ++k) {\n                int nr = r + dr[k], nc = c + dc[k];\n                if (!seen.contains(nr * N + nc) && 0 <= nr && nr < N &&\n                        0 <= nc && nc < N && grid[nr][nc] == 1) {\n                    stack.push(nr * N + nc);\n                    seen.add(nr * N + nc);\n                }\n            }\n        }\n\n        return seen.size();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def largestIsland(self, grid):\n        N = len(grid)\n\n        def check(r, c):\n            seen = {(r, c)}\n            stack = [(r, c)]\n            while stack:\n                r, c = stack.pop()\n                for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):\n                    if (nr, nc) not in seen and 0 <= nr < N and 0 <= nc < N and grid[nr][nc]:\n                        stack.append((nr, nc))\n                        seen.add((nr, nc))\n            return len(seen)\n\n        ans = 0\n        has_zero = False\n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                if val == 0:\n                    has_zero = True\n                    grid[r][c] = 1\n                    ans = max(ans, check(r, c))\n                    grid[r][c] = 0\n\n        return ans if has_zero else N*N"}, {"lang": "Java", "code": "class Solution {\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n    int[][] grid;\n    int N;\n\n    public int largestIsland(int[][] grid) {\n        this.grid = grid;\n        N = grid.length;\n\n        int index = 2;\n        int[] area = new int[N*N + 2];\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 1)\n                    area[index] = dfs(r, c, index++);\n\n        int ans = 0;\n        for (int x: area) ans = Math.max(ans, x);\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 0) {\n                    Set<Integer> seen = new HashSet();\n                    for (Integer move: neighbors(r, c))\n                        if (grid[move / N][move % N] > 1)\n                            seen.add(grid[move / N][move % N]);\n\n                    int bns = 1;\n                    for (int i: seen) bns += area[i];\n                    ans = Math.max(ans, bns);\n                }\n\n        return ans;\n    }\n\n    public int dfs(int r, int c, int index) {\n        int ans = 1;\n        grid[r][c] = index;\n        for (Integer move: neighbors(r, c)) {\n            if (grid[move / N][move % N] == 1) {\n                grid[move / N][move % N] = index;\n                ans += dfs(move / N, move % N, index);\n            }\n        }\n\n        return ans;\n    }\n\n    public List<Integer> neighbors(int r, int c) {\n        List<Integer> ans = new ArrayList();\n        for (int k = 0; k < 4; ++k) {\n            int nr = r + dr[k];\n            int nc = c + dc[k];\n            if (0 <= nr && nr < N && 0 <= nc && nc < N)\n                ans.add(nr * N + nc);\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def largestIsland(self, grid):\n        N = len(grid)\n\n        def neighbors(r, c):\n            for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                if 0 <= nr < N and 0 <= nc < N:\n                    yield nr, nc\n\n        def dfs(r, c, index):\n            ans = 1\n            grid[r][c] = index\n            for nr, nc in neighbors(r, c):\n                if grid[nr][nc] == 1:\n                    ans += dfs(nr, nc, index)\n            return ans\n\n        area = {}\n        index = 2\n        for r in xrange(N):\n            for c in xrange(N):\n                if grid[r][c] == 1:\n                    area[index] = dfs(r, c, index)\n                    index += 1\n\n        ans = max(area.values() or [0])\n        for r in xrange(N):\n            for c in xrange(N):\n                if grid[r][c] == 0:\n                    seen = {grid[nr][nc] for nr, nc in neighbors(r, c) if grid[nr][nc] > 1}\n                    ans = max(ans, 1 + sum(area[i] for i in seen))\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/unique-letter-string", "source": [{"lang": "Java", "code": "class Solution {\n    Map<Character, List<Integer>> index;\n    int[] peek;\n    int N;\n\n    public int uniqueLetterString(String S) {\n        index = new HashMap();\n        peek = new int[26];\n        N = S.length();\n\n        for (int i = 0; i < S.length(); ++i) {\n            char c = S.charAt(i);\n            index.computeIfAbsent(c, x-> new ArrayList<Integer>()).add(i);\n        }\n\n        long cur = 0, ans = 0;\n        for (char c: index.keySet()) {\n            index.get(c).add(N);\n            index.get(c).add(N);\n            cur += get(c);\n        }\n\n        for (char c: S.toCharArray()) {\n            ans += cur;\n            long oldv = get(c);\n            peek[c - 'A']++;\n            cur += get(c) - oldv;\n        }\n        return (int) ans % 1_000_000_007;\n    }\n\n    public long get(char c) {\n        List<Integer> indexes = index.get(c);\n        int i = peek[c - 'A'];\n        return indexes.get(i+1) - indexes.get(i);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def uniqueLetterString(self, S):\n        N = len(S)\n        index = collections.defaultdict(list)\n        peek = collections.defaultdict(int)\n        for i, c in enumerate(S):\n            index[c].append(i)\n        for c in index:\n            index[c].extend([N, N])\n\n        def get(c):\n            return index[c][peek[c] + 1] - index[c][peek[c]]\n\n        ans = 0\n        cur = sum(get(c) for c in index)\n        for i, c in enumerate(S):\n            ans += cur\n            oldv = get(c)\n            peek[c] += 1\n            cur += get(c) - oldv\n        return ans % (10**9 + 7)"}, {"lang": "Java", "code": "class Solution {\n    public int uniqueLetterString(String S) {\n        Map<Character, List<Integer>> index = new HashMap();\n        for (int i = 0; i < S.length(); ++i) {\n            char c = S.charAt(i);\n            index.computeIfAbsent(c, x-> new ArrayList<Integer>()).add(i);\n        }\n\n        long ans = 0;\n        for (List<Integer> A: index.values()) {\n            for (int i = 0; i < A.size(); ++i) {\n                long prev = i > 0 ? A.get(i-1) : -1;\n                long next = i < A.size() - 1 ? A.get(i+1) : S.length();\n                ans += (A.get(i) - prev) * (next - A.get(i));\n            }\n        }\n\n        return (int) ans % 1_000_000_007;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def uniqueLetterString(self, S):\n        index = collections.defaultdict(list)\n        for i, c in enumerate(S):\n            index[c].append(i)\n\n        ans = 0\n        for A in index.values():\n            A = [-1] + A + [len(S)]\n            for i in xrange(1, len(A) - 1):\n                ans += (A[i] - A[i-1]) * (A[i+1] - A[i])\n        return ans % (10**9 + 7)"}]}
{"url": "https://leetcode-cn.com/problems/consecutive-numbers-sum", "source": [{"lang": "Java", "code": "class Solution {\n    public int consecutiveNumbersSum(int N) {\n        int ans = 0;\n        for (int start = 1; start <= N; ++start) {\n            int target = N, x = start;\n            while (target > 0)\n                target -= x++;\n            if (target == 0) ans++;\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def consecutiveNumbersSum(self, N):\n        ans = 0\n        for start in xrange(1, N+1):\n            target = N\n            while target > 0:\n                target -= start\n                start += 1\n            if target == 0: ans += 1\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int consecutiveNumbersSum(int N) {\n        // 2N = k(2x + k + 1)\n        int ans = 0;\n        for (int k = 1; k <= 2*N; ++k)\n            if (2 * N % k == 0) {\n                int y = 2 * N / k - k - 1;\n                if (y % 2 == 0 && y >= 0)\n                    ans++;\n            }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def consecutiveNumbersSum(self, N):\n        # 2N = k(2x + k + 1)\n        ans = 0\n        for k in xrange(1, 2*N + 1):\n            if 2*N % k == 0:\n                y = 2 * N / k - k - 1\n                if y % 2 == 0 and y >= 0:\n                    ans += 1\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int consecutiveNumbersSum(int N) {\n        while ((N & 1) == 0) N >>= 1;\n        int ans = 1, d = 3;\n\n        while (d * d <= N) {\n            int e = 0;\n            while (N % d == 0) {\n                N /= d;\n                e++;\n            }\n            ans *= e + 1;\n            d += 2;\n        }\n\n        if (N > 1) ans <<= 1;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def consecutiveNumbersSum(self, N):\n        while N & 1 == 0:\n            N >>= 1\n\n        ans = 1    \n        d = 3\n        while d * d <= N:\n            e = 0\n            while N % d == 0:\n                N /= d\n                e += 1\n            ans *= e + 1\n            d += 2\n\n        if N > 1: ans *= 2\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/positions-of-large-groups", "source": [{"lang": "Java", "code": "class Solution {\n    public List<List<Integer>> largeGroupPositions(String S) {\n        List<List<Integer>> ans = new ArrayList();\n        int i = 0, N = S.length(); // i is the start of each group\n        for (int j = 0; j < N; ++j) {\n            if (j == N-1 || S.charAt(j) != S.charAt(j+1)) {\n                // Here, [i, j] represents a group.\n                if (j-i+1 >= 3)\n                    ans.add(Arrays.asList(new Integer[]{i, j}));\n                i = j + 1;\n            }\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def largeGroupPositions(self, S):\n        ans = []\n        i = 0 # The start of each group\n        for j in xrange(len(S)):\n            if j == len(S) - 1 or S[j] != S[j+1]:\n                # Here, [i, j] represents a group.\n                if j-i+1 >= 3:\n                    ans.append([i, j])\n                i = j+1\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/masking-personal-information", "source": [{"lang": "Java", "code": "class Solution {\n    public String maskPII(String S) {\n        int atIndex = S.indexOf('@');\n        if (atIndex >= 0) { // email\n            return (S.substring(0, 1) + \"*****\" + S.substring(atIndex - 1)).toLowerCase();\n        } else { // phone\n            String digits = S.replaceAll(\"\\\\D+\", \"\");\n            String local = \"***-***-\" + digits.substring(digits.length() - 4);\n            if (digits.length() == 10) return local;\n            String ans = \"+\";\n            for (int i = 0; i < digits.length() - 10; ++i)\n                ans += \"*\";\n            return ans + \"-\" + local;\n        }\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maskPII(self, S):\n        if '@' in S: #email\n            first, after = S.split('@')\n            return \"{}*****{}@{}\".format(\n                first[0], first[-1], after).lower()\n\n        else: #phone\n            digits = filter(unicode.isdigit, S)\n            local = \"***-***-{}\".format(digits[-4:])\n            if len(digits) == 10:\n                return local\n            return \"+{}-\".format('*' * (len(digits) - 10)) + local"}]}
{"url": "https://leetcode-cn.com/problems/flipping-an-image", "source": [{"lang": "Java", "code": "class Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int C = A[0].length;\n        for (int[] row: A)\n            for (int i = 0; i < (C + 1) / 2; ++i) {\n                int tmp = row[i] ^ 1;\n                row[i] = row[C - 1 - i] ^ 1;\n                row[C - 1 - i] = tmp;\n            }\n\n        return A;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def flipAndInvertImage(self, A):\n        for row in A:\n            for i in xrange((len(row) + 1) / 2):\n                \"\"\"\n                In Python, the shortcut row[~i] = row[-i-1] = row[len(row) - 1 - i]\n                helps us find the i-th value of the row, counting from the right.\n                \"\"\"\n                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1\n        return A"}]}
{"url": "https://leetcode-cn.com/problems/find-and-replace-in-string", "source": []}
{"url": "https://leetcode-cn.com/problems/sum-of-distances-in-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/image-overlap", "source": []}
{"url": "https://leetcode-cn.com/problems/rectangle-overlap", "source": []}
{"url": "https://leetcode-cn.com/problems/new-21-game", "source": []}
{"url": "https://leetcode-cn.com/problems/push-dominoes", "source": [{"lang": "Java", "code": "class Solution {\n    public String pushDominoes(String dominoes) {\n        int N = dominoes.length();\n        int[] indexes = new int[N+2];\n        char[] symbols = new char[N+2];\n        int len = 1;\n        indexes[0] = -1;\n        symbols[0] = 'L';\n\n        for (int i = 0; i < N; ++i)\n            if (dominoes.charAt(i) != '.') {\n                indexes[len] = i;\n                symbols[len++] = dominoes.charAt(i);\n            }\n\n        indexes[len] = N;\n        symbols[len++] = 'R';\n\n        char[] ans = dominoes.toCharArray();\n        for (int index = 0; index < len - 1; ++index) {\n            int i = indexes[index], j = indexes[index+1];\n            char x = symbols[index], y = symbols[index+1];\n            char write;\n            if (x == y) {\n                for (int k = i+1; k < j; ++k)\n                    ans[k] = x;\n            } else if (x > y) { // RL\n                for (int k = i+1; k < j; ++k)\n                    ans[k] = k-i == j-k ? '.' : k-i < j-k ? 'R' : 'L';\n            }\n        }\n\n        return String.valueOf(ans);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def pushDominoes(self, dominoes):\n        symbols = [(i, x) for i, x in enumerate(dominoes) if x != '.']\n        symbols = [(-1, 'L')] + symbols + [(len(dominoes), 'R')]\n\n        ans = list(dominoes)\n        for (i, x), (j, y) in zip(symbols, symbols[1:]):\n            if x == y:\n                for k in xrange(i+1, j):\n                    ans[k] = x\n            elif x > y: #RL\n                for k in xrange(i+1, j):\n                    ans[k] = '.LR'[cmp(k-i, j-k)]\n\n        return \"\".join(ans)"}, {"lang": "Java", "code": "class Solution {\n    public String pushDominoes(String S) {\n        char[] A = S.toCharArray();\n        int N = A.length;\n        int[] forces = new int[N];\n\n        // Populate forces going from left to right\n        int force = 0;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 'R') force = N;\n            else if (A[i] == 'L') force = 0;\n            else force = Math.max(force - 1, 0);\n            forces[i] += force;\n        }\n\n        // Populate forces going from right to left\n        force = 0;\n        for (int i = N-1; i >= 0; --i) {\n            if (A[i] == 'L') force = N;\n            else if (A[i] == 'R') force = 0;\n            else force = Math.max(force - 1, 0);\n            forces[i] -= force;\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (int f: forces)\n            ans.append(f > 0 ? 'R' : f < 0 ? 'L' : '.');\n        return ans.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def pushDominoes(self, dominoes):\n        N = len(dominoes)\n        force = [0] * N\n\n        # Populate forces going from left to right\n        f = 0\n        for i in xrange(N):\n            if dominoes[i] == 'R': f = N\n            elif dominoes[i] == 'L': f = 0\n            else: f = max(f-1, 0)\n            force[i] += f\n\n        # Populate forces going from right to left\n        f = 0\n        for i in xrange(N-1, -1, -1):\n            if dominoes[i] == 'L': f = N\n            elif dominoes[i] == 'R': f = 0\n            else: f = max(f-1, 0)\n            force[i] -= f\n\n        return \"\".join('.' if f==0 else 'R' if f > 0 else 'L'\n                       for f in force)"}]}
{"url": "https://leetcode-cn.com/problems/similar-string-groups", "source": [{"lang": "Java", "code": "class Solution {\n    public int numSimilarGroups(String[] A) {\n        int N = A.length;\n        int W = A[0].length();\n        DSU dsu = new DSU(N);\n\n        if (N < W*W) { // If few words, then check for pairwise similarity: O(N^2 W)\n            for (int i = 0; i < N; ++i)\n                for (int j = i+1; j < N; ++j)\n                    if (similar(A[i], A[j]))\n                        dsu.union(i, j);\n\n        } else { // If short words, check all neighbors: O(N W^3)\n            Map<String, List<Integer>> buckets = new HashMap();\n            for (int i = 0; i < N; ++i) {\n                char[] L = A[i].toCharArray();\n                for (int j0 = 0; j0 < L.length; ++j0)\n                    for (int j1 = j0 + 1; j1 < L.length; ++j1) {\n                        swap(L, j0, j1);\n                        StringBuilder sb = new StringBuilder();\n                        for (char c: L) sb.append(c);\n                        buckets.computeIfAbsent(sb.toString(),\n                                x-> new ArrayList<Integer>()).add(i);\n                        swap(L, j0, j1);\n                    }\n            }\n\n            for (int i1 = 0; i1 < A.length; ++i1)\n                if (buckets.containsKey(A[i1]))\n                    for (int i2: buckets.get(A[i1]))\n                        dsu.union(i1, i2);\n        }\n\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            if (dsu.parent[i] == i) ans++;\n\n        return ans;\n    }\n\n    public boolean similar(String word1, String word2) {\n        int diff = 0;\n        for (int i = 0; i < word1.length(); ++i)\n            if (word1.charAt(i) != word2.charAt(i))\n                diff++;\n        return diff <= 2;\n    }\n\n    public void swap(char[] A, int i, int j) {\n        char tmp = A[i];\n        A[i] = A[j];\n        A[j] = tmp;\n    }\n}\n\nclass DSU {\n    int[] parent;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}"}, {"lang": "Python", "code": "class DSU:\n    def __init__(self, N):\n        self.par = range(N)\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    def union(self, x, y):\n        self.par[self.find(x)] = self.find(y)\n\nclass Solution(object): # (NW) * min(N, W*W) complexity\n    def numSimilarGroups(self, A):\n        N, W = len(A), len(A[0])\n\n        def similar(word1, word2):\n            diff = 0\n            for x, y in itertools.izip(word1, word2):\n                if x != y:\n                    diff += 1\n            return diff <= 2\n\n        dsu = DSU(N)\n\n        if N < W*W: # If few words, then check for pairwise similarity: O(N^2 W)\n            for (i1, word1), (i2, word2) in \\\n                    itertools.combinations(enumerate(A), 2):\n                if similar(word1, word2):\n                    dsu.union(i1, i2)\n\n        else: # If short words, check all neighbors: O(N W^3)\n            buckets = collections.defaultdict(set)\n            for i, word in enumerate(A):\n                L = list(word)\n                for j0, j1 in itertools.combinations(xrange(W), 2):\n                    L[j0], L[j1] = L[j1], L[j0]\n                    buckets[\"\".join(L)].add(i)\n                    L[j0], L[j1] = L[j1], L[j0]\n\n            for i1, word in enumerate(A):\n                for i2 in buckets[word]:\n                    dsu.union(i1, i2)\n\n        return sum(dsu.par[x] == x for x in xrange(N))"}]}
{"url": "https://leetcode-cn.com/problems/magic-squares-in-grid", "source": [{"lang": "Java", "code": "class Solution {\n    public int numMagicSquaresInside(int[][] grid) {\n        int R = grid.length, C = grid[0].length;\n        int ans = 0;\n        for (int r = 0; r < R-2; ++r)\n            for (int c = 0; c < C-2; ++c) {\n                if (grid[r+1][c+1] != 5) continue;  // optional skip\n                if (magic(grid[r][c], grid[r][c+1], grid[r][c+2],\n                          grid[r+1][c], grid[r+1][c+1], grid[r+1][c+2],\n                          grid[r+2][c], grid[r+2][c+1], grid[r+2][c+2]))\n                    ans++;\n            }\n\n        return ans;\n    }\n\n    public boolean magic(int... vals) {\n        int[] count = new int[16];\n        for (int v: vals) count[v]++;\n        for (int v = 1; v <= 9; ++v)\n            if (count[v] != 1)\n                return false;\n\n        return (vals[0] + vals[1] + vals[2] == 15 &&\n                vals[3] + vals[4] + vals[5] == 15 &&\n                vals[6] + vals[7] + vals[8] == 15 &&\n                vals[0] + vals[3] + vals[6] == 15 &&\n                vals[1] + vals[4] + vals[7] == 15 &&\n                vals[2] + vals[5] + vals[8] == 15 &&\n                vals[0] + vals[4] + vals[8] == 15 &&\n                vals[2] + vals[4] + vals[6] == 15);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numMagicSquaresInside(self, grid):\n        R, C = len(grid), len(grid[0])\n\n        def magic(a,b,c,d,e,f,g,h,i):\n            return (sorted([a,b,c,d,e,f,g,h,i]) == range(1, 10) and\n                (a+b+c == d+e+f == g+h+i == a+d+g ==\n                 b+e+h == c+f+i == a+e+i == c+e+g == 15))\n\n        ans = 0\n        for r in xrange(R-2):\n            for c in xrange(C-2):\n                if grid[r+1][c+1] != 5: continue  # optional skip\n                if magic(grid[r][c], grid[r][c+1], grid[r][c+2],\n                         grid[r+1][c], grid[r+1][c+1], grid[r+1][c+2],\n                         grid[r+2][c], grid[r+2][c+1], grid[r+2][c+2]):\n                    ans += 1\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/keys-and-rooms", "source": []}
{"url": "https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence", "source": []}
{"url": "https://leetcode-cn.com/problems/guess-the-word", "source": [{"lang": "Java", "code": "class Solution {\n    int[][] H;\n    public void findSecretWord(String[] wordlist, Master master) {\n        int N = wordlist.length;\n        H = new int[N][N];\n        for (int i = 0; i < N; ++i)\n            for (int j = i; j < N; ++j) {\n                int match = 0;\n                for (int k = 0; k < 6; ++k)\n                    if (wordlist[i].charAt(k) == wordlist[j].charAt(k))\n                        match++;\n                H[i][j] = H[j][i] = match;\n            }\n\n        List<Integer> possible = new ArrayList();\n        List<Integer> path = new ArrayList();\n        for (int i = 0; i < N; ++i) possible.add(i);\n\n        while (!possible.isEmpty()) {\n            int guess = solve(possible, path);\n            int matches = master.guess(wordlist[guess]);\n            if (matches == wordlist[0].length()) return;\n            List<Integer> possible2 = new ArrayList();\n            for (Integer j: possible) if (H[guess][j] == matches) possible2.add(j);\n            possible = possible2;\n            path.add(guess);\n        }\n\n    }\n\n    public int solve(List<Integer> possible, List<Integer> path) {\n        if (possible.size() <= 2) return possible.get(0);\n        List<Integer> ansgrp = possible;\n        int ansguess = -1;\n\n        for (int guess = 0; guess < H.length; ++guess) {\n            if (!path.contains(guess)) {\n                ArrayList<Integer>[] groups = new ArrayList[7];\n                for (int i = 0; i < 7; ++i) groups[i] = new ArrayList<Integer>();\n                for (Integer j: possible) if (j != guess) {\n                    groups[H[guess][j]].add(j);\n                }\n\n                ArrayList<Integer> maxgroup = groups[0];\n                for (int i = 0; i < 7; ++i)\n                    if (groups[i].size() > maxgroup.size())\n                        maxgroup = groups[i];\n\n                if (maxgroup.size() < ansgrp.size()) {\n                    ansgrp = maxgroup;\n                    ansguess = guess;\n                }\n            }\n        }\n\n        return ansguess;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def findSecretWord(self, wordlist, master):\n        N = len(wordlist)\n        self.H = [[sum(a==b for a,b in itertools.izip(wordlist[i], wordlist[j]))\n                   for j in xrange(N)] for i in xrange(N)]\n\n        possible, path = range(N), ()\n        while possible:\n            guess = self.solve(possible, path)\n            matches = master.guess(wordlist[guess])\n            if matches == len(wordlist[0]): return\n            possible = [j for j in possible if self.H[guess][j] == matches]\n            path = path + (guess,)\n\n    def solve(self, possible, path = ()):\n        if len(possible) <= 2: return possible[0]\n\n        ansgrp, ansguess = possible, None\n        for guess, row in enumerate(self.H):\n            if guess not in path:\n                groups = [[] for _ in xrange(7)]\n                for j in possible:\n                    if j != guess:\n                        groups[row[j]].append(j)\n                maxgroup = max(groups, key = len)\n                if len(maxgroup) < len(ansgrp):\n                    ansgrp, ansguess = maxgroup, guess\n\n        return ansguess"}]}
{"url": "https://leetcode-cn.com/problems/backspace-string-compare", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean backspaceCompare(String S, String T) {\n        return build(S).equals(build(T));\n    }\n\n    public String build(String S) {\n        Stack<Character> ans = new Stack();\n        for (char c: S.toCharArray()) {\n            if (c != '#')\n                ans.push(c);\n            else if (!ans.empty())\n                ans.pop();\n        }\n        return String.valueOf(ans);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def backspaceCompare(self, S, T):\n        def build(S):\n            ans = []\n            for c in S:\n                if c != '#':\n                    ans.append(c)\n                elif ans:\n                    ans.pop()\n            return \"\".join(ans)\n        return build(S) == build(T)"}, {"lang": "Java", "code": "class Solution {\n    public boolean backspaceCompare(String S, String T) {\n        int i = S.length() - 1, j = T.length() - 1;\n        int skipS = 0, skipT = 0;\n\n        while (i >= 0 || j >= 0) { // While there may be chars in build(S) or build (T)\n            while (i >= 0) { // Find position of next possible char in build(S)\n                if (S.charAt(i) == '#') {skipS++; i--;}\n                else if (skipS > 0) {skipS--; i--;}\n                else break;\n            }\n            while (j >= 0) { // Find position of next possible char in build(T)\n                if (T.charAt(j) == '#') {skipT++; j--;}\n                else if (skipT > 0) {skipT--; j--;}\n                else break;\n            }\n            // If two actual characters are different\n            if (i >= 0 && j >= 0 && S.charAt(i) != T.charAt(j))\n                return false;\n            // If expecting to compare char vs nothing\n            if ((i >= 0) != (j >= 0))\n                return false;\n            i--; j--;\n        }\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def backspaceCompare(self, S, T):\n        def F(S):\n            skip = 0\n            for x in reversed(S):\n                if x == '#':\n                    skip += 1\n                elif skip:\n                    skip -= 1\n                else:\n                    yield x\n\n        return all(x == y for x, y in itertools.izip_longest(F(S), F(T)))"}]}
{"url": "https://leetcode-cn.com/problems/longest-mountain-in-array", "source": []}
{"url": "https://leetcode-cn.com/problems/hand-of-straights", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean isNStraightHand(int[] hand, int W) {\n        TreeMap<Integer, Integer> count = new TreeMap();\n        for (int card: hand) {\n            if (!count.containsKey(card))\n                count.put(card, 1);\n            else\n                count.replace(card, count.get(card) + 1);\n        }\n\n        while (count.size() > 0) {\n            int first = count.firstKey();\n            for (int card = first; card < first + W; ++card) {\n                if (!count.containsKey(card)) return false;\n                int c = count.get(card);\n                if (c == 1) count.remove(card);\n                else count.replace(card, c - 1);\n            }\n        }\n\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isNStraightHand(self, hand, W):\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in xrange(m, m+W):\n                v = count[k]\n                if not v: return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes", "source": []}
{"url": "https://leetcode-cn.com/problems/shifting-letters", "source": [{"lang": "Java", "code": "class Solution {\n    public String shiftingLetters(String S, int[] shifts) {\n        StringBuilder ans = new StringBuilder();\n        int X = 0;\n        for (int shift: shifts)\n            X = (X + shift) % 26;\n\n        for (int i = 0; i < S.length(); ++i) {\n            int index = S.charAt(i) - 'a';\n            ans.append((char) ((index + X) % 26 + 97));\n            X = Math.floorMod(X - shifts[i], 26);\n        }\n\n        return ans.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def shiftingLetters(self, S, shifts):\n        ans = []\n        X = sum(shifts) % 26\n        for i, c in enumerate(S):\n            index = ord(c) - ord('a')\n            ans.append(chr(ord('a') + (index + X) % 26))\n            X = (X - shifts[i]) % 26\n\n        return \"\".join(ans)"}]}
{"url": "https://leetcode-cn.com/problems/maximize-distance-to-closest-person", "source": []}
{"url": "https://leetcode-cn.com/problems/rectangle-area-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/loud-and-rich", "source": [{"lang": "Java", "code": "class Solution {\n    ArrayList<Integer>[] graph;\n    int[] answer;\n    int[] quiet;\n\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        int N = quiet.length;\n        graph = new ArrayList[N];\n        answer = new int[N];\n        this.quiet = quiet;\n\n        for (int node = 0; node < N; ++node)\n            graph[node] = new ArrayList<Integer>();\n\n        for (int[] edge: richer)\n            graph[edge[1]].add(edge[0]);\n\n        Arrays.fill(answer, -1);\n\n        for (int node = 0; node < N; ++node)\n            dfs(node);\n        return answer;\n    }\n\n    public int dfs(int node) {\n        if (answer[node] == -1) {\n            answer[node] = node;\n            for (int child: graph[node]) {\n                int cand = dfs(child);\n                if (quiet[cand] < quiet[answer[node]])\n                    answer[node] = cand;\n            }\n        }\n        return answer[node];\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def loudAndRich(self, richer, quiet):\n        N = len(quiet)\n        graph = [[] for _ in xrange(N)]\n        for u, v in richer:\n            graph[v].append(u)\n\n        answer = [None] * N\n        def dfs(node):\n            #Want least quiet person in this subtree\n            if answer[node] is None:\n                answer[node] = node\n                for child in graph[node]:\n                    cand = dfs(child)\n                    if quiet[cand] < quiet[answer[node]]:\n                        answer[node] = cand\n            return answer[node]\n\n        return map(dfs, range(N))"}]}
{"url": "https://leetcode-cn.com/problems/peak-index-in-a-mountain-array", "source": [{"lang": "Java", "code": "class Solution {\n    public int peakIndexInMountainArray(int[] A) {\n        int i = 0;\n        while (A[i] < A[i+1]) i++;\n        return i;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def peakIndexInMountainArray(self, A):\n        for i in xrange(len(A)):\n            if A[i] > A[i+1]:\n                return i"}, {"lang": "Java", "code": "class Solution {\n    public int peakIndexInMountainArray(int[] A) {\n        int lo = 0, hi = A.length - 1;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A[mi] < A[mi + 1])\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        return lo;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def peakIndexInMountainArray(self, A):\n        lo, hi = 0, len(A) - 1\n        while lo < hi:\n            mi = (lo + hi) / 2\n            if A[mi] < A[mi + 1]:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo"}]}
{"url": "https://leetcode-cn.com/problems/car-fleet", "source": [{"lang": "Java", "code": "class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        int N = position.length;\n        Car[] cars = new Car[N];\n        for (int i = 0; i < N; ++i)\n            cars[i] = new Car(position[i], (double) (target - position[i]) / speed[i]);\n        Arrays.sort(cars, (a, b) -> Integer.compare(a.position, b.position));\n\n        int ans = 0, t = N;\n        while (--t > 0) {\n            if (cars[t].time < cars[t-1].time) ans++; //if cars[t] arrives sooner, it can't be caught\n            else cars[t-1] = cars[t]; //else, cars[t-1] arrives at same time as cars[t]\n        }\n\n        return ans + (t == 0 ? 1 : 0); //lone car is fleet (if it exists)\n    }\n}\n\nclass Car {\n    int position;\n    double time;\n    Car(int p, double t) {\n        position = p;\n        time = t;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def carFleet(self, target, position, speed):\n        cars = sorted(zip(position, speed))\n        times = [float(target - p) / s for p, s in cars]\n        ans = 0\n        while len(times) > 1:\n            lead = times.pop()\n            if lead < times[-1]: ans += 1  # if lead arrives sooner, it can't be caught\n            else: times[-1] = lead # else, fleet arrives at later time 'lead'\n\n        return ans + bool(times) # remaining car is fleet (if it exists)"}]}
{"url": "https://leetcode-cn.com/problems/k-similar-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/exam-room", "source": [{"lang": "Java", "code": "class ExamRoom {\n    int N;\n    TreeSet<Integer> students;\n\n    public ExamRoom(int N) {\n        this.N = N;\n        students = new TreeSet();\n    }\n\n    public int seat() {\n        //Let's determine student, the position of the next\n        //student to sit down.\n        int student = 0;\n        if (students.size() > 0) {\n            //Tenatively, dist is the distance to the closest student,\n            //which is achieved by sitting in the position 'student'.\n            //We start by considering the left-most seat.\n            int dist = students.first();\n            Integer prev = null;\n            for (Integer s: students) {\n                if (prev != null) {\n                    //For each pair of adjacent students in positions (prev, s),\n                    //d is the distance to the closest student;\n                    //achieved at position prev + d.\n                    int d = (s - prev) / 2;\n                    if (d > dist) {\n                        dist = d;\n                        student = prev + d;\n                    }\n                }\n                prev = s;\n            }\n\n            //Considering the right-most seat.\n            if (N - 1 - students.last() > dist)\n                student = N - 1;\n        }\n\n        //Add the student to our sorted TreeSet of positions.\n        students.add(student);\n        return student;\n    }\n\n    public void leave(int p) {\n        students.remove(p);\n    }\n}"}, {"lang": "Python", "code": "class ExamRoom(object):\n    def __init__(self, N):\n        self.N = N\n        self.students = []\n\n    def seat(self):\n        # Let's determine student, the position of the next\n        # student to sit down.\n        if not self.students:\n            student = 0\n        else:\n            # Tenatively, dist is the distance to the closest student,\n            # which is achieved by sitting in the position 'student'.\n            # We start by considering the left-most seat.\n            dist, student = self.students[0], 0\n            for i, s in enumerate(self.students):\n                if i:\n                    prev = self.students[i-1]\n                    # For each pair of adjacent students in positions (prev, s),\n                    # d is the distance to the closest student;\n                    # achieved at position prev + d.\n                    d = (s - prev) / 2\n                    if d > dist:\n                        dist, student = d, prev + d\n\n            # Considering the right-most seat.\n            d = self.N - 1 - self.students[-1]\n            if d > dist:\n                student = self.N - 1\n\n        # Add the student to our sorted list of positions.\n        bisect.insort(self.students, student)\n        return student\n\n    def leave(self, p):\n        self.students.remove(p)"}]}
{"url": "https://leetcode-cn.com/problems/score-of-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-cost-to-hire-k-workers", "source": []}
{"url": "https://leetcode-cn.com/problems/mirror-reflection", "source": [{"lang": "Java", "code": "class Solution {\n    double EPS = 1e-6;\n\n    public int mirrorReflection(int p, int q) {\n        double x = 0, y = 0;\n        double rx = p, ry = q;    \n\n        // While it hasn't reached a receptor,...\n        while (!( close(x, p) && (close(y, 0) || close(y, p))\n                  || close(x, 0) && close (y, p) )) {\n            // Want smallest t so that some x + rx, y + ry is 0 or p\n            // x + rxt = 0, then t = -x/rx etc.\n            double t = 1e9;\n            if ((-x / rx) > EPS) t = Math.min(t, -x / rx);\n            if ((-y / ry) > EPS) t = Math.min(t, -y / ry);\n            if (((p-x) / rx) > EPS) t = Math.min(t, (p-x) / rx);\n            if (((p-y) / ry) > EPS) t = Math.min(t, (p-y) / ry);\n\n            x += rx * t;\n            y += ry * t;\n\n            if (close(x, p) || close(x, 0)) rx *= -1;\n            if (close(y, p) || close(y, 0)) ry *= -1;\n        }\n\n        if (close(x, p) && close(y, p)) return 1;\n        return close(x, p) ? 0 : 2;\n    }\n\n    public boolean close(double x, double y) {\n        return Math.abs(x - y) < EPS;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def mirrorReflection(self, p, q):\n        from fractions import Fraction as F\n\n        x = y = 0\n        rx, ry = p, q\n        targets = [(p, 0), (p, p), (0, p)]\n\n        while (x, y) not in targets:\n            #Want smallest t so that some x + rx, y + ry is 0 or p\n            #x + rxt = 0, then t = -x/rx etc.\n            t = float('inf')\n            for v in [F(-x,rx), F(-y,ry), F(p-x,rx), F(p-y,ry)]:\n                if v > 0: t = min(t, v)\n\n            x += rx * t\n            y += ry * t\n\n            #update rx, ry\n            if x == p or x == 0: # bounced from east/west wall, so reflect on y axis\n                rx *= -1\n            if y == p or y == 0:\n                ry *= -1\n\n        return 1 if x==y==p else 0 if x==p else 2"}, {"lang": "Java", "code": "class Solution {\n\n    public int mirrorReflection(int p, int q) {\n        int g = gcd(p, q);\n        p /= g; p %= 2;\n        q /= g; q %= 2;\n\n        if (p == 1 && q == 1) return 1;\n        return p == 1 ? 0 : 2;\n    }\n\n    public int gcd(int a, int b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def mirrorReflection(self, p, q):\n        from fractions import gcd\n        g = gcd(p, q)\n        p = (p / g) % 2\n        q = (q / g) % 2\n\n        return 1 if p and q else 0 if p else 2"}]}
{"url": "https://leetcode-cn.com/problems/buddy-strings", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean buddyStrings(String A, String B) {\n        if (A.length() != B.length()) return false;\n        if (A.equals(B)) {\n            int[] count = new int[26];\n            for (int i = 0; i < A.length(); ++i)\n                count[A.charAt(i) - 'a']++;\n\n            for (int c: count)\n                if (c > 1) return true;\n            return false;\n        } else {\n            int first = -1, second = -1;\n            for (int i = 0; i < A.length(); ++i) {\n                if (A.charAt(i) != B.charAt(i)) {\n                    if (first == -1)\n                        first = i;\n                    else if (second == -1)\n                        second = i;\n                    else\n                        return false;\n                }\n            }\n\n            return (second != -1 && A.charAt(first) == B.charAt(second) &&\n                    A.charAt(second) == B.charAt(first));\n        }\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def buddyStrings(self, A, B):\n        if len(A) != len(B): return False\n        if A == B:\n            seen = set()\n            for a in A:\n                if a in seen:\n                    return True\n                seen.add(a)\n            return False\n        else:\n            pairs = []\n            for a, b in itertools.izip(A, B):\n                if a != b:\n                    pairs.append((a, b))\n                if len(pairs) >= 3: return False\n            return len(pairs) == 2 and pairs[0] == pairs[1][::-1]"}]}
{"url": "https://leetcode-cn.com/problems/lemonade-change", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int five = 0, ten = 0;\n        for (int bill: bills) {\n            if (bill == 5)\n                five++;\n            else if (bill == 10) {\n                if (five == 0) return false;\n                five--;\n                ten++;\n            } else {\n                if (five > 0 && ten > 0) {\n                    five--;\n                    ten--;\n                } else if (five >= 3) {\n                    five -= 3;\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object): #aw\n    def lemonadeChange(self, bills):\n        five = ten = 0\n        for bill in bills:\n            if bill == 5:\n                five += 1\n            elif bill == 10:\n                if not five: return False\n                five -= 1\n                ten += 1\n            else:\n                if ten and five:\n                    ten -= 1\n                    five -= 1\n                elif five >= 3:\n                    five -= 3\n                else:\n                    return False\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/score-after-flipping-matrix", "source": [{"lang": "Java", "code": "class Solution {\n    public int matrixScore(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[] colsums = new int[C];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c)\n                colsums[c] += A[r][c];\n\n        int ans = 0;\n        for (int state = 0; state < (1<<R); ++state) {\n            // Toggle the rows so that after, 'state' represents\n            // the toggled rows.\n            if (state > 0) {\n                int trans = state ^ (state-1);\n                for (int r = 0; r < R; ++r) {\n                    if (((trans >> r) & 1) > 0) {\n                        for (int c = 0; c < C; ++c) {\n                            colsums[c] += A[r][c] == 1 ? -1 : 1;\n                            A[r][c] ^= 1;\n                        }\n                    }\n                }\n            }\n\n            // Calculate the score with the rows toggled by 'state'\n            int score = 0;\n            for (int c = 0; c < C; ++c)\n                score += Math.max(colsums[c], R - colsums[c]) * (1 << (C-1-c));\n            ans = Math.max(ans, score);\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def matrixScore(self, A):\n        R, C = len(A), len(A[0])\n\n        colsums = [0] * C\n        for r in xrange(R):\n            for c in xrange(C):\n                colsums[c] += A[r][c]\n\n        ans = 0\n        for r in xrange(1<<R):\n            if r:\n                trans = r ^ (r-1)\n                for bit in xrange(R):\n                    if (trans >> bit) & 1:\n                        for c in xrange(C):\n                            colsums[c] += -1 if A[bit][c] else +1\n                            A[bit][c] ^= 1\n            \n            score = sum(max(x, R - x) * (1 << (C-1-c))\n                        for c, x in enumerate(colsums))\n            ans = max(ans, score)\n\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int matrixScore(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int ans = 0;\n        for (int c = 0; c < C; ++c) {\n            int col = 0;\n            for (int r = 0; r < R; ++r)\n                col += A[r][c] ^ A[r][0];\n            ans += Math.max(col, R - col) * (1 << (C-1-c));\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def matrixScore(self, A):\n        R, C = len(A), len(A[0])\n        ans = 0\n        for c in xrange(C):\n            col = 0\n            for r in xrange(R):\n                col += A[r][c] ^ A[r][0]\n            ans += max(col, R - col) * 2 ** (C - 1 - c)\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k", "source": []}
{"url": "https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/shortest-path-to-get-all-keys", "source": []}
{"url": "https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes", "source": []}
{"url": "https://leetcode-cn.com/problems/prime-palindrome", "source": [{"lang": "Java", "code": "class Solution {\n    public int primePalindrome(int N) {\n        for (int L = 1; L <= 5; ++L) {\n            //Check for odd-length palindromes\n            for (int root = (int)Math.pow(10, L - 1); root < (int)Math.pow(10, L); ++root) {\n                StringBuilder sb = new StringBuilder(Integer.toString(root));\n                for (int k = L-2; k >= 0; --k)\n                    sb.append(sb.charAt(k));\n                int x = Integer.valueOf(sb.toString());\n                if (x >= N && isPrime(x))\n                    return x;\n                    //If we didn't check for even-length palindromes:\n                    //return N <= 11 ? min(x, 11) : x\n            }\n\n            //Check for even-length palindromes\n            for (int root = (int)Math.pow(10, L - 1); root < (int)Math.pow(10, L); ++root) {\n                StringBuilder sb = new StringBuilder(Integer.toString(root));\n                for (int k = L-1; k >= 0; --k)\n                    sb.append(sb.charAt(k));\n                int x = Integer.valueOf(sb.toString());\n                if (x >= N && isPrime(x))\n                    return x;\n            }\n        }\n\n        throw null;\n    }\n\n    public boolean isPrime(int N) {\n        if (N < 2) return false;\n        int R = (int) Math.sqrt(N);\n        for (int d = 2; d <= R; ++d)\n            if (N % d == 0) return false;\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def primePalindrome(self, N):\n        def is_prime(n):\n            return n > 1 and all(n%d for d in xrange(2, int(n**.5) + 1))\n\n        for length in xrange(1, 6):\n            #Check for odd-length palindromes\n            for root in xrange(10**(length - 1), 10**length):\n                s = str(root)\n                x = int(s + s[-2::-1]) #eg. s = '123' to x = int('12321')\n                if x >= N and is_prime(x):\n                    return x\n                    #If we didn't check for even-length palindromes:\n                    #return min(x, 11) if N <= 11 else x\n\n            #Check for even-length palindromes\n            for root in xrange(10**(length - 1), 10**length):\n                s = str(root)\n                x = int(s + s[-1::-1]) #eg. s = '123' to x = int('123321')\n                if x >= N and is_prime(x):\n                    return x"}, {"lang": "Java", "code": "class Solution {\n    public int primePalindrome(int N) {\n        while (true) {\n            if (N == reverse(N) && isPrime(N))\n                return N;\n            N++;\n            if (10_000_000 < N && N < 100_000_000)\n                N = 100_000_000;\n        }\n    }\n\n    public boolean isPrime(int N) {\n        if (N < 2) return false;\n        int R = (int) Math.sqrt(N);\n        for (int d = 2; d <= R; ++d)\n            if (N % d == 0) return false;\n        return true;\n    }\n\n    public int reverse(int N) {\n        int ans = 0;\n        while (N > 0) {\n            ans = 10 * ans + (N % 10);\n            N /= 10;\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def primePalindrome(self, N):\n        def is_prime(n):\n            return n > 1 and all(n % d for d in xrange(2, int(n**.5) + 1))\n\n        def reverse(x):\n            ans = 0\n            while x:\n                ans = 10 * ans + x % 10\n                x /= 10\n            return ans\n\n        while True:\n            if N == reverse(N) and is_prime(N):\n                return N\n            N += 1\n            if 10**7 < N < 10**8:\n                N = 10**8"}]}
{"url": "https://leetcode-cn.com/problems/transpose-matrix", "source": [{"lang": "Java", "code": "class Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def transpose(self, A):\n        R, C = len(A), len(A[0])\n        ans = [[None] * R for _ in xrange(C)]\n        for r, row in enumerate(A):\n            for c, val in enumerate(row):\n                ans[c][r] = val\n        return ans\n\n        #Alternative Solution:\n        #return zip(*A)"}]}
{"url": "https://leetcode-cn.com/problems/binary-gap", "source": [{"lang": "Java", "code": "class Solution {\n    public int binaryGap(int N) {\n        int[] A = new int[32];\n        int t = 0;\n        for (int i = 0; i < 32; ++i)\n            if (((N >> i) & 1) != 0)\n                A[t++] = i;\n\n        int ans = 0;\n        for (int i = 0; i < t - 1; ++i)\n            ans = Math.max(ans, A[i+1] - A[i]);\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def binaryGap(self, N):\n        A = [i for i in xrange(32) if (N >> i) & 1]\n        if len(A) < 2: return 0\n        return max(A[i+1] - A[i] for i in xrange(len(A) - 1))"}, {"lang": "Java", "code": "class Solution {\n    public int binaryGap(int N) {\n        int last = -1, ans = 0;\n        for (int i = 0; i < 32; ++i)\n            if (((N >> i) & 1) > 0) {\n                if (last >= 0)\n                    ans = Math.max(ans, i - last);\n                last = i;\n            }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def binaryGap(self, N):\n        last = None\n        ans = 0\n        for i in xrange(32):\n            if (N >> i) & 1:\n                if last is not None:\n                    ans = max(ans, i - last)\n                last = i\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/reordered-power-of-2", "source": []}
{"url": "https://leetcode-cn.com/problems/advantage-shuffle", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] advantageCount(int[] A, int[] B) {\n        int[] sortedA = A.clone();\n        Arrays.sort(sortedA);\n        int[] sortedB = B.clone();\n        Arrays.sort(sortedB);\n\n        // assigned[b] = list of a that are assigned to beat b\n        Map<Integer, Deque<Integer>> assigned = new HashMap();\n        for (int b: B) assigned.put(b, new LinkedList());\n\n        // remaining = list of a that are not assigned to any b\n        Deque<Integer> remaining = new LinkedList();\n\n        // populate (assigned, remaining) appropriately\n        // sortedB[j] is always the smallest unassigned element in B\n        int j = 0;\n        for (int a: sortedA) {\n            if (a > sortedB[j]) {\n                assigned.get(sortedB[j++]).add(a);\n            } else {\n                remaining.add(a);\n            }\n        }\n\n        // Reconstruct the answer from annotations (assigned, remaining)\n        int[] ans = new int[B.length];\n        for (int i = 0; i < B.length; ++i) {\n            // if there is some a assigned to b...\n            if (assigned.get(B[i]).size() > 0)\n                ans[i] = assigned.get(B[i]).pop();\n            else\n                ans[i] = remaining.pop();\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def advantageCount(self, A, B):\n        sortedA = sorted(A)\n        sortedB = sorted(B)\n\n        # assigned[b] = list of a that are assigned to beat b\n        # remaining = list of a that are not assigned to any b\n        assigned = {b: [] for b in B}\n        remaining = []\n\n        # populate (assigned, remaining) appropriately\n        # sortedB[j] is always the smallest unassigned element in B\n        j = 0\n        for a in sortedA:\n            if a > sortedB[j]:\n                assigned[sortedB[j]].append(a)\n                j += 1\n            else:\n                remaining.append(a)\n\n        # Reconstruct the answer from annotations (assigned, remaining)\n        return [assigned[b].pop() if assigned[b] else remaining.pop()\n                for b in B]"}]}
{"url": "https://leetcode-cn.com/problems/minimum-number-of-refueling-stops", "source": [{"lang": "Java", "code": "class Solution {\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\n        int N = stations.length;\n        long[] dp = new long[N + 1];\n        dp[0] = startFuel;\n        for (int i = 0; i < N; ++i)\n            for (int t = i; t >= 0; --t)\n                if (dp[t] >= stations[i][0])\n                    dp[t+1] = Math.max(dp[t+1], dp[t] + (long) stations[i][1]);\n\n        for (int i = 0; i <= N; ++i)\n            if (dp[i] >= target) return i;\n        return -1;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minRefuelStops(self, target, startFuel, stations):\n        dp = [startFuel] + [0] * len(stations)\n        for i, (location, capacity) in enumerate(stations):\n            for t in xrange(i, -1, -1):\n                if dp[t] >= location:\n                    dp[t+1] = max(dp[t+1], dp[t] + capacity)\n\n        for i, d in enumerate(dp):\n            if d >= target: return i\n        return -1"}, {"lang": "Java", "code": "class Solution {\n    public int minRefuelStops(int target, int tank, int[][] stations) {\n        // pq is a maxheap of gas station capacities\n        PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder());\n        int ans = 0, prev = 0;\n        for (int[] station: stations) {\n            int location = station[0];\n            int capacity = station[1];\n            tank -= location - prev;\n            while (!pq.isEmpty() && tank < 0) {  // must refuel in past\n                tank += pq.poll();\n                ans++;\n            }\n\n            if (tank < 0) return -1;\n            pq.offer(capacity);\n            prev = location;\n        }\n\n        // Repeat body for station = (target, inf)\n        {\n            tank -= target - prev;\n            while (!pq.isEmpty() && tank < 0) {\n                tank += pq.poll();\n                ans++;\n            }\n            if (tank < 0) return -1;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minRefuelStops(self, target, tank, stations):\n        pq = []  # A maxheap is simulated using negative values\n        stations.append((target, float('inf')))\n\n        ans = prev = 0\n        for location, capacity in stations:\n            tank -= location - prev\n            while pq and tank < 0:  # must refuel in past\n                tank += -heapq.heappop(pq)\n                ans += 1\n            if tank < 0: return -1\n            heapq.heappush(pq, -capacity)\n            prev = location\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/leaf-similar-trees", "source": []}
{"url": "https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/walking-robot-simulation", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\n        int dx[4] = {0, 1, 0, -1};\n        int dy[4] = {1, 0, -1, 0};\n        int x = 0, y = 0, di = 0;\n\n        unordered_set<pair<int, int>> obstacleSet;\n        for (vector<int> obstacle: obstacles)\n            obstacleSet.insert(make_pair(obstacle[0], obstacle[1]));\n\n        int ans = 0;\n        for (int cmd: commands) {\n            if (cmd == -2)\n                di = (di + 3) % 4;\n            else if (cmd == -1)\n                di = (di + 1) % 4;\n            else {\n                for (int k = 0; k < cmd; ++k) {\n                    int nx = x + dx[di];\n                    int ny = y + dy[di];\n                    if (obstacleSet.find(make_pair(nx, ny)) == obstacleSet.end()) {\n                        x = nx;\n                        y = ny;\n                        ans = max(ans, x*x + y*y);\n                    }\n                }\n            }\n        }\n\n        return ans;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int robotSim(int[] commands, int[][] obstacles) {\n        int[] dx = new int[]{0, 1, 0, -1};\n        int[] dy = new int[]{1, 0, -1, 0};\n        int x = 0, y = 0, di = 0;\n\n        // Encode obstacles (x, y) as (x+30000) * (2^16) + (y+30000)\n        Set<Long> obstacleSet = new HashSet();\n        for (int[] obstacle: obstacles) {\n            long ox = (long) obstacle[0] + 30000;\n            long oy = (long) obstacle[1] + 30000;\n            obstacleSet.add((ox << 16) + oy);\n        }\n\n        int ans = 0;\n        for (int cmd: commands) {\n            if (cmd == -2)  //left\n                di = (di + 3) % 4;\n            else if (cmd == -1)  //right\n                di = (di + 1) % 4;\n            else {\n                for (int k = 0; k < cmd; ++k) {\n                    int nx = x + dx[di];\n                    int ny = y + dy[di];\n                    long code = (((long) nx + 30000) << 16) + ((long) ny + 30000);\n                    if (!obstacleSet.contains(code)) {\n                        x = nx;\n                        y = ny;\n                        ans = Math.max(ans, x*x + y*y);\n                    }\n                }\n            }\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def robotSim(self, commands, obstacles):\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n        ans = 0\n\n        for cmd in commands:\n            if cmd == -2:  #left\n                di = (di - 1) % 4\n            elif cmd == -1:  #right\n                di = (di + 1) % 4\n            else:\n                for k in xrange(cmd):\n                    if (x+dx[di], y+dy[di]) not in obstacleSet:\n                        x += dx[di]\n                        y += dy[di]\n                        ans = max(ans, x*x + y*y)\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/koko-eating-bananas", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int minEatingSpeed(vector<int>& piles, int H) {\n        int lo = 1, hi = pow(10, 9);\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (!possible(piles, H, mi))\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n\n        return lo;\n    }\n\n    // Can Koko eat all bananas in H hours with eating speed K?\n    bool possible(vector<int>& piles, int H, int K) {\n        int time = 0;\n        for (int p: piles)\n            time += (p - 1) / K + 1;\n        return time <= H;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int minEatingSpeed(int[] piles, int H) {\n        int lo = 1;\n        int hi = 1_000_000_000;\n        while (lo < hi) {\n            int mi = (lo + hi) / 2;\n            if (!possible(piles, H, mi))\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n\n        return lo;\n    }\n\n    // Can Koko eat all bananas in H hours with eating speed K?\n    public boolean possible(int[] piles, int H, int K) {\n        int time = 0;\n        for (int p: piles)\n            time += (p-1) / K + 1;\n        return time <= H;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minEatingSpeed(self, piles, H):\n        # Can Koko eat all bananas in H hours with eating speed K?\n        def possible(K):\n            return sum((p-1) / K + 1 for p in piles) <= H\n\n        lo, hi = 1, max(piles)\n        while lo < hi:\n            mi = (lo + hi) / 2\n            if not possible(mi):\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo"}]}
{"url": "https://leetcode-cn.com/problems/middle-of-the-linked-list", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        vector<ListNode*> A = {head};\n        while (A.back()->next != NULL)\n            A.push_back(A.back()->next);\n        return A[A.size() / 2];\n    }\n};"}, {"lang": "Java", "code": ""}, {"lang": "Python", "code": "class Solution(object):\n    def middleNode(self, head):\n        A = [head]\n        while A[-1].next:\n            A.append(A[-1].next)\n        return A[len(A) / 2]"}, {"lang": "JavaScript", "code": "var middleNode = function(head) {\n    let A = [head];\n    while (A[A.length - 1].next != null)\n        A.push(A[A.length - 1].next);\n    return A[Math.trunc(A.length / 2)];\n};"}, {"lang": "C++", "code": "class Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def middleNode(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow"}, {"lang": "JavaScript", "code": "var middleNode = function(head) {\n    slow = fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n};"}]}
{"url": "https://leetcode-cn.com/problems/stone-game", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        int N = piles.size();\n\n        // dp[i+1][j+1] = the value of the game [piles[i], ..., piles[j]]\n        int dp[N+2][N+2];\n        memset(dp, 0, sizeof(dp));\n\n        for (int size = 1; size <= N; ++size)\n            for (int i = 0, j = size - 1; j < N; ++i, ++j) {\n                int parity = (j + i + N) % 2;  // j - i - N; but +x = -x (mod 2)\n                if (parity == 1)\n                    dp[i+1][j+1] = max(piles[i] + dp[i+2][j+1], piles[j] + dp[i+1][j]);\n                else\n                    dp[i+1][j+1] = min(-piles[i] + dp[i+2][j+1], -piles[j] + dp[i+1][j]);\n            }\n\n        return dp[1][N] > 0;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public boolean stoneGame(int[] piles) {\n        int N = piles.length;\n\n        // dp[i+1][j+1] = the value of the game [piles[i], ..., piles[j]].\n        int[][] dp = new int[N+2][N+2];\n        for (int size = 1; size <= N; ++size)\n            for (int i = 0; i + size <= N; ++i) {\n                int j = i + size - 1;\n                int parity = (j + i + N) % 2;  // j - i - N; but +x = -x (mod 2)\n                if (parity == 1)\n                    dp[i+1][j+1] = Math.max(piles[i] + dp[i+2][j+1], piles[j] + dp[i+1][j]);\n                else\n                    dp[i+1][j+1] = Math.min(-piles[i] + dp[i+2][j+1], -piles[j] + dp[i+1][j]);\n            }\n\n        return dp[1][N] > 0;\n    }\n}"}, {"lang": "JavaScript", "code": "var stoneGame = function(piles) {\n    const N = piles.length;\n    // Make a (N+2) by (N+2) array, initialized with 0s.\n    const dp = Array(N + 2).fill(0).map(() => Array(N + 2).fill(0));\n\n    // dp[i+1][j+1] = the value of the game [piles[i], ..., piles[j]]\n    for (let size = 1; size <= N; ++size)\n        for (let i = 0, j = size - 1; j < N; ++i, ++j) {\n            let parity = (j + i + N) % 2;  // j - i - N; but +x = -x (mod 2)\n            if (parity == 1)\n                dp[i+1][j+1] = Math.max(piles[i] + dp[i+2][j+1], piles[j] + dp[i+1][j]);\n            else\n                dp[i+1][j+1] = Math.min(-piles[i] + dp[i+2][j+1], -piles[j] + dp[i+1][j]);\n        }\n\n    return dp[1][N] > 0;\n};"}, {"lang": "Python3", "code": "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles):\n        N = len(piles)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # The value of the game [piles[i], piles[i+1], ..., piles[j]].\n            if i > j: return 0\n            parity = (j - i - N) % 2\n            if parity == 1:  # first player\n                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n\n        return dp(0, N - 1) > 0"}, {"lang": "C++", "code": "class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        return true;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public boolean stoneGame(int[] piles) {\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def stoneGame(self, piles):\n        return True"}, {"lang": "JavaScript", "code": "var stoneGame = function(piles) {\n    return true;\n};"}]}
{"url": "https://leetcode-cn.com/problems/nth-magical-number", "source": []}
{"url": "https://leetcode-cn.com/problems/profitable-schemes", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int profitableSchemes(int G, int P, vector<int>& group, vector<int>& profit) {\n        int MOD = 1e9 + 7;\n        int N = group.size();\n\n        long dp[2][P+1][G+1];\n        memset(dp, 0, sizeof(dp));\n        dp[0][0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n            int p0 = profit[i];  // the current crime profit\n            int g0 = group[i];  // the current crime group size\n\n            long (*cur)[G+1] = dp[i % 2];\n            long (*cur2)[G+1] = dp[(i + 1) % 2];\n\n            // Deep copy cur into cur2\n            for (int jp = 0; jp <= P; ++jp)\n                for (int jg = 0; jg <= G; ++jg)\n                    cur2[jp][jg] = cur[jp][jg];\n\n            for (int p1 = 0; p1 <= P; ++p1) {  // p1 : the current profit\n                // p2 : the new profit after committing this crime\n                int p2 = min(p1 + p0, P);\n                for (int g1 = 0; g1 <= G - g0; ++g1) {  // g1 : the current group size\n                    // g2 : the new group size after committing this crime\n                    int g2 = g1 + g0;\n                    cur2[p2][g2] += cur[p1][g1];\n                    cur2[p2][g2] %= MOD;\n                }\n            }\n        }\n\n        // Sum all schemes with profit P and group size 0 <= g <= G.\n        long ans = 0;\n        for (long x: dp[N % 2][P])\n            ans += x;\n\n        return (int) (ans % MOD);\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int profitableSchemes(int G, int P, int[] group, int[] profit) {\n        int MOD = 1_000_000_007;\n        int N = group.length;\n        long[][][] dp = new long[2][P+1][G+1];\n        dp[0][0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n            int p0 = profit[i];  // the current crime profit\n            int g0 = group[i];  // the current crime group size\n\n            long[][] cur = dp[i % 2];\n            long[][] cur2 = dp[(i + 1) % 2];\n\n            // Deep copy cur into cur2\n            for (int jp = 0; jp <= P; ++jp)\n                for (int jg = 0; jg <= G; ++jg)\n                    cur2[jp][jg] = cur[jp][jg];\n\n            for (int p1 = 0; p1 <= P; ++p1) {  // p1 : the current profit\n                // p2 : the new profit after committing this crime\n                int p2 = Math.min(p1 + p0, P);\n                for (int g1 = 0; g1 <= G - g0; ++g1) {  // g1 : the current group size\n                    // g2 : the new group size after committing this crime\n                    int g2 = g1 + g0;\n                    cur2[p2][g2] += cur[p1][g1];\n                    cur2[p2][g2] %= MOD;\n                }\n            }\n        }\n\n        // Sum all schemes with profit P and group size 0 <= g <= G.\n        long ans = 0;\n        for (long x: dp[N%2][P])\n            ans += x;\n\n        return (int) ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def profitableSchemes(self, G, P, group, profit):\n        MOD = 10**9 + 7\n        cur = [[0] * (G + 1) for _ in xrange(P + 1)]\n        cur[0][0] = 1\n\n        for p0, g0 in zip(profit, group):\n            # p0, g0 : the current crime profit and group size\n            cur2 = [row[:] for row in cur]\n            for p1 in xrange(P + 1):\n                # p1 : the current profit\n                # p2 : the new profit after committing this crime\n                p2 = min(p1 + p0, P)\n                for g1 in xrange(G - g0 + 1):\n                    # g1 : the current group size\n                    # g2 : the new group size after committing this crime\n                    g2 = g1 + g0\n                    cur2[p2][g2] += cur[p1][g1]\n                    cur2[p2][g2] %= MOD\n            cur = cur2\n\n        # Sum all schemes with profit P and group size 0 <= g <= G.\n        return sum(cur[-1]) % MOD"}, {"lang": "JavaScript", "code": "var profitableSchemes = function(G, P, group, profit) {\n    const MOD = 1e9 + 7;\n    const N = group.length;\n    let cur = Array(P + 1).fill(0).map(() => Array(G + 1).fill(0));\n    cur[0][0] = 1;\n\n    for (let i = 0; i < N; ++i) {\n        // p0, g0 : the current crime profit and group size\n        let p0 = profit[i];\n        let g0 = group[i];\n\n        // Set cur2 as a deep copy of cur.\n        let cur2 = Array(P + 1).fill(0).map((_, i) => cur[i].slice(0));\n\n        for (let p1 = 0; p1 <= P; ++p1) {  // p1 : the current profit\n            // p2 : the new profit after committing this crime\n            let p2 = Math.min(p1 + p0, P);\n            for (let g1 = 0; g1 <= G - g0; ++g1) {  // g1 : the current group size\n                // g2 : the new group size after committing this crime\n                let g2 = g1 + g0;\n                cur2[p2][g2] += cur[p1][g1];\n                cur2[p2][g2] %= MOD;\n            }\n        }\n\n        cur = cur2;\n    }\n\n    // Sum all schemes with profit P and group size 0 <= g <= G.\n    ans = 0;\n    for (let x of cur[P])\n        ans += x;\n    return ans % MOD;\n};"}]}
{"url": "https://leetcode-cn.com/problems/decoded-string-at-index", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    string decodeAtIndex(string S, int K) {\n        long size = 0;\n        int N = S.size();\n\n        // Find size = length of decoded string\n        for (int i = 0; i < N; ++i) {\n            if (isdigit(S[i]))\n                size *= S[i] - '0';\n            else\n                size++;\n        }\n\n        for (int i = N-1; i >=0; --i) {\n            K %= size;\n            if (K == 0 && isalpha(S[i]))\n                return (string) \"\" + S[i];\n\n            if (isdigit(S[i]))\n                size /= S[i] - '0';\n            else\n                size--;\n        }\n        return \"\";\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public String decodeAtIndex(String S, int K) {\n        long size = 0;\n        int N = S.length();\n\n        // Find size = length of decoded string\n        for (int i = 0; i < N; ++i) {\n            char c = S.charAt(i);\n            if (Character.isDigit(c))\n                size *= c - '0';\n            else\n                size++;\n        }\n\n        for (int i = N-1; i >= 0; --i) {\n            char c = S.charAt(i);\n            K %= size;\n            if (K == 0 && Character.isLetter(c))\n                return Character.toString(c);\n\n            if (Character.isDigit(c))\n                size /= c - '0';\n            else\n                size--;\n        }\n\n        throw null;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def decodeAtIndex(self, S, K):\n        size = 0\n        # Find size = length of decoded string\n        for c in S:\n            if c.isdigit():\n                size *= int(c)\n            else:\n                size += 1\n\n        for c in reversed(S):\n            K %= size\n            if K == 0 and c.isalpha():\n                return c\n\n            if c.isdigit():\n                size /= int(c)\n            else:\n                size -= 1"}]}
{"url": "https://leetcode-cn.com/problems/boats-to-save-people", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(), people.end());\n        int i = 0, j = people.size() - 1;\n        int ans = 0;\n\n        while (i <= j) {\n            ans++;\n            if (people[i] + people[j] <= limit)\n                i++;\n            j--;\n        }\n\n        return ans;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int i = 0, j = people.length - 1;\n        int ans = 0;\n\n        while (i <= j) {\n            ans++;\n            if (people[i] + people[j] <= limit)\n                i++;\n            j--;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numRescueBoats(self, people, limit):\n        people.sort()\n        i, j = 0, len(people) - 1\n        ans = 0\n        while i <= j:\n            ans += 1\n            if people[i] + people[j] <= limit:\n                i += 1\n            j -= 1\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph", "source": [{"lang": "C++", "code": "#define pii pair<int, int>\n\nclass Solution {\npublic:\n    int reachableNodes(vector<vector<int>>& edges, int M, int N) {\n        vector<vector<pii>> graph(N);\n        for (vector<int> edge: edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            graph[u].push_back({v, w});\n            graph[v].push_back({u, w});\n        }\n\n        map<int, int> dist;\n        dist[0] = 0;\n        for (int i = 1; i < N; ++i)\n            dist[i] = M+1;\n\n        map<pii, int> used;\n        int ans = 0;\n\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        pq.push({0, 0});\n\n        while (!pq.empty()) {\n            pii top = pq.top();\n            pq.pop();\n            int d = top.first, node = top.second;\n            if (d > dist[node]) continue;\n            dist[node] = d;\n\n            // Each node is only visited once.  We've reached\n            // a node in our original graph.\n            ans++;\n\n            for (auto pair: graph[node]) {\n                // M - d is how much further we can walk from this node;\n                // weight is how many new nodes there are on this edge.\n                // v is the maximum utilization of this edge.\n                int nei = pair.first;\n                int weight = pair.second;\n                used[{node, nei}] = min(weight, M - d);\n\n                // d2 is the total distance to reach 'nei' (nei***or) node\n                // in the original graph.\n                int d2 = d + weight + 1;\n                if (d2 < min(dist[nei], M+1)) {\n                    pq.push({d2, nei});\n                    dist[nei] = d2;\n                }\n            }\n        }\n\n        // At the end, each edge (u, v, w) can be used with a maximum\n        // of w new nodes: a max of used[u, v] nodes from one side,\n        // and used[v, u] nodes from the other.\n        for (vector<int> edge: edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            ans += min(w, used[{u, v}] + used[{v, u}]);\n        }\n        return ans;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int reachableNodes(int[][] edges, int M, int N) {\n        Map<Integer, Map<Integer, Integer>> graph = new HashMap();\n        for (int[] edge: edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            graph.computeIfAbsent(u, x->new HashMap()).put(v, w);\n            graph.computeIfAbsent(v, x->new HashMap()).put(u, w);\n        }\n\n        PriorityQueue<ANode> pq = new PriorityQueue<ANode>(\n            (a, b) -> Integer.compare(a.dist, b.dist));\n        pq.offer(new ANode(0, 0));\n\n        Map<Integer, Integer> dist = new HashMap();\n        dist.put(0, 0);\n        Map<Integer, Integer> used = new HashMap();\n        int ans = 0;\n\n        while (!pq.isEmpty()) {\n            ANode anode = pq.poll();\n            int node = anode.node;\n            int d = anode.dist;\n\n            if (d > dist.getOrDefault(node, 0)) continue;\n            // Each node is only visited once.  We've reached\n            // a node in our original graph.\n            ans++;\n\n            if (!graph.containsKey(node)) continue;\n            for (int nei: graph.get(node).keySet()) {\n                // M - d is how much further we can walk from this node;\n                // weight is how many new nodes there are on this edge.\n                // v is the maximum utilization of this edge.\n                int weight = graph.get(node).get(nei);\n                int v = Math.min(weight, M - d);\n                used.put(N * node + nei, v);\n\n                // d2 is the total distance to reach 'nei' (nei***or) node\n                // in the original graph.\n                int d2 = d + weight + 1;\n                if (d2 < dist.getOrDefault(nei, M+1)) {\n                    pq.offer(new ANode(nei, d2));\n                    dist.put(nei, d2);\n                }\n            }\n        }\n\n        // At the end, each edge (u, v, w) can be used with a maximum\n        // of w new nodes: a max of used[u, v] nodes from one side,\n        // and used[v, u] nodes from the other.\n        // [We use the encoding (u, v) = u * N + v.]\n        for (int[] edge: edges) {\n            ans += Math.min(edge[2], used.getOrDefault(edge[0] * N + edge[1], 0) +\n                                     used.getOrDefault(edge[1] * N + edge[0], 0) );\n        }\n\n        return ans;\n    }\n}\n\nclass ANode {\n    int node, dist;\n    ANode(int n, int d) {\n        node = n;\n        dist = d;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def reachableNodes(self, edges, M, N):\n        graph = collections.defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w\n\n        pq = [(0, 0)]\n        dist = {0: 0}\n        used = {}\n        ans = 0\n\n        while pq:\n            d, node = heapq.heappop(pq)\n            if d > dist[node]: continue\n            # Each node is only visited once.  We've reached\n            # a node in our original graph.\n            ans += 1\n\n            for nei, weight in graph[node].iteritems():\n                # M - d is how much further we can walk from this node;\n                # weight is how many new nodes there are on this edge.\n                # v is the maximum utilization of this edge.\n                v = min(weight, M - d)\n                used[node, nei] = v\n\n                # d2 is the total distance to reach 'nei' (nei***or) node\n                # in the original graph.\n                d2 = d + weight + 1\n                if d2 < dist.get(nei, M+1):\n                    heapq.heappush(pq, (d2, nei))\n                    dist[nei] = d2\n\n        # At the end, each edge (u, v, w) can be used with a maximum\n        # of w new nodes: a max of used[u, v] nodes from one side,\n        # and used[v, u] nodes from the other.\n        for u, v, w in edges:\n            ans += min(w, used.get((u, v), 0) + used.get((v, u), 0))\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/projection-area-of-3d-shapes", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int projectionArea(vector<vector<int>>& grid) {\n        int N = grid.size();\n        int ans = 0;\n\n        for (int i = 0; i < N;  ++i) {\n            int bestRow = 0;  // largest of grid[i][j]\n            int bestCol = 0;  // largest of grid[j][i]\n            for (int j = 0; j < N; ++j) {\n                if (grid[i][j] > 0) ans++;  // top shadow\n                bestRow = max(bestRow, grid[i][j]);\n                bestCol = max(bestCol, grid[j][i]);\n            }\n            ans += bestRow + bestCol;\n        }\n\n        return ans;\n    }\n};"}, {"lang": "Java", "code": "class Solution {\n    public int projectionArea(int[][] grid) {\n        int N = grid.length;\n        int ans = 0;\n\n        for (int i = 0; i < N;  ++i) {\n            int bestRow = 0;  // largest of grid[i][j]\n            int bestCol = 0;  // largest of grid[j][i]\n            for (int j = 0; j < N; ++j) {\n                if (grid[i][j] > 0) ans++;  // top shadow\n                bestRow = Math.max(bestRow, grid[i][j]);\n                bestCol = Math.max(bestCol, grid[j][i]);\n            }\n            ans += bestRow + bestCol;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def projectionArea(self, grid):\n        N = len(grid)\n        ans = 0\n\n        for i in xrange(N):\n            best_row = 0  # max of grid[i][j]\n            best_col = 0  # max of grid[j][i]\n            for j in xrange(N):\n                if grid[i][j]: ans += 1  # top shadow\n                best_row = max(best_row, grid[i][j])\n                best_col = max(best_col, grid[j][i])\n\n            ans += best_row + best_col\n\n        return ans\n\n        \"\"\" Alternative solution:\n        ans = sum(map(max, grid))\n        ans += sum(map(max, zip(*grid)))\n        ans += sum(v > 0 for row in grid for v in row)\n        \"\"\""}]}
{"url": "https://leetcode-cn.com/problems/uncommon-words-from-two-sentences", "source": []}
{"url": "https://leetcode-cn.com/problems/spiral-matrix-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/possible-bipartition", "source": [{"lang": "Java", "code": "class Solution {\n    ArrayList<Integer>[] graph;\n    Map<Integer, Integer> color;\n\n    public boolean possibleBipartition(int N, int[][] dislikes) {\n        graph = new ArrayList[N+1];\n        for (int i = 1; i <= N; ++i)\n            graph[i] = new ArrayList();\n\n        for (int[] edge: dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        color = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            if (!color.containsKey(node) && !dfs(node, 0))\n                return false;\n        return true;\n    }\n\n    public boolean dfs(int node, int c) {\n        if (color.containsKey(node))\n            return color.get(node) == c;\n        color.put(node, c);\n\n        for (int nei: graph[node])\n            if (!dfs(nei, c ^ 1))\n                return false;\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}\n        def dfs(node, c = 0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n\n        return all(dfs(node)\n                   for node in range(1, N+1)\n                   if node not in color)"}]}
{"url": "https://leetcode-cn.com/problems/super-egg-drop", "source": [{"lang": "Java", "code": "class Solution {\n    public int superEggDrop(int K, int N) {\n        return dp(K, N);\n    }\n\n    Map<Integer, Integer> memo = new HashMap();\n    public int dp(int K, int N) {\n        if (!memo.containsKey(N * 100 + K)) {\n            int ans;\n            if (N == 0)\n                ans = 0;\n            else if (K == 1)\n                ans = N;\n            else {\n                int lo = 1, hi = N;\n                while (lo + 1 < hi) {\n                    int x = (lo + hi) / 2;\n                    int t1 = dp(K-1, x-1);\n                    int t2 = dp(K, N-x);\n\n                    if (t1 < t2)\n                        lo = x;\n                    else if (t1 > t2)\n                        hi = x;\n                    else\n                        lo = hi = x;\n                }\n\n                ans = 1 + Math.min(Math.max(dp(K-1, lo-1), dp(K, N-lo)),\n                                   Math.max(dp(K-1, hi-1), dp(K, N-hi)));\n            }\n\n            memo.put(N * 100 + K, ans);\n        }\n\n        return memo.get(N * 100 + K);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def superEggDrop(self, K, N):\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    # keep a gap of 2 X values to manually check later\n                    while lo + 1 < hi:\n                        x = (lo + hi) / 2\n                        t1 = dp(k-1, x-1)\n                        t2 = dp(k, n-x)\n\n                        if t1 < t2:\n                            lo = x\n                        elif t1 > t2:\n                            hi = x\n                        else:\n                            lo = hi = x\n\n                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x))\n                                  for x in (lo, hi))\n\n                memo[k, n] = ans\n            return memo[k, n]\n\n        return dp(K, N)"}, {"lang": "Java", "code": "class Solution {\n    public int superEggDrop(int K, int N) {\n        // Right now, dp[i] represents dp(1, i)\n        int[] dp = new int[N+1];\n        for (int i = 0; i <= N; ++i)\n            dp[i] = i;\n\n        for (int k = 2; k <= K; ++k) {\n            // Now, we will develop dp2[i] = dp(k, i)\n            int[] dp2 = new int[N+1];\n            int x = 1;\n            for (int n = 1; n <= N; ++n) {\n                // Let's find dp2[n] = dp(k, n)\n                // Increase our optimal x while we can make our answer better.\n                // Notice max(dp[x-1], dp2[n-x]) > max(dp[x], dp2[n-x-1])\n                // is simply max(T1(x-1), T2(x-1)) > max(T1(x), T2(x)).\n                while (x < n && Math.max(dp[x-1], dp2[n-x]) > Math.max(dp[x], dp2[n-x-1]))\n                    x++;\n\n                // The final answer happens at this x.\n                dp2[n] = 1 + Math.max(dp[x-1], dp2[n-x]);\n            }\n\n            dp = dp2;\n        }\n\n        return dp[N];\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def superEggDrop(self, K, N):\n\n        # Right now, dp[i] represents dp(1, i)\n        dp = range(N+1)\n\n        for k in xrange(2, K+1):\n            # Now, we will develop dp2[i] = dp(k, i)\n            dp2 = [0]\n            x = 1\n            for n in xrange(1, N+1):\n                # Let's find dp2[n] = dp(k, n)\n                # Increase our optimal x while we can make our answer better.\n                # Notice max(dp[x-1], dp2[n-x]) > max(dp[x], dp2[n-x-1])\n                # is simply max(T1(x-1), T2(x-1)) > max(T1(x), T2(x)).\n                while x < n and max(dp[x-1], dp2[n-x]) > \\\n                                max(dp[x], dp2[n-x-1]):\n                    x += 1\n\n                # The final answer happens at this x.\n                dp2.append(1 + max(dp[x-1], dp2[n-x]))\n\n            dp = dp2\n\n        return dp[-1]"}, {"lang": "Java", "code": "class Solution {\n    public int superEggDrop(int K, int N) {\n        int lo = 1, hi = N;\n        while (lo < hi) {\n            int mi = (lo + hi) / 2;\n            if (f(mi, K, N) < N)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n\n        return lo;\n    }\n\n    public int f(int x, int K, int N) {\n        int ans = 0, r = 1;\n        for (int i = 1; i <= K; ++i) {\n            r *= x-i+1;\n            r /= i;\n            ans += r;\n            if (ans >= N) break;\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def superEggDrop(self, K, N):\n        def f(x):\n            ans = 0\n            r = 1\n            for i in range(1, K+1):\n                r *= x-i+1\n                r //= i\n                ans += r\n                if ans >= N: break\n            return ans\n\n        lo, hi = 1, N\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if f(mi) < N:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo"}]}
{"url": "https://leetcode-cn.com/problems/fair-candy-swap", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] fairCandySwap(int[] A, int[] B) {\n        int sa = 0, sb = 0;  // sum of A, B respectively\n        for (int x: A) sa += x;\n        for (int x: B) sb += x;\n        int delta = (sb - sa) / 2;\n        // If Alice gives x, she expects to receive x + delta\n\n        Set<Integer> setB = new HashSet();\n        for (int x: B) setB.add(x);\n\n        for (int x: A)\n            if (setB.contains(x + delta))\n                return new int[]{x, x + delta};\n\n        throw null;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def fairCandySwap(self, A, B):\n        Sa, Sb = sum(A), sum(B)\n        setB = set(B)\n        for x in A:\n            if x + (Sb - Sa) / 2 in setB:\n                return [x, x + (Sb - Sa) / 2]"}]}
{"url": "https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/find-and-replace-pattern", "source": [{"lang": "Java", "code": "class Solution {\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\n        List<String> ans = new ArrayList();\n        for (String word: words)\n            if (match(word, pattern))\n                ans.add(word);\n        return ans;\n    }\n\n    public boolean match(String word, String pattern) {\n        Map<Character, Character> m1 = new HashMap();\n        Map<Character, Character> m2 = new HashMap();\n\n        for (int i = 0; i < word.length(); ++i) {\n            char w = word.charAt(i);\n            char p = pattern.charAt(i);\n            if (!m1.containsKey(w)) m1.put(w, p);\n            if (!m2.containsKey(p)) m2.put(p, w);\n            if (m1.get(w) != p || m2.get(p) != w)\n                return false;\n        }\n\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def findAndReplacePattern(self, words, pattern):\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return filter(match, words)"}, {"lang": "Java", "code": "class Solution {\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\n        List<String> ans = new ArrayList();\n        for (String word: words)\n            if (match(word, pattern))\n                ans.add(word);\n        return ans;\n    }\n\n    public boolean match(String word, String pattern) {\n        Map<Character, Character> M = new HashMap();\n        for (int i = 0; i < word.length(); ++i) {\n            char w = word.charAt(i);\n            char p = pattern.charAt(i);\n            if (!M.containsKey(w)) M.put(w, p);\n            if (M.get(w) != p) return false;\n        }\n\n        boolean[] seen = new boolean[26];\n        for (char p: M.values()) {\n            if (seen[p - 'a']) return false;\n            seen[p - 'a'] = true;\n        }\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def findAndReplacePattern(self, words, pattern):\n        def match(word):\n            P = {}\n            for x, y in zip(pattern, word):\n                if P.setdefault(x, y) != y:\n                    return False\n            return len(set(P.values())) == len(P.values())\n\n        return filter(match, words)"}]}
{"url": "https://leetcode-cn.com/problems/sum-of-subsequence-widths", "source": [{"lang": "Java", "code": "class Solution {\n    public int sumSubseqWidths(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n        Arrays.sort(A);\n\n        long[] pow2 = new long[N];\n        pow2[0] = 1;\n        for (int i = 1; i < N; ++i)\n            pow2[i] = pow2[i-1] * 2 % MOD;\n\n        long ans = 0;\n        for (int i = 0; i < N; ++i)\n            ans = (ans + (pow2[i] - pow2[N-1-i]) * A[i]) % MOD;\n\n        return (int) ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def sumSubseqWidths(self, A):\n        MOD = 10**9 + 7\n        N = len(A)\n        A.sort()\n\n        pow2 = [1]\n        for i in xrange(1, N):\n            pow2.append(pow2[-1] * 2 % MOD)\n\n        ans = 0\n        for i, x in enumerate(A):\n            ans = (ans + (pow2[i] - pow2[N-1-i]) * x) % MOD\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/surface-area-of-3d-shapes", "source": [{"lang": "Java", "code": "class Solution {\n    public int surfaceArea(int[][] grid) {\n        int[] dr = new int[]{0, 1, 0, -1};\n        int[] dc = new int[]{1, 0, -1, 0};\n\n        int N = grid.length;\n        int ans = 0;\n\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] > 0) {\n                    ans += 2;\n                    for (int k = 0; k < 4; ++k) {\n                        int nr = r + dr[k];\n                        int nc = c + dc[k];\n                        int nv = 0;\n                        if (0 <= nr && nr < N && 0 <= nc && nc < N)\n                            nv = grid[nr][nc];\n\n                        ans += Math.max(grid[r][c] - nv, 0);\n                    }\n                }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def surfaceArea(self, grid):\n        N = len(grid)\n\n        ans = 0\n        for r in xrange(N):\n            for c in xrange(N):\n                if grid[r][c]:\n                    ans += 2\n                    for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r,c+1)):\n                        if 0 <= nr < N and 0 <= nc < N:\n                            nval = grid[nr][nc]\n                        else:\n                            nval = 0\n\n                        ans += max(grid[r][c] - nval, 0)\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/groups-of-special-equivalent-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/all-possible-full-binary-trees", "source": [{"lang": "Java", "code": "class Solution {\n    Map<Integer, List<TreeNode>> memo = new HashMap();\n\n    public List<TreeNode> allPossibleFBT(int N) {\n        if (!memo.containsKey(N)) {\n            List<TreeNode> ans = new LinkedList();\n            if (N == 1) {\n                ans.add(new TreeNode(0));\n            } else if (N % 2 == 1) {\n                for (int x = 0; x < N; ++x) {\n                    int y = N - 1 - x;\n                    for (TreeNode left: allPossibleFBT(x))\n                        for (TreeNode right: allPossibleFBT(y)) {\n                            TreeNode bns = new TreeNode(0);\n                            bns.left = left;\n                            bns.right = right;\n                            ans.add(bns);\n                        }\n                }\n            }\n            memo.put(N, ans);\n        }\n\n        return memo.get(N);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    memo = {0: [], 1: [TreeNode(0)]}\n\n    def allPossibleFBT(self, N):\n        if N not in Solution.memo:\n            ans = []\n            for x in xrange(N):\n                y = N - 1 - x\n                for left in self.allPossibleFBT(x):\n                    for right in self.allPossibleFBT(y):\n                        bns = TreeNode(0)\n                        bns.left = left\n                        bns.right = right\n                        ans.append(bns)\n            Solution.memo[N] = ans\n\n        return Solution.memo[N]"}]}
{"url": "https://leetcode-cn.com/problems/maximum-frequency-stack", "source": []}
{"url": "https://leetcode-cn.com/problems/monotonic-array", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean isMonotonic(int[] A) {\n        return increasing(A) || decreasing(A);\n    }\n\n    public boolean increasing(int[] A) {\n        for (int i = 0; i < A.length - 1; ++i)\n            if (A[i] > A[i+1]) return false;\n        return true;\n    }\n\n    public boolean decreasing(int[] A) {\n        for (int i = 0; i < A.length - 1; ++i)\n            if (A[i] < A[i+1]) return false;\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isMonotonic(self, A):\n        return (all(A[i] <= A[i+1] for i in xrange(len(A) - 1)) or\n                all(A[i] >= A[i+1] for i in xrange(len(A) - 1)))"}, {"lang": "Java", "code": "class Solution {\n    public boolean isMonotonic(int[] A) {\n        int store = 0;\n        for (int i = 0; i < A.length - 1; ++i) {\n            int c = Integer.compare(A[i], A[i+1]);\n            if (c != 0) {\n                if (c != store && store != 0)\n                    return false;\n                store = c;\n            }\n        }\n\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isMonotonic(self, A):\n        store = 0\n        for i in xrange(len(A) - 1):\n            c = cmp(A[i], A[i+1])\n            if c:\n                if c != store != 0:\n                    return False\n                store = c\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/increasing-order-search-tree", "source": [{"lang": "Java", "code": "class Solution {    \n    public TreeNode increasingBST(TreeNode root) {\n        List<Integer> vals = new ArrayList();\n        inorder(root, vals);\n        TreeNode ans = new TreeNode(0), cur = ans;\n        for (int v: vals) {\n            cur.right = new TreeNode(v);\n            cur = cur.right;\n        }\n        return ans.right;\n    }\n\n    public void inorder(TreeNode node, List<Integer> vals) {\n        if (node == null) return;\n        inorder(node.left, vals);\n        vals.add(node.val);\n        inorder(node.right, vals);\n    }\n}"}, {"lang": "Python3", "code": "class Solution:\n    def increasingBST(self, root):\n        def inorder(node):\n            if node:\n                yield from inorder(node.left)\n                yield node.val\n                yield from inorder(node.right)\n\n        ans = cur = TreeNode(None)\n        for v in inorder(root):\n            cur.right = TreeNode(v)\n            cur = cur.right\n        return ans.right"}, {"lang": "Java", "code": "class Solution {\n    TreeNode cur;\n    public TreeNode increasingBST(TreeNode root) {\n        TreeNode ans = new TreeNode(0);\n        cur = ans;\n        inorder(root);\n        return ans.right;\n    }\n\n    public void inorder(TreeNode node) {\n        if (node == null) return;\n        inorder(node.left);\n        node.left = null;\n        cur.right = node;\n        cur = node;\n        inorder(node.right);\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def increasingBST(self, root):\n        def inorder(node):\n            if node:\n                inorder(node.left)\n                node.left = None\n                self.cur.right = node\n                self.cur = node\n                inorder(node.right)\n\n        ans = self.cur = TreeNode(None)\n        inorder(root)\n        return ans.right"}]}
{"url": "https://leetcode-cn.com/problems/bitwise-ors-of-subarrays", "source": [{"lang": "Java", "code": "class Solution {\n    public int subarrayBitwiseORs(int[] A) {\n        Set<Integer> ans = new HashSet();\n        Set<Integer> cur = new HashSet();\n        cur.add(0);\n        for (int x: A) {\n            Set<Integer> cur2 = new HashSet();\n            for (int y: cur)\n                cur2.add(x | y);\n            cur2.add(x);\n            cur = cur2;\n            ans.addAll(cur);\n        }\n\n        return ans.size();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def subarrayBitwiseORs(self, A):\n        ans = set()\n        cur = {0}\n        for x in A:\n            cur = {x | y for y in cur} | {x}\n            ans |= cur\n        return len(ans)"}]}
{"url": "https://leetcode-cn.com/problems/orderly-queue", "source": [{"lang": "Java", "code": "class Solution {\n    public String orderlyQueue(String S, int K) {\n        if (K == 1) {\n            String ans = S;\n            for (int i = 0; i < S.length(); ++i) {\n                String T = S.substring(i) + S.substring(0, i);\n                if (T.compareTo(ans) < 0) ans = T;\n            }\n            return ans;\n        } else {\n            char[] ca = S.toCharArray();\n            Arrays.sort(ca);\n            return new String(ca);\n        }\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def orderlyQueue(self, S, K):\n        if K == 1:\n            return min(S[i:] + S[:i] for i in range(len(S)))\n        return \"\".join(sorted(S))"}]}
{"url": "https://leetcode-cn.com/problems/rle-iterator", "source": []}
{"url": "https://leetcode-cn.com/problems/online-stock-span", "source": []}
{"url": "https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-permutations-for-di-sequence", "source": []}
{"url": "https://leetcode-cn.com/problems/fruit-into-baskets", "source": [{"lang": "Java", "code": "class Solution {\n    public int totalFruit(int[] tree) {\n        // We'll make a list of indexes for which a block starts.\n        List<Integer> blockLefts = new ArrayList();\n\n        // Add the left boundary of each block\n        for (int i = 0; i < tree.length; ++i)\n            if (i == 0 || tree[i-1] != tree[i])\n                blockLefts.add(i);\n\n        // Add tree.length as a sentinel for convenience\n        blockLefts.add(tree.length);\n\n        int ans = 0, i = 0;\n        search: while (true) {\n            // We'll start our scan at block[i].\n            // types : the different values of tree[i] seen\n            // weight : the total number of trees represented\n            //          by blocks under consideration\n            Set<Integer> types = new HashSet();\n            int weight = 0;\n\n            // For each block from the i-th and going forward,\n            for (int j = i; j < blockLefts.size() - 1; ++j) {\n                // Add each block to consideration\n                types.add(tree[blockLefts.get(j)]);\n                weight += blockLefts.get(j+1) - blockLefts.get(j);\n\n                // If we have 3+ types, this is an illegal subarray\n                if (types.size() >= 3) {\n                    i = j - 1;\n                    continue search;\n                }\n\n                // If it is a legal subarray, record the answer\n                ans = Math.max(ans, weight);\n            }\n\n            break;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def totalFruit(self, tree):\n        blocks = [(k, len(list(v)))\n                  for k, v in itertools.groupby(tree)]\n\n        ans = i = 0\n        while i < len(blocks):\n            # We'll start our scan at block[i].\n            # types : the different values of tree[i] seen\n            # weight : the total number of trees represented\n            #          by blocks under consideration\n            types, weight = set(), 0\n\n            # For each block from i and going forward,\n            for j in xrange(i, len(blocks)):\n                # Add each block to consideration\n                types.add(blocks[j][0])\n                weight += blocks[j][1]\n\n                # If we have 3 types, this is not a legal subarray\n                if len(types) >= 3:\n                    i = j-1\n                    break\n\n                ans = max(ans, weight)\n\n            # If we go to the last block, then stop\n            else:\n                break\n\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int totalFruit(int[] tree) {\n        int ans = 0, i = 0;\n        Counter count = new Counter();\n        for (int j = 0; j < tree.length; ++j) {\n            count.add(tree[j], 1);\n            while (count.size() >= 3) {\n                count.add(tree[i], -1);\n                if (count.get(tree[i]) == 0)\n                    count.remove(tree[i]);\n                i++;\n            }\n\n            ans = Math.max(ans, j - i + 1);\n        }\n\n        return ans;\n    }\n}\n\nclass Counter extends HashMap<Integer, Integer> {\n    public int get(int k) {\n        return containsKey(k) ? super.get(k) : 0;\n    }\n\n    public void add(int k, int v) {\n        put(k, get(k) + v);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def totalFruit(self, tree):\n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/sort-array-by-parity", "source": []}
{"url": "https://leetcode-cn.com/problems/super-palindromes", "source": [{"lang": "Java", "code": "class Solution {\n    public int superpalindromesInRange(String sL, String sR) {\n        long L = Long.valueOf(sL);\n        long R = Long.valueOf(sR);\n        int MAGIC = 100000;\n        int ans = 0;\n\n        // count odd length;\n        for (int k = 1; k < MAGIC; ++k) {\n            StringBuilder sb = new StringBuilder(Integer.toString(k));\n            for (int i = sb.length() - 2; i >= 0; --i)\n                sb.append(sb.charAt(i));\n            long v = Long.valueOf(sb.toString());\n            v *= v;\n            if (v > R) break;\n            if (v >= L && isPalindrome(v)) ans++;\n        }\n\n        // count even length;\n        for (int k = 1; k < MAGIC; ++k) {\n            StringBuilder sb = new StringBuilder(Integer.toString(k));\n            for (int i = sb.length() - 1; i >= 0; --i)\n                sb.append(sb.charAt(i));\n            long v = Long.valueOf(sb.toString());\n            v *= v;\n            if (v > R) break;\n            if (v >= L && isPalindrome(v)) ans++;\n        }\n\n        return ans;\n    }\n\n    public boolean isPalindrome(long x) {\n        return x == reverse(x);\n    }\n\n    public long reverse(long x) {\n        long ans = 0;\n        while (x > 0) {\n            ans = 10 * ans + x % 10;\n            x /= 10;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def superpalindromesInRange(self, L, R):\n        L, R = int(L), int(R)\n        MAGIC = 100000\n\n        def reverse(x):\n            ans = 0\n            while x:\n                ans = 10 * ans + x % 10\n                x /= 10\n            return ans\n\n        def is_palindrome(x):\n            return x == reverse(x)\n\n        ans = 0\n\n        # count odd length\n        for k in xrange(MAGIC):\n            s = str(k)  # Eg. s = '1234'\n            t = s + s[-2::-1]  # t = '1234321'\n            v = int(t) ** 2\n            if v > R: break\n            if v >= L and is_palindrome(v):\n                ans += 1\n\n        # count even length\n        for k in xrange(MAGIC):\n            s = str(k)  # Eg. s = '1234'\n            t = s + s[::-1]  # t = '12344321'\n            v = int(t) ** 2\n            if v > R: break\n            if v >= L and is_palindrome(v):\n                ans += 1\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/sum-of-subarray-minimums", "source": [{"lang": "Java", "code": "class Solution {\n    public int sumSubarrayMins(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n\n        // prev has i* - 1 in increasing order of A[i* - 1]\n        // where i* is the answer to query j\n        Stack<Integer> stack = new Stack();\n        int[] prev = new int[N];\n        for (int i = 0; i < N; ++i) {\n            while (!stack.isEmpty() && A[i] <= A[stack.peek()])\n                stack.pop();\n            prev[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n\n        // next has k* + 1 in increasing order of A[k* + 1]\n        // where k* is the answer to query j\n        stack = new Stack();\n        int[] next = new int[N];\n        for (int k = N-1; k >= 0; --k) {\n            while (!stack.isEmpty() && A[k] < A[stack.peek()])\n                stack.pop();\n            next[k] = stack.isEmpty() ? N : stack.peek();\n            stack.push(k);\n        }\n\n        // Use prev/next array to count answer\n        long ans = 0;\n        for (int i = 0; i < N; ++i) {\n            ans += (i - prev[i]) * (next[i] - i) % MOD * A[i] % MOD;\n            ans %= MOD;\n        }\n        return (int) ans;\n\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def sumSubarrayMins(self, A):\n        MOD = 10**9 + 7\n        N = len(A)\n\n        # prev has i* - 1 in increasing order of A[i* - 1]\n        # where i* is the answer to query j\n        stack = []\n        prev = [None] * N\n        for i in xrange(N):\n            while stack and A[i] <= A[stack[-1]]:\n                stack.pop()\n            prev[i] = stack[-1] if stack else -1\n            stack.append(i)\n\n        # next has k* + 1 in increasing order of A[k* + 1]\n        # where k* is the answer to query j\n        stack = []\n        next_ = [None] * N\n        for k in xrange(N-1, -1, -1):\n            while stack and A[k] < A[stack[-1]]:\n                stack.pop()\n            next_[k] = stack[-1] if stack else N\n            stack.append(k)\n\n        # Use prev/next array to count answer\n        return sum((i - prev[i]) * (next_[i] - i) * A[i]\n                   for i in xrange(N)) % MOD"}, {"lang": "Java", "code": "class Solution {\n    public int sumSubarrayMins(int[] A) {\n        int MOD = 1_000_000_007;\n\n        Stack<RepInteger> stack = new Stack();\n        int ans = 0, dot = 0;\n        for (int j = 0; j < A.length; ++j) {\n            // Add all answers for subarrays [i, j], i <= j\n            int count = 1;\n            while (!stack.isEmpty() && stack.peek().val >= A[j]) {\n                RepInteger node = stack.pop();\n                count += node.count;\n                dot -= node.val * node.count;\n            }\n            stack.push(new RepInteger(A[j], count));\n            dot += A[j] * count;\n            ans += dot;\n            ans %= MOD;\n        }\n\n        return ans;\n    }\n}\n\nclass RepInteger {\n    int val, count;\n    RepInteger(int v, int c) {\n        val = v;\n        count = c;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def sumSubarrayMins(self, A):\n        MOD = 10**9 + 7\n\n        stack = []\n        ans = dot = 0\n        for j, y in enumerate(A):\n            # Add all answers for subarrays [i, j], i <= j\n            count = 1\n            while stack and stack[-1][0] >= y:\n                x, c = stack.pop()\n                count += c\n                dot -= x * c\n\n            stack.append((y, count))\n            dot += y * count\n            ans += dot\n        return ans % MOD"}]}
{"url": "https://leetcode-cn.com/problems/smallest-range-i", "source": []}
{"url": "https://leetcode-cn.com/problems/snakes-and-ladders", "source": [{"lang": "Java", "code": "class Solution {\n    public int snakesAndLadders(int[][] board) {\n        int N = board.length;\n\n        Map<Integer, Integer> dist = new HashMap();\n        dist.put(1, 0);\n\n        Queue<Integer> queue = new LinkedList();\n        queue.add(1);\n\n        while (!queue.isEmpty()) {\n            int s = queue.remove();\n            if (s == N*N) return dist.get(s);\n\n            for (int s2 = s+1; s2 <= Math.min(s+6, N*N); ++s2) {\n                int rc = get(s2, N);\n                int r = rc / N, c = rc % N;\n                int s2Final = board[r][c] == -1 ? s2 : board[r][c];\n                if (!dist.containsKey(s2Final)) {\n                    dist.put(s2Final, dist.get(s) + 1);\n                    queue.add(s2Final);\n                }\n            }\n        }\n        return -1;\n    }\n\n    public int get(int s, int N) {\n        // Given a square num s, return board coordinates (r, c) as r*N + c\n        int quot = (s-1) / N;\n        int rem = (s-1) % N;\n        int row = N - 1 - quot;\n        int col = row % 2 != N % 2 ? rem : N - 1 - rem;\n        return row * N + col;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def snakesAndLadders(self, board):\n        N = len(board)\n\n        def get(s):\n            # Given a square num s, return board coordinates (r, c)\n            quot, rem = divmod(s-1, N)\n            row = N - 1 - quot\n            col = rem if row%2 != N%2 else N - 1 - rem\n            return row, col\n\n        dist = {1: 0}\n        queue = collections.deque([1])\n        while queue:\n            s = queue.popleft()\n            if s == N*N: return dist[s]\n            for s2 in xrange(s+1, min(s+6, N*N) + 1):\n                r, c = get(s2)\n                if board[r][c] != -1:\n                    s2 = board[r][c]\n                if s2 not in dist:\n                    dist[s2] = dist[s] + 1\n                    queue.append(s2)\n        return -1"}]}
{"url": "https://leetcode-cn.com/problems/smallest-range-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/online-election", "source": [{"lang": "Java", "code": "class TopVotedCandidate {\n    List<List<Vote>> A;\n    public TopVotedCandidate(int[] persons, int[] times) {\n        A = new ArrayList();\n        Map<Integer, Integer> count = new HashMap();\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i], t = times[i];\n            int c = count.getOrDefault(p, 0) + 1;\n\n            count.put(p, c);\n            while (A.size() <= c)\n                A.add(new ArrayList<Vote>());\n            A.get(c).add(new Vote(p, t));\n        }\n    }\n\n    public int q(int t) {\n        // Binary search on A[i][0].time for smallest i\n        // such that A[i][0].time > t\n        int lo = 1, hi = A.size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(mi).get(0).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        int i = lo - 1;\n\n        // Binary search on A[i][j].time for smallest j\n        // such that A[i][j].time > t\n        lo = 0; hi = A.get(i).size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(i).get(mi).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        int j = Math.max(lo-1, 0);\n        return A.get(i).get(j).person;\n    }\n}\n\nclass Vote {\n    int person, time;\n    Vote(int p, int t) {\n        person = p;\n        time = t;\n    }\n}"}, {"lang": "Python", "code": "class TopVotedCandidate(object):\n\n    def __init__(self, persons, times):\n        self.A = []\n        self.count = collections.Counter()\n        for p, t in zip(persons, times):\n            self.count[p] = c = self.count[p] + 1\n            while len(self.A) <= c: self.A.append([])\n            self.A[c].append((t, p))\n\n    def q(self, t):\n        lo, hi = 1, len(self.A)\n        while lo < hi:\n            mi = (lo + hi) / 2\n            if self.A[mi][0][0] <= t:\n                lo = mi + 1\n            else:\n                hi = mi\n        i = lo - 1\n        j = bisect.bisect(self.A[i], (t, float('inf')))\n        return self.A[i][j-1][1]"}, {"lang": "Java", "code": "class TopVotedCandidate {\n    List<Vote> A;\n    public TopVotedCandidate(int[] persons, int[] times) {\n        A = new ArrayList();\n        Map<Integer, Integer> count = new HashMap();\n        int leader = -1;  // current leader\n        int m = 0;  // current number of votes for leader\n\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i], t = times[i];\n            int c = count.getOrDefault(p, 0) + 1;\n            count.put(p, c);\n\n            if (c >= m) {\n                if (p != leader) {  // lead change\n                    leader = p;\n                    A.add(new Vote(leader, t));\n                }\n\n                if (c > m) m = c;\n            }\n        }\n    }\n\n    public int q(int t) {\n        int lo = 1, hi = A.size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(mi).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n\n        return A.get(lo - 1).person;\n    }\n}\n\nclass Vote {\n    int person, time;\n    Vote(int p, int t) {\n        person = p;\n        time = t;\n    }\n}"}, {"lang": "Python", "code": "class TopVotedCandidate(object):\n    def __init__(self, persons, times):\n        self.A = []\n        count = collections.Counter()\n        leader, m = None, 0  # leader, num votes for leader\n\n        for p, t in itertools.izip(persons, times):\n            count[p] += 1\n            c = count[p]\n            if c >= m:\n                if p != leader:  # lead change\n                    leader = p\n                    self.A.append((t, leader))\n\n                if c > m:\n                    m = c\n\n    def q(self, t):\n        i = bisect.bisect(self.A, (t, float('inf')), 1)\n        return self.A[i-1][1]"}]}
{"url": "https://leetcode-cn.com/problems/sort-an-array", "source": []}
{"url": "https://leetcode-cn.com/problems/cat-and-mouse", "source": [{"lang": "Java", "code": "class Solution {\n    public int catMouseGame(int[][] graph) {\n        int N = graph.length;\n        final int DRAW = 0, MOUSE = 1, CAT = 2;\n\n        int[][][] color = new int[50][50][3];\n        int[][][] degree = new int[50][50][3];\n\n        // degree[node] : the number of neutral children of this node\n        for (int m = 0; m < N; ++m)\n            for (int c = 0; c < N; ++c) {\n                degree[m][c][1] = graph[m].length;\n                degree[m][c][2] = graph[c].length;\n                for (int x: graph[c]) if (x == 0) {\n                    degree[m][c][2]--;\n                    break;\n                }\n            }\n\n        // enqueued : all nodes that are colored\n        Queue<int[]> queue = new LinkedList();\n        for (int i = 0; i < N; ++i)\n            for (int t = 1; t <= 2; ++t) {\n                color[0][i][t] = MOUSE;\n                queue.add(new int[]{0, i, t, MOUSE});\n                if (i > 0) {\n                    color[i][i][t] = CAT;\n                    queue.add(new int[]{i, i, t, CAT});\n                }\n            }\n\n        // percolate\n        while (!queue.isEmpty()) {\n            // for nodes that are colored :\n            int[] node = queue.remove();\n            int i = node[0], j = node[1], t = node[2], c = node[3];\n            // for every parent of this node i, j, t :\n            for (int[] parent: parents(graph, i, j, t)) {\n                int i2 = parent[0], j2 = parent[1], t2 = parent[2];\n                // if this parent is not colored :\n                if (color[i2][j2][t2] == DRAW) {\n                    // if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if (t2 == c) {\n                        color[i2][j2][t2] = c;\n                        queue.add(new int[]{i2, j2, t2, c});\n                    } else {\n                        // else, this parent has degree[parent]--, and enqueue\n                        // if all children of this parent are colored as losing moves\n                        degree[i2][j2][t2]--;\n                        if (degree[i2][j2][t2] == 0) {\n                            color[i2][j2][t2] = 3 - t2;\n                            queue.add(new int[]{i2, j2, t2, 3 - t2});\n                        }\n                    }\n                }\n            }\n        }\n\n        return color[1][2][1];\n    }\n\n    // What nodes could play their turn to\n    // arrive at node (m, c, t) ?\n    public List<int[]> parents(int[][] graph, int m, int c, int t) {\n        List<int[]> ans = new ArrayList();\n        if (t == 2) {\n            for (int m2: graph[m])\n                ans.add(new int[]{m2, c, 3-t});\n        } else {\n            for (int c2: graph[c]) if (c2 > 0)\n                ans.add(new int[]{m, c2, 3-t});\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def catMouseGame(self, graph):\n        N = len(graph)\n\n        # What nodes could play their turn to\n        # arrive at node (m, c, t) ?\n        def parents(m, c, t):\n            if t == 2:\n                for m2 in graph[m]:\n                    yield m2, c, 3-t\n            else:\n                for c2 in graph[c]:\n                    if c2:\n                        yield m, c2, 3-t\n\n        DRAW, MOUSE, CAT = 0, 1, 2\n        color = collections.defaultdict(int)\n\n        # degree[node] : the number of neutral children of this node\n        degree = {}\n        for m in xrange(N):\n            for c in xrange(N):\n                degree[m,c,1] = len(graph[m])\n                degree[m,c,2] = len(graph[c]) - (0 in graph[c])\n\n        # enqueued : all nodes that are colored\n        queue = collections.deque([])\n        for i in xrange(N):\n            for t in xrange(1, 3):\n                color[0, i, t] = MOUSE\n                queue.append((0, i, t, MOUSE))\n                if i > 0:\n                    color[i, i, t] = CAT\n                    queue.append((i, i, t, CAT))\n\n        # percolate\n        while queue:\n            # for nodes that are colored :\n            i, j, t, c = queue.popleft()\n            # for every parent of this node i, j, t :\n            for i2, j2, t2 in parents(i, j, t):\n                # if this parent is not colored :\n                if color[i2, j2, t2] is DRAW:\n                    # if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if t2 == c: # winning move\n                        color[i2, j2, t2] = c\n                        queue.append((i2, j2, t2, c))\n                    # else, this parent has degree[parent]--, and enqueue if all children\n                    # of this parent are colored as losing moves\n                    else:\n                        degree[i2, j2, t2] -= 1\n                        if degree[i2, j2, t2] == 0:\n                            color[i2, j2, t2] = 3 - t2\n                            queue.append((i2, j2, t2, 3 - t2))\n\n        return color[1, 2, 1]"}]}
{"url": "https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards", "source": []}
{"url": "https://leetcode-cn.com/problems/partition-array-into-disjoint-intervals", "source": [{"lang": "Java", "code": "class Solution {\n    public int partitionDisjoint(int[] A) {\n        int N = A.length;\n        int[] maxleft = new int[N];\n        int[] minright = new int[N];\n\n        int m = A[0];\n        for (int i = 0; i < N; ++i) {\n            m = Math.max(m, A[i]);\n            maxleft[i] = m;\n        }\n\n        m = A[N-1];\n        for (int i = N-1; i >= 0; --i) {\n            m = Math.min(m, A[i]);\n            minright[i] = m;\n        }\n\n        for (int i = 1; i < N; ++i)\n            if (maxleft[i-1] <= minright[i])\n                return i;\n\n        throw null;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def partitionDisjoint(self, A):\n        N = len(A)\n        maxleft = [None] * N\n        minright = [None] * N\n\n        m = A[0]\n        for i in xrange(N):\n            m = max(m, A[i])\n            maxleft[i] = m\n\n        m = A[-1]\n        for i in xrange(N-1, -1, -1):\n            m = min(m, A[i])\n            minright[i] = m\n\n        for i in xrange(1, N):\n            if maxleft[i-1] <= minright[i]:\n                return i"}]}
{"url": "https://leetcode-cn.com/problems/word-subsets", "source": [{"lang": "Java", "code": "class Solution {\n    public List<String> wordSubsets(String[] A, String[] B) {\n        int[] bmax = count(\"\");\n        for (String b: B) {\n            int[] bCount = count(b);\n            for (int i = 0; i < 26; ++i)\n                bmax[i] = Math.max(bmax[i], bCount[i]);\n        }\n\n        List<String> ans = new ArrayList();\n        search: for (String a: A) {\n            int[] aCount = count(a);\n            for (int i = 0; i < 26; ++i)\n                if (aCount[i] < bmax[i])\n                    continue search;\n            ans.add(a);\n        }\n\n        return ans;\n    }\n\n    public int[] count(String S) {\n        int[] ans = new int[26];\n        for (char c: S.toCharArray())\n            ans[c - 'a']++;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def wordSubsets(self, A, B):\n        def count(word):\n            ans = [0] * 26\n            for letter in word:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n\n        bmax = [0] * 26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n\n        ans = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                ans.append(a)\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/reverse-only-letters", "source": [{"lang": "Java", "code": "class Solution {\n    public String reverseOnlyLetters(String S) {\n        Stack<Character> letters = new Stack();\n        for (char c: S.toCharArray())\n            if (Character.isLetter(c))\n                letters.push(c);\n\n        StringBuilder ans = new StringBuilder();\n        for (char c: S.toCharArray()) {\n            if (Character.isLetter(c))\n                ans.append(letters.pop());\n            else\n                ans.append(c);\n        }\n\n        return ans.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def reverseOnlyLetters(self, S):\n        letters = [c for c in S if c.isalpha()]\n        ans = []\n        for c in S:\n            if c.isalpha():\n                ans.append(letters.pop())\n            else:\n                ans.append(c)\n        return \"\".join(ans)"}, {"lang": "Java", "code": "class Solution {\n    public String reverseOnlyLetters(String S) {\n        StringBuilder ans = new StringBuilder();\n        int j = S.length() - 1;\n        for (int i = 0; i < S.length(); ++i) {\n            if (Character.isLetter(S.charAt(i))) {\n                while (!Character.isLetter(S.charAt(j)))\n                    j--;\n                ans.append(S.charAt(j--));\n            } else {\n                ans.append(S.charAt(i));\n            }\n        }\n\n        return ans.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def reverseOnlyLetters(self, S):\n        ans = []\n        j = len(ans) - 1\n        for i, x in enumerate(S):\n            if x.isalpha():\n                while not S[j].isalpha():\n                    j -= 1\n                ans.append(S[j])\n                j -= 1\n            else:\n                ans.append(x)\n        \n        return \"\".join(ans)"}]}
{"url": "https://leetcode-cn.com/problems/maximum-sum-circular-subarray", "source": [{"lang": "Python", "code": "#Kadane's algorithm\nans = cur = None\nfor x in A:\n    cur = x + max(cur, 0)\n    ans = max(ans, cur)\nreturn ans"}, {"lang": "Java", "code": "class Solution {\n    public int maxSubarraySumCircular(int[] A) {\n        int N = A.length;\n\n        int ans = A[0], cur = A[0];\n        for (int i = 1; i < N; ++i) {\n            cur = A[i] + Math.max(cur, 0);\n            ans = Math.max(ans, cur);\n        }\n\n        // ans is the answer for 1-interval subarrays.\n        // Now, let's consider all 2-interval subarrays.\n        // For each i, we want to know\n        // the maximum of sum(A[j:]) with j >= i+2\n\n        // rightsums[i] = A[i] + A[i+1] + ... + A[N-1]\n        int[] rightsums = new int[N];\n        rightsums[N-1] = A[N-1];\n        for (int i = N-2; i >= 0; --i)\n            rightsums[i] = rightsums[i+1] + A[i];\n\n        // maxright[i] = max_{j >= i} rightsums[j]\n        int[] maxright = new int[N];\n        maxright[N-1] = A[N-1];\n        for (int i = N-2; i >= 0; --i)\n            maxright[i] = Math.max(maxright[i+1], rightsums[i]);\n\n        int leftsum = 0;\n        for (int i = 0; i < N-2; ++i) {\n            leftsum += A[i];\n            ans = Math.max(ans, leftsum + maxright[i+2]);\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maxSubarraySumCircular(self, A):\n        N = len(A)\n\n        ans = cur = None\n        for x in A:\n            cur = x + max(cur, 0)\n            ans = max(ans, cur)\n\n        # ans is the answer for 1-interval subarrays.\n        # Now, let's consider all 2-interval subarrays.\n        # For each i, we want to know\n        # the maximum of sum(A[j:]) with j >= i+2\n\n        # rightsums[i] = sum(A[i:])\n        rightsums = [None] * N\n        rightsums[-1] = A[-1]\n        for i in xrange(N-2, -1, -1):\n            rightsums[i] = rightsums[i+1] + A[i]\n\n        # maxright[i] = max_{j >= i} rightsums[j]\n        maxright = [None] * N\n        maxright[-1] = rightsums[-1]\n        for i in xrange(N-2, -1, -1):\n            maxright[i] = max(maxright[i+1], rightsums[i])\n\n        leftsum = 0\n        for i in xrange(N-2):\n            leftsum += A[i]\n            ans = max(ans, leftsum + maxright[i+2])\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int maxSubarraySumCircular(int[] A) {\n        int N = A.length;\n\n        // Compute P[j] = B[0] + B[1] + ... + B[j-1]\n        // for fixed array B = A+A\n        int[] P = new int[2*N+1];\n        for (int i = 0; i < 2*N; ++i)\n            P[i+1] = P[i] + A[i % N];\n\n        // Want largest P[j] - P[i] with 1 <= j-i <= N\n        // For each j, want smallest P[i] with i >= j-N\n        int ans = A[0];\n        // deque: i's, increasing by P[i]\n        Deque<Integer> deque = new ArrayDeque();\n        deque.offer(0);\n\n        for (int j = 1; j <= 2*N; ++j) {\n            // If the smallest i is too small, remove it.\n            if (deque.peekFirst() < j-N)\n                deque.pollFirst();\n\n            // The optimal i is deque[0], for cand. answer P[j] - P[i].\n            ans = Math.max(ans, P[j] - P[deque.peekFirst()]);\n\n            // Remove any i1's with P[i2] <= P[i1].\n            while (!deque.isEmpty() && P[j] <= P[deque.peekLast()])\n                deque.pollLast();\n\n            deque.offerLast(j);\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maxSubarraySumCircular(self, A):\n        N = len(A)\n\n        # Compute P[j] = sum(B[:j]) for the fixed array B = A+A\n        P = [0]\n        for _ in xrange(2):\n            for x in A:\n                P.append(P[-1] + x)\n\n        # Want largest P[j] - P[i] with 1 <= j-i <= N\n        # For each j, want smallest P[i] with i >= j-N\n        ans = A[0]\n        deque = collections.deque([0]) # i's, increasing by P[i]\n        for j in xrange(1, len(P)):\n            # If the smallest i is too small, remove it.\n            if deque[0] < j-N:\n                deque.popleft()\n\n            # The optimal i is deque[0], for cand. answer P[j] - P[i].\n            ans = max(ans, P[j] - P[deque[0]])\n\n            # Remove any i1's with P[i2] <= P[i1].\n            while deque and P[j] <= P[deque[-1]]:\n                deque.pop()\n\n            deque.append(j)\n\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int maxSubarraySumCircular(int[] A) {\n        int S = 0;  // S = sum(A)\n        for (int x: A)\n            S += x;\n\n        int ans1 = kadane(A, 0, A.length-1, 1);\n        int ans2 = S + kadane(A, 1, A.length-1, -1);\n        int ans3 = S + kadane(A, 0, A.length-2, -1);\n        return Math.max(ans1, Math.max(ans2, ans3));\n    }\n\n    public int kadane(int[] A, int i, int j, int sign) {\n        // The maximum non-empty subarray for array\n        // [sign * A[i], sign * A[i+1], ..., sign * A[j]]\n        int ans = Integer.MIN_VALUE;\n        int cur = Integer.MIN_VALUE;\n        for (int k = i; k <= j; ++k) {\n            cur = sign * A[k] + Math.max(cur, 0);\n            ans = Math.max(ans, cur);\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maxSubarraySumCircular(self, A):\n        def kadane(gen):\n            # Maximum non-empty subarray sum\n            ans = cur = None\n            for x in gen:\n                cur = x + max(cur, 0)\n                ans = max(ans, cur)\n            return ans\n\n        S = sum(A)\n        ans1 = kadane(iter(A))\n        ans2 = S + kadane(-A[i] for i in xrange(1, len(A)))\n        ans3 = S + kadane(-A[i] for i in xrange(len(A) - 1))\n        return max(ans1, ans2, ans3)"}, {"lang": "Java", "code": "class Solution {\n    public int maxSubarraySumCircular(int[] A) {\n        // S: sum of A\n        int S = 0;\n        for (int x: A)\n            S += x;\n\n        // ans1: answer for one-interval subarray\n        int ans1 = Integer.MIN_VALUE;\n        int cur = Integer.MIN_VALUE;\n        for (int x: A) {\n            cur = x + Math.max(cur, 0);\n            ans1 = Math.max(ans1, cur);\n        }\n\n        // ans2: answer for two-interval subarray, interior in A[1:]\n        int ans2 = Integer.MAX_VALUE;\n        cur = Integer.MAX_VALUE;\n        for (int i = 1; i < A.length; ++i) {\n            cur = A[i] + Math.min(cur, 0);\n            ans2 = Math.min(ans2, cur);\n        }\n        ans2 = S - ans2;\n\n        // ans3: answer for two-interval subarray, interior in A[:-1]\n        int ans3 = Integer.MAX_VALUE;\n        cur = Integer.MAX_VALUE;\n        for (int i = 0; i < A.length - 1; ++i) {\n            cur = A[i] + Math.min(cur, 0);\n            ans3 = Math.min(ans3, cur);\n        }\n\n        return Math.max(ans1, Math.max(ans2, ans3));\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maxSubarraySumCircular(self, A):\n        # ans1: answer for one-interval subarray\n        ans1 = cur = None\n        for x in A:\n            cur = x + max(cur, 0)\n            ans1 = max(ans1, cur)\n\n        # ans2: answer for two-interval subarray, interior in A[1:]\n        ans2 = cur = float('inf')\n        for i in xrange(1, len(A)):\n            cur = A[i] + min(cur, 0)\n            ans2 = min(ans2, cur)\n        ans2 = sum(A) - ans2\n\n        # ans3: answer for two-interval subarray, interior in A[:-1]\n        ans3 = cur = float('inf')\n        for i in xrange(len(A)-1):\n            cur = A[i] + min(cur, 0)\n            ans3 = min(ans3, cur)\n        ans3 = sum(A) - ans3\n        \n        return max(ans1, ans2, ans3)"}]}
{"url": "https://leetcode-cn.com/problems/complete-binary-tree-inserter", "source": [{"lang": "Java", "code": "class CBTInserter {\n    TreeNode root;\n    Deque<TreeNode> deque;\n    public CBTInserter(TreeNode root) {\n        this.root = root;\n        deque = new LinkedList();\n        Queue<TreeNode> queue = new LinkedList();\n        queue.offer(root);\n\n        // BFS to populate deque\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.left == null || node.right == null)\n                deque.offerLast(node);\n            if (node.left != null)\n                queue.offer(node.left);\n            if (node.right != null)\n                queue.offer(node.right);\n        }\n    }\n\n    public int insert(int v) {\n        TreeNode node = deque.peekFirst();\n        deque.offerLast(new TreeNode(v));\n        if (node.left == null)\n            node.left = deque.peekLast();\n        else {\n            node.right = deque.peekLast();\n            deque.pollFirst();\n        }\n\n        return node.val;\n    }\n\n    public TreeNode get_root() {\n        return root;\n    }\n}"}, {"lang": "Python", "code": "class CBTInserter(object):\n    def __init__(self, root):\n        self.deque = collections.deque()\n        self.root = root\n        q = collections.deque([root])\n        while q:\n            node = q.popleft()\n            if not node.left or not node.right:\n                self.deque.append(node)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    def insert(self, v):\n        node = self.deque[0]\n        self.deque.append(TreeNode(v))\n        if not node.left:\n            node.left = self.deque[-1]\n        else:\n            node.right = self.deque[-1]\n            self.deque.popleft()\n        return node.val\n\n    def get_root(self):\n        return self.root"}]}
{"url": "https://leetcode-cn.com/problems/number-of-music-playlists", "source": [{"lang": "Java", "code": "class Solution {\n    public int numMusicPlaylists(int N, int L, int K) {\n        int MOD = 1_000_000_007;\n\n        long[][] dp = new long[L+1][N+1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= L; ++i)\n            for (int j = 1; j <= N; ++j) {\n                dp[i][j] += dp[i-1][j-1] * (N-j+1);\n                dp[i][j] += dp[i-1][j] * Math.max(j-K, 0);\n                dp[i][j] %= MOD;\n            }\n\n        return (int) dp[L][N];\n    }\n}"}, {"lang": "Python", "code": "from functools import lru_cache\n\nclass Solution:\n    def numMusicPlaylists(self, N, L, K):\n        @lru_cache(None)\n        def dp(i, j):\n            if i == 0:\n                return +(j == 0)\n            ans = dp(i-1, j-1) * (N-j+1)\n            ans += dp(i-1, j) * max(j-K, 0)\n            return ans % (10**9+7)\n\n        return dp(L, N)"}, {"lang": "Java", "code": "class Solution {\n    public int numMusicPlaylists(int N, int L, int K) {\n        int MOD = 1_000_000_007;\n\n        // dp[S] at time P = <S, P> as discussed in article\n        long[] dp = new long[L-N+1];\n        Arrays.fill(dp, 1);\n        for (int p = 2; p <= N-K; ++p)\n            for (int i = 1; i <= L-N; ++i) {\n                dp[i] += dp[i-1] * p;\n                dp[i] %= MOD;\n            }\n\n        // Multiply by N!\n        long ans = dp[L-N];\n        for (int k = 2; k <= N; ++k)\n            ans = ans * k % MOD;\n        return (int) ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numMusicPlaylists(self, N, L, K):\n        # dp[S] at time P = <S, P> as discussed in article\n        dp = [1] * (L-N+1)\n        for p in xrange(2, N-K+1):\n            for i in xrange(1, L-N+1):\n                dp[i] += dp[i-1] * p\n\n        # Multiply by N!\n        ans = dp[-1]\n        for k in xrange(2, N+1):\n            ans *= k\n        return ans % (10**9 + 7)"}, {"lang": "Python", "code": "class Solution(object):\n    def numMusicPlaylists(self, N, L, K):\n        MOD = 10**9 + 7\n        def inv(x):\n            return pow(x, MOD-2, MOD)\n\n        C = 1\n        for x in xrange(1, N-K):\n            C *= -x\n            C %= MOD\n        C = inv(C)\n\n        ans = 0\n        for k in xrange(1, N-K+1):\n            ans += pow(k, L-K-1, MOD) * C\n            C = C * (k - (N-K)) % MOD * inv(k) % MOD\n\n        for k in xrange(1, N+1):\n            ans = ans * k % MOD\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid", "source": []}
{"url": "https://leetcode-cn.com/problems/sort-array-by-parity-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/3sum-with-multiplicity", "source": []}
{"url": "https://leetcode-cn.com/problems/minimize-malware-spread", "source": []}
{"url": "https://leetcode-cn.com/problems/long-pressed-name", "source": []}
{"url": "https://leetcode-cn.com/problems/flip-string-to-monotone-increasing", "source": []}
{"url": "https://leetcode-cn.com/problems/three-equal-parts", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] threeEqualParts(int[] A) {\n        int[] IMP = new int[]{-1, -1};\n        int N = A.length;\n\n        int S = 0;\n        for (int x: A) S += x;\n        if (S % 3 != 0) return IMP;\n        int T = S / 3;\n        if (T == 0)\n            return new int[]{0, N - 1};\n\n        int i1 = -1, j1 = -1, i2 = -1, j2 = -1, i3 = -1, j3 = -1;\n        int su = 0;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 1) {\n                su += 1;\n                if (su == 1) i1 = i;\n                if (su == T) j1 = i;\n                if (su == T+1) i2 = i;\n                if (su == 2*T) j2 = i;\n                if (su == 2*T + 1) i3 = i;\n                if (su == 3*T) j3 = i;\n            }\n        }\n\n        // The array is in the form W [i1, j1] X [i2, j2] Y [i3, j3] Z\n        // where [i1, j1] is a block of 1s, etc.\n        int[] part1 = Arrays.copyOfRange(A, i1, j1+1);\n        int[] part2 = Arrays.copyOfRange(A, i2, j2+1);\n        int[] part3 = Arrays.copyOfRange(A, i3, j3+1);\n\n        if (!Arrays.equals(part1, part2)) return IMP;\n        if (!Arrays.equals(part1, part3)) return IMP;\n\n        // x, y, z: the number of zeros after part 1, 2, 3\n        int x = i2 - j1 - 1;\n        int y = i3 - j2 - 1;\n        int z = A.length - j3 - 1;\n\n        if (x < z || y < z) return IMP;\n        return new int[]{j1+z, j2+z+1};\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def threeEqualParts(self, A):\n        IMP = [-1, -1]\n\n        S = sum(A)\n        if S % 3: return IMP\n        T = S / 3\n        if T == 0:\n            return [0, len(A) - 1]\n\n        breaks = []\n        su = 0\n        for i, x in enumerate(A):\n            if x:\n                su += x\n                if su in {1, T+1, 2*T+1}:\n                    breaks.append(i)\n                if su in {T, 2*T, 3*T}:\n                    breaks.append(i)\n\n        i1, j1, i2, j2, i3, j3 = breaks\n\n        # The array is in the form W [i1, j1] X [i2, j2] Y [i3, j3] Z\n        # where [i1, j1] is a block of 1s, etc.\n        if not(A[i1:j1+1] == A[i2:j2+1] == A[i3:j3+1]):\n            return [-1,-1]\n\n        # x, y, z: the number of zeros after part 1, 2, 3\n        x = i2 - j1 - 1\n        y = i3 - j2 - 1\n        z = len(A) - j3 - 1\n\n        if x < z or y < z: return IMP\n        j1 += z\n        j2 += z\n        return [j1, j2+1]"}]}
{"url": "https://leetcode-cn.com/problems/minimize-malware-spread-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/unique-email-addresses", "source": [{"lang": "Java", "code": "class Solution {\n    public int numUniqueEmails(String[] emails) {\n        Set<String> seen = new HashSet();\n        for (String email: emails) {\n            int i = email.indexOf('@');\n            String local = email.substring(0, i);\n            String rest = email.substring(i);\n            if (local.contains(\"+\")) {\n                local = local.substring(0, local.indexOf('+'));\n            }\n            local = local.replaceAll(\".\", \"\");\n            seen.add(local + rest);\n        }\n\n        return seen.size();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numUniqueEmails(self, emails):\n        seen = set()\n        for email in emails:\n            local, domain = email.split('@')\n            if '+' in local:\n                local = local[:local.index('+')]\n            seen.add(local.replace('.','') + '@' + domain)\n        return len(seen)"}]}
{"url": "https://leetcode-cn.com/problems/binary-subarrays-with-sum", "source": [{"lang": "Java", "code": "class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int su = 0;\n        for (int x: A) su += x;\n\n        // indexes[i] = location of i-th one (1 indexed)\n        int[] indexes = new int[su + 2];\n        int t = 0;\n        indexes[t++] = -1;\n        for (int i = 0; i < A.length; ++i)\n            if (A[i] == 1)\n                indexes[t++] = i;\n        indexes[t] = A.length;\n\n        int ans = 0;\n        if (S == 0) {\n            for (int i = 0; i < indexes.length - 1; ++i) {\n                // w: number of zeros between consecutive ones\n                int w = indexes[i+1] - indexes[i] - 1;\n                ans += w * (w + 1) / 2;\n            }\n            return ans;\n        }\n\n        for (int i = 1; i < indexes.length - S; ++i) {\n            int j = i + S - 1;\n            int left = indexes[i] - indexes[i-1];\n            int right = indexes[j+1] - indexes[j];\n            ans += left * right;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numSubarraysWithSum(self, A, S):\n        indexes = [-1] + [ix for ix, v in enumerate(A) if v] + [len(A)]\n        ans = 0\n\n        if S == 0:\n            for i in xrange(len(indexes) - 1):\n                # w: number of zeros between two consecutive ones\n                w = indexes[i+1] - indexes[i] - 1\n                ans += w * (w+1) / 2\n            return ans\n\n        for i in xrange(1, len(indexes) - S):\n            j = i + S - 1\n            left = indexes[i] - indexes[i-1]\n            right = indexes[j+1] - indexes[j]\n            ans += left * right\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int N = A.length;\n        int[] P = new int[N + 1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + A[i];\n\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        for (int x: P) {\n            ans += count.getOrDefault(x, 0);\n            count.put(x+S, count.getOrDefault(x+S, 0) + 1);\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numSubarraysWithSum(self, A, S):\n        P = [0]\n        for x in A: P.append(P[-1] + x)\n        count = collections.Counter()\n\n        ans = 0\n        for x in P:\n            ans += count[x]\n            count[x + S] += 1\n\n        return ans"}, {"lang": "Java", "code": "class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int iLo = 0, iHi = 0;\n        int sumLo = 0, sumHi = 0;\n        int ans = 0;\n\n        for (int j = 0; j < A.length; ++j) {\n            // While sumLo is too big, iLo++\n            sumLo += A[j];\n            while (iLo < j && sumLo > S)\n                sumLo -= A[iLo++];\n\n            // While sumHi is too big, or equal and we can move, iHi++\n            sumHi += A[j];\n            while (iHi < j && (sumHi > S || sumHi == S && A[iHi] == 0))\n                sumHi -= A[iHi++];\n\n            if (sumLo == S)\n                ans += iHi - iLo + 1;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numSubarraysWithSum(self, A, S):\n        i_lo = i_hi = 0\n        sum_lo = sum_hi = 0\n        ans = 0\n        for j, x in enumerate(A):\n            # Maintain i_lo, sum_lo:\n            # While the sum is too big, i_lo += 1\n            sum_lo += x\n            while i_lo < j and sum_lo > S:\n                sum_lo -= A[i_lo]\n                i_lo += 1\n\n            # Maintain i_hi, sum_hi:\n            # While the sum is too big, or equal and we can move, i_hi += 1\n            sum_hi += x\n            while i_hi < j and (\n                    sum_hi > S or sum_hi == S and not A[i_hi]):\n                sum_hi -= A[i_hi]\n                i_hi += 1\n\n            if sum_lo == S:\n                ans += i_hi - i_lo + 1\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/minimum-falling-path-sum", "source": [{"lang": "Java", "code": "class Solution {\n    public int minFallingPathSum(int[][] A) {\n        int N = A.length;\n        for (int r = N-2; r >= 0; --r) {\n            for (int c = 0; c < N; ++c) {\n                // best = min(A[r+1][c-1], A[r+1][c], A[r+1][c+1])\n                int best = A[r+1][c];\n                if (c > 0)\n                    best = Math.min(best, A[r+1][c-1]);\n                if (c+1 < N)\n                    best = Math.min(best, A[r+1][c+1]);\n                A[r][c] += best;\n            }\n        }\n\n        int ans = Integer.MAX_VALUE;\n        for (int x: A[0])\n            ans = Math.min(ans, x);\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minFallingPathSum(self, A):\n        while len(A) >= 2:\n            row = A.pop()            \n            for i in xrange(len(row)):\n                A[-1][i] += min(row[max(0,i-1): min(len(row), i+2)])\n        return min(A[0])"}]}
{"url": "https://leetcode-cn.com/problems/beautiful-array", "source": [{"lang": "Java", "code": "class Solution {\n    Map<Integer, int[]> memo;\n    public int[] beautifulArray(int N) {\n        memo = new HashMap();\n        return f(N);\n    }\n\n    public int[] f(int N) {\n        if (memo.containsKey(N))\n            return memo.get(N);\n\n        int[] ans = new int[N];\n        if (N == 1) {\n            ans[0] = 1;\n        } else {\n            int t = 0;\n            for (int x: f((N+1)/2))  // odds\n                ans[t++] = 2*x - 1;\n            for (int x: f(N/2))  // evens\n                ans[t++] = 2*x;\n        }\n        memo.put(N, ans);\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution:\n    def beautifulArray(self, N):\n        memo = {1: [1]}\n        def f(N):\n            if N not in memo:\n                odds = f((N+1)/2)\n                evens = f(N/2)\n                memo[N] = [2*x-1 for x in odds] + [2*x for x in evens]\n            return memo[N]\n        return f(N)"}]}
{"url": "https://leetcode-cn.com/problems/number-of-recent-calls", "source": [{"lang": "Java", "code": "class RecentCounter {\n    Queue<Integer> q;\n    public RecentCounter() {\n        q = new LinkedList();\n    }\n\n    public int ping(int t) {\n        q.add(t);\n        while (q.peek() < t - 3000)\n            q.poll();\n        return q.size();\n    }\n}"}, {"lang": "Python", "code": "class RecentCounter(object):\n    def __init__(self):\n        self.q = collections.deque()\n\n    def ping(self, t):\n        self.q.append(t)\n        while self.q[0] < t-3000:\n            self.q.popleft()\n        return len(self.q)"}]}
{"url": "https://leetcode-cn.com/problems/shortest-bridge", "source": [{"lang": "Java", "code": "class Solution {\n    public int shortestBridge(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] colors = getComponents(A);\n\n        Queue<Node> queue = new LinkedList();\n        Set<Integer> target = new HashSet();\n\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                if (colors[r][c] == 1) {\n                    queue.add(new Node(r, c, 0));\n                } else if (colors[r][c] == 2) {\n                    target.add(r * C + c);\n                }\n            }\n\n        while (!queue.isEmpty()) {\n            Node node = queue.poll();\n            if (target.contains(node.r * C + node.c))\n                return node.depth - 1;\n            for (int nei: neighbors(A, node.r, node.c)) {\n                int nr = nei / C, nc = nei % C;\n                if (colors[nr][nc] != 1) {\n                    queue.add(new Node(nr, nc, node.depth + 1));\n                    colors[nr][nc] = 1;\n                }\n            }\n        }\n\n        throw null;\n    }\n\n    public int[][] getComponents(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] colors = new int[R][C];\n        int t = 0;\n\n        for (int r0 = 0; r0 < R; ++r0)\n            for (int c0 = 0; c0 < C; ++c0)\n                if (colors[r0][c0] == 0 && A[r0][c0] == 1) {\n                    // Start dfs\n                    Stack<Integer> stack = new Stack();\n                    stack.push(r0 * C + c0);\n                    colors[r0][c0] = ++t;\n\n                    while (!stack.isEmpty()) {\n                        int node = stack.pop();\n                        int r = node / C, c = node % C;\n                        for (int nei: neighbors(A, r, c)) {\n                            int nr = nei / C, nc = nei % C;\n                            if (A[nr][nc] == 1 && colors[nr][nc] == 0) {\n                                colors[nr][nc] = t;\n                                stack.push(nr * C + nc);\n                            }\n                        }\n                    }\n                }\n\n        return colors;\n    }\n\n    public List<Integer> neighbors(int[][] A, int r, int c) {\n        int R = A.length, C = A[0].length;\n        List<Integer> ans = new ArrayList();\n        if (0 <= r-1) ans.add((r-1) * R + c);\n        if (0 <= c-1) ans.add(r * R + (c-1));\n        if (r+1 < R) ans.add((r+1) * R + c);\n        if (c+1 < C) ans.add(r * R + (c+1));\n        return ans;\n    }\n}\n\nclass Node {\n    int r, c, depth;\n    Node(int r, int c, int d) {\n        this.r = r;\n        this.c = c;\n        depth = d;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def shortestBridge(self, A):\n        R, C = len(A), len(A[0])\n\n        def neighbors(r, c):\n            for nr, nc in ((r-1,c),(r,c-1),(r+1,c),(r,c+1)):\n                if 0 <= nr < R and 0 <= nc < C:\n                    yield nr, nc\n\n        def get_components():\n            done = set()\n            components = []\n            for r, row in enumerate(A):\n                for c, val in enumerate(row):\n                    if val and (r, c) not in done:\n                        # Start dfs\n                        stack = [(r, c)]\n                        seen = {(r, c)}\n                        while stack:\n                            node = stack.pop()\n                            for nei in neighbors(*node):\n                                if A[nei[0]][nei[1]] and nei not in seen:\n                                    stack.append(nei)\n                                    seen.add(nei)\n                        done |= seen\n                        components.append(seen)\n            return components\n\n        source, target = get_components()\n        print source, target\n        queue = collections.deque([(node, 0) for node in source])\n        done = set(source)\n        while queue:\n            node, d = queue.popleft()\n            if node in target: return d-1\n            for nei in neighbors(*node):\n                if nei not in done:\n                    queue.append((nei, d+1))\n                    done.add(nei)"}]}
{"url": "https://leetcode-cn.com/problems/knight-dialer", "source": [{"lang": "Java", "code": "class Solution {\n    public int knightDialer(int N) {\n        int MOD = 1_000_000_007;\n        int[][] moves = new int[][]{\n            {4,6},{6,8},{7,9},{4,8},{3,9,0},\n            {},{1,7,0},{2,6},{1,3},{2,4}};\n\n        int[][] dp = new int[2][10];\n        Arrays.fill(dp[0], 1);\n        for (int hops = 0; hops < N-1; ++hops) {\n            Arrays.fill(dp[~hops & 1], 0);\n            for (int node = 0; node < 10; ++node)\n                for (int nei: moves[node]) {\n                    dp[~hops & 1][nei] += dp[hops & 1][node];\n                    dp[~hops & 1][nei] %= MOD;\n                }\n        }\n\n        long ans = 0;\n        for (int x: dp[~N & 1])\n            ans += x;\n        return (int) (ans % MOD);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def knightDialer(self, N):\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in xrange(N-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD"}]}
{"url": "https://leetcode-cn.com/problems/stamping-the-sequence", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] movesToStamp(String stamp, String target) {\n        int M = stamp.length(), N = target.length();\n        Queue<Integer> queue = new ArrayDeque();\n        boolean[] done = new boolean[N];\n        Stack<Integer> ans = new Stack();\n        List<Node> A = new ArrayList();\n\n        for (int i = 0; i <= N-M; ++i) {\n            // For each window [i, i+M), A[i] will contain\n            // info on what needs to change before we can\n            // reverse stamp at this window.\n\n            Set<Integer> made = new HashSet();\n            Set<Integer> todo = new HashSet();\n            for (int j = 0; j < M; ++j) {\n                if (target.charAt(i+j) == stamp.charAt(j))\n                    made.add(i+j);\n                else\n                    todo.add(i+j);\n            }\n\n            A.add(new Node(made, todo));\n\n            // If we can reverse stamp at i immediately,\n            // enqueue letters from this window.\n            if (todo.isEmpty()) {\n                ans.push(i);\n                for (int j = i; j < i + M; ++j) if (!done[j]) {\n                    queue.add(j);\n                    done[j] = true;\n                }\n            }\n        }\n\n        // For each enqueued letter (position),\n        while (!queue.isEmpty()) {\n            int i = queue.poll();\n\n            // For each window that is potentially affected,\n            // j: start of window\n            for (int j = Math.max(0, i-M+1); j <= Math.min(N-M, i); ++j) {\n                if (A.get(j).todo.contains(i)) {  // This window is affected\n                    A.get(j).todo.remove(i);\n                    if (A.get(j).todo.isEmpty()) {\n                        ans.push(j);\n                        for (int m: A.get(j).made) if (!done[m]) {\n                            queue.add(m);\n                            done[m] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (boolean b: done)\n            if (!b) return new int[0];\n\n        int[] ret = new int[ans.size()];\n        int t = 0;\n        while (!ans.isEmpty())\n            ret[t++] = ans.pop();\n\n        return ret;\n    }\n}\n\nclass Node {\n    Set<Integer> made, todo;\n    Node(Set<Integer> m, Set<Integer> t) {\n        made = m;\n        todo = t;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def movesToStamp(self, stamp, target):\n        M, N = len(stamp), len(target)\n\n        queue = collections.deque()\n        done = [False] * N\n        ans = []\n        A = []\n        for i in xrange(N - M + 1):\n            # For each window [i, i+M),\n            # A[i] will contain info on what needs to change\n            # before we can reverse stamp at i.\n\n            made, todo = set(), set()\n            for j, c in enumerate(stamp):\n                a = target[i+j]\n                if a == c:\n                    made.add(i+j)\n                else:\n                    todo.add(i+j)\n            A.append((made, todo))\n\n            # If we can reverse stamp at i immediately,\n            # enqueue letters from this window.\n            if not todo:\n                ans.append(i)\n                for j in xrange(i, i + len(stamp)):\n                    if not done[j]:\n                        queue.append(j)\n                        done[j] = True\n\n        # For each enqueued letter,\n        while queue:\n            i = queue.popleft()\n\n            # For each window that is potentially affected,\n            # j: start of window\n            for j in xrange(max(0, i-M+1), min(N-M, i)+1):\n                if i in A[j][1]:  # This window is affected\n                    A[j][1].discard(i) # Remove it from todo list of this window\n                    if not A[j][1]:  # Todo list of this window is empty\n                        ans.append(j)\n                        for m in A[j][0]: # For each letter to potentially enqueue,\n                            if not done[m]:\n                                queue.append(m)\n                                done[m] = True\n\n        return ans[::-1] if all(done) else []"}]}
{"url": "https://leetcode-cn.com/problems/reorder-data-in-log-files", "source": []}
{"url": "https://leetcode-cn.com/problems/range-sum-of-bst", "source": [{"lang": "Java", "code": "class Solution {\n    int ans;\n    public int rangeSumBST(TreeNode root, int L, int R) {\n        ans = 0;\n        dfs(root, L, R);\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int L, int R) {\n        if (node != null) {\n            if (L <= node.val && node.val <= R)\n                ans += node.val;\n            if (L < node.val)\n                dfs(node.left, L, R);\n            if (node.val < R)\n                dfs(node.right, L, R);\n        }\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def rangeSumBST(self, root, L, R):\n        def dfs(node):\n            if node:\n                if L <= node.val <= R:\n                    self.ans += node.val\n                if L < node.val:\n                    dfs(node.left)\n                if node.val < R:\n                    dfs(node.right)\n\n        self.ans = 0\n        dfs(root)\n        return self.ans"}, {"lang": "Java", "code": "class Solution {\n    public int rangeSumBST(TreeNode root, int L, int R) {\n        int ans = 0;\n        Stack<TreeNode> stack = new Stack();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            if (node != null) {\n                if (L <= node.val && node.val <= R)\n                    ans += node.val;\n                if (L < node.val)\n                    stack.push(node.left);\n                if (node.val < R)\n                    stack.push(node.right);\n            }\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def rangeSumBST(self, root, L, R):\n        ans = 0\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node:\n                if L <= node.val <= R:\n                    ans += node.val\n                if L < node.val:\n                    stack.append(node.left)\n                if node.val < R:\n                    stack.append(node.right)\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/minimum-area-rectangle", "source": [{"lang": "Java", "code": "class Solution {\n    public int minAreaRect(int[][] points) {\n        Map<Integer, List<Integer>> rows = new TreeMap();\n        for (int[] point: points) {\n            int x = point[0], y = point[1];\n            rows.computeIfAbsent(x, z-> new ArrayList()).add(y);\n        }\n\n        int ans = Integer.MAX_VALUE;\n        Map<Integer, Integer> lastx = new HashMap();\n        for (int x: rows.keySet()) {\n            List<Integer> row = rows.get(x);\n            Collections.sort(row);\n            for (int i = 0; i < row.size(); ++i)\n                for (int j = i+1; j < row.size(); ++j) {\n                    int y1 = row.get(i), y2 = row.get(j);\n                    int code = 40001 * y1 + y2;\n                    if (lastx.containsKey(code))\n                        ans = Math.min(ans, (x - lastx.get(code)) * (y2-y1));\n                    lastx.put(code, x);\n                }\n        }\n\n        return ans < Integer.MAX_VALUE ? ans : 0;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in xrange(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0"}, {"lang": "Java", "code": "class Solution {\n    public int minAreaRect(int[][] points) {\n        Set<Integer> pointSet = new HashSet();\n        for (int[] point: points)\n            pointSet.add(40001 * point[0] + point[1]);\n\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < points.length; ++i)\n            for (int j = i+1; j < points.length; ++j) {\n                if (points[i][0] != points[j][0] && points[i][1] != points[j][1]) {\n                    if (pointSet.contains(40001 * points[i][0] + points[j][1]) &&\n                            pointSet.contains(40001 * points[j][0] + points[i][1])) {\n                        ans = Math.min(ans, Math.abs(points[j][0] - points[i][0]) *\n                                            Math.abs(points[j][1] - points[i][1]));\n                    }\n                }\n            }\n\n        return ans < Integer.MAX_VALUE ? ans : 0;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in xrange(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0"}]}
{"url": "https://leetcode-cn.com/problems/distinct-subsequences-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-mountain-array", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean validMountainArray(int[] A) {\n        int N = A.length;\n        int i = 0;\n\n        // walk up\n        while (i+1 < N && A[i] < A[i+1])\n            i++;\n\n        // peak can't be first or last\n        if (i == 0 || i == N-1)\n            return false;\n\n        // walk down\n        while (i+1 < N && A[i] > A[i+1])\n            i++;\n\n        return i == N-1;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def validMountainArray(self, A):\n        N = len(A)\n        i = 0\n\n        # walk up\n        while i+1 < N and A[i] < A[i+1]:\n            i += 1\n\n        # peak can't be first or last\n        if i == 0 or i == N-1:\n            return False\n\n        # walk down\n        while i+1 < N and A[i] > A[i+1]:\n            i += 1\n\n        return i == N-1"}]}
{"url": "https://leetcode-cn.com/problems/di-string-match", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] diStringMatch(String S) {\n        int N = S.length();\n        int lo = 0, hi = N;\n        int[] ans = new int[N + 1];\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == 'I')\n                ans[i] = lo++;\n            else\n                ans[i] = hi--;\n        }\n\n        ans[N] = lo;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def diStringMatch(self, S):\n        lo, hi = 0, len(S)\n        ans = []\n        for x in S:\n            if x == 'I':\n                ans.append(lo)\n                lo += 1\n            else:\n                ans.append(hi)\n                hi -= 1\n\n        return ans + [lo]"}]}
{"url": "https://leetcode-cn.com/problems/find-the-shortest-superstring", "source": [{"lang": "Java", "code": "class Solution {\n    public String shortestSuperstring(String[] A) {\n        int N = A.length;\n\n        // Populate overlaps\n        int[][] overlaps = new int[N][N];\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < N; ++j) if (i != j) {\n                int m = Math.min(A[i].length(), A[j].length());\n                for (int k = m; k >= 0; --k)\n                    if (A[i].endsWith(A[j].substring(0, k))) {\n                        overlaps[i][j] = k;\n                        break;\n                    }\n            }\n\n        // dp[mask][i] = most overlap with mask, ending with ith element\n        int[][] dp = new int[1<<N][N];\n        int[][] parent = new int[1<<N][N];\n        for (int mask = 0; mask < (1<<N); ++mask) {\n            Arrays.fill(parent[mask], -1);\n\n            for (int bit = 0; bit < N; ++bit) if (((mask >> bit) & 1) > 0) {\n                // Let's try to find dp[mask][bit].  Previously, we had\n                // a collection of items represented by pmask.\n                int pmask = mask ^ (1 << bit);\n                if (pmask == 0) continue;\n                for (int i = 0; i < N; ++i) if (((pmask >> i) & 1) > 0) {\n                    // For each bit i in pmask, calculate the value\n                    // if we ended with word i, then added word 'bit'.\n                    int val = dp[pmask][i] + overlaps[i][bit];\n                    if (val > dp[mask][bit]) {\n                        dp[mask][bit] = val;\n                        parent[mask][bit] = i;\n                    }\n                }\n            }\n        }\n\n        // # Answer will have length sum(len(A[i]) for i) - max(dp[-1])\n        // Reconstruct answer, first as a sequence 'perm' representing\n        // the indices of each word from left to right.\n\n        int[] perm = new int[N];\n        boolean[] seen = new boolean[N];\n        int t = 0;\n        int mask = (1 << N) - 1;\n\n        // p: the last element of perm (last word written left to right)\n        int p = 0;\n        for (int j = 0; j < N; ++j)\n            if (dp[(1<<N) - 1][j] > dp[(1<<N) - 1][p])\n                p = j;\n\n        // Follow parents down backwards path that retains maximum overlap\n        while (p != -1) {\n            perm[t++] = p;\n            seen[p] = true;\n            int p2 = parent[mask][p];\n            mask ^= 1 << p;\n            p = p2;\n        }\n\n        // Reverse perm\n        for (int i = 0; i < t/2; ++i) {\n            int v = perm[i];\n            perm[i] = perm[t-1-i];\n            perm[t-1-i] = v;\n        }\n\n        // Fill in remaining words not yet added\n        for (int i = 0; i < N; ++i) if (!seen[i])\n            perm[t++] = i;\n\n        // Reconstruct final answer given perm\n        StringBuilder ans = new StringBuilder(A[perm[0]]);\n        for (int i = 1; i < N; ++i) {\n            int overlap = overlaps[perm[i-1]][perm[i]];\n            ans.append(A[perm[i]].substring(overlap));\n        }\n\n        return ans.toString();\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def shortestSuperstring(self, A):\n        N = len(A)\n\n        # Populate overlaps\n        overlaps = [[0] * N for _ in xrange(N)]\n        for i, x in enumerate(A):\n            for j, y in enumerate(A):\n                if i != j:\n                    for ans in xrange(min(len(x), len(y)), -1, -1):\n                        if x.endswith(y[:ans]):\n                            overlaps[i][j] = ans\n                            break\n\n        # dp[mask][i] = most overlap with mask, ending with ith element\n        dp = [[0] * N for _ in xrange(1<<N)]\n        parent = [[None] * N for _ in xrange(1<<N)]\n        for mask in xrange(1, 1 << N):\n            for bit in xrange(N):\n                if (mask >> bit) & 1:\n                    # Let's try to find dp[mask][bit].  Previously, we had\n                    # a collection of items represented by pmask.\n                    pmask = mask ^ (1 << bit)\n                    if pmask == 0: continue\n                    for i in xrange(N):\n                        if (pmask >> i) & 1:\n                            # For each bit i in pmask, calculate the value\n                            # if we ended with word i, then added word 'bit'.\n                            value = dp[pmask][i] + overlaps[i][bit]\n                            if value > dp[mask][bit]:\n                                dp[mask][bit] = value\n                                parent[mask][bit] = i\n\n        # Answer will have length sum(len(A[i]) for i) - max(dp[-1])\n        # Reconstruct answer:\n\n        # Follow parents down backwards path that retains maximum overlap\n        perm = []\n        mask = (1<<N) - 1\n        i = max(xrange(N), key = dp[-1].__getitem__)\n        while i is not None:\n            perm.append(i)\n            mask, i = mask ^ (1<<i), parent[mask][i]\n\n        # Reverse path to get forwards direction; add all remaining words\n        perm = perm[::-1]\n        seen = [False] * N\n        for x in perm:\n            seen[x] = True\n        perm.extend([i for i in xrange(N) if not seen[i]])\n\n        # Reconstruct answer given perm = word indices in left to right order\n        ans = [A[perm[0]]]\n        for i in xrange(1, len(perm)):\n            overlap = overlaps[perm[i-1]][perm[i]]\n            ans.append(A[perm[i]][overlap:])\n\n        return \"\".join(ans)"}]}
{"url": "https://leetcode-cn.com/problems/delete-columns-to-make-sorted", "source": [{"lang": "Java", "code": "class Solution {\n    public int minDeletionSize(String[] A) {\n        int ans = 0;\n        for (int c = 0; c < A[0].length(); ++c)\n            for (int r = 0; r < A.length - 1; ++r)\n                if (A[r].charAt(c) > A[r+1].charAt(c)) {\n                    ans++;\n                    break;\n                }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def minDeletionSize(self, A):\n        ans = 0\n        for col in zip(*A):\n            if any(col[i] > col[i+1] for i in xrange(len(col) - 1)):\n                ans += 1\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique", "source": []}
{"url": "https://leetcode-cn.com/problems/validate-stack-sequences", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        int N = pushed.length;\n        Stack<Integer> stack = new Stack();\n\n        int j = 0;\n        for (int x: pushed) {\n            stack.push(x);\n            while (!stack.isEmpty() && j < N && stack.peek() == popped[j]) {\n                stack.pop();\n                j++;\n            }\n        }\n\n        return j == N;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def validateStackSequences(self, pushed, popped):\n        j = 0\n        stack = []\n        for x in pushed:\n            stack.append(x)\n            while stack and j < len(popped) and stack[-1] == popped[j]:\n                stack.pop()\n                j += 1\n\n        return j == len(popped)"}]}
{"url": "https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column", "source": []}
{"url": "https://leetcode-cn.com/problems/bag-of-tokens", "source": [{"lang": "Java", "code": "class Solution {\n    public int bagOfTokensScore(int[] tokens, int P) {\n        Arrays.sort(tokens);\n        int lo = 0, hi = tokens.length - 1;\n        int points = 0, ans = 0;\n        while (lo <= hi && (P >= tokens[lo] || points > 0)) {\n            while (lo <= hi && P >= tokens[lo]) {\n                P -= tokens[lo++];\n                points++;\n            }\n\n            ans = Math.max(ans, points);\n            if (lo <= hi && points > 0) {\n                P += tokens[hi--];\n                points--;\n            }\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def bagOfTokensScore(self, tokens, P):\n        tokens.sort()\n        deque = collections.deque(tokens)\n        ans = bns = 0\n        while deque and (P >= deque[0] or bns):\n            while deque and P >= deque[0]:\n                P -= deque.popleft()\n                bns += 1\n            ans = max(ans, bns)\n\n            if deque and bns:\n                P += deque.pop()\n                bns -= 1\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/largest-time-for-given-digits", "source": []}
{"url": "https://leetcode-cn.com/problems/reveal-cards-in-increasing-order", "source": []}
{"url": "https://leetcode-cn.com/problems/flip-equivalent-binary-trees", "source": []}
{"url": "https://leetcode-cn.com/problems/largest-component-size-by-common-factor", "source": []}
{"url": "https://leetcode-cn.com/problems/verifying-an-alien-dictionary", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean isAlienSorted(String[] words, String order) {\n        int[] index = new int[26];\n        for (int i = 0; i < order.length(); ++i)\n            index[order.charAt(i) - 'a'] = i;\n\n        search: for (int i = 0; i < words.length - 1; ++i) {\n            String word1 = words[i];\n            String word2 = words[i+1];\n\n            // Find the first difference word1[k] != word2[k].\n            for (int k = 0; k < Math.min(word1.length(), word2.length()); ++k) {\n                if (word1.charAt(k) != word2.charAt(k)) {\n                    // If they compare badly, it's not sorted.\n                    if (index[word1.charAt(k) - 'a'] > index[word2.charAt(k) - 'a'])\n                        return false;\n                    continue search;\n                }\n            }\n\n            // If we didn't find a first difference, the\n            // words are like (\"app\", \"apple\").\n            if (word1.length() > word2.length())\n                return false;\n        }\n\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isAlienSorted(self, words, order):\n        order_index = {c: i for i, c in enumerate(order)}\n\n        for i in xrange(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i+1]\n\n            # Find the first difference word1[k] != word2[k].\n            for k in xrange(min(len(word1), len(word2))):\n                # If they compare badly, it's not sorted.\n                if word1[k] != word2[k]:\n                    if order_index[word1[k]] > order_index[word2[k]]:\n                        return False\n                    break\n            else:\n                # If we didn't find a first difference, the\n                # words are like (\"app\", \"apple\").\n                if len(word1) > len(word2):\n                    return False\n\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/array-of-doubled-pairs", "source": [{"lang": "java", "code": "class Solution {\n    public boolean canReorderDoubled(int[] A) {\n        // count[x] = the number of occurrences of x in A\n        Map<Integer, Integer> count = new HashMap();\n        for (int x: A)\n            count.put(x, count.getOrDefault(x, 0) + 1);\n\n        // B = A as Integer[], sorted by absolute value\n        Integer[] B = new Integer[A.length];\n        for (int i = 0; i < A.length; ++i)\n            B[i] = A[i];\n        Arrays.sort(B, Comparator.comparingInt(Math::abs));\n\n        for (int x: B) {\n            // If this can't be consumed, skip\n            if (count.get(x) == 0) continue;\n            // If this doesn't have a doubled partner, the answer is false\n            if (count.getOrDefault(2*x, 0) <= 0) return false;\n\n            // Write x, 2*x\n            count.put(x, count.get(x) - 1);\n            count.put(2*x, count.get(2*x) - 1);\n        }\n\n        // If we have written everything, the answer is true\n        return true;\n    }\n}"}, {"lang": "python", "code": "class Solution(object):\n    def canReorderDoubled(self, A):\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/delete-columns-to-make-sorted-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/tallest-billboard", "source": []}
{"url": "https://leetcode-cn.com/problems/prison-cells-after-n-days", "source": []}
{"url": "https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean isCompleteTree(TreeNode root) {\n        List<ANode> nodes = new ArrayList();\n        nodes.add(new ANode(root, 1));\n        int i = 0;\n        while (i < nodes.size()) {\n            ANode anode = nodes.get(i++);\n            if (anode.node != null) {\n                nodes.add(new ANode(anode.node.left, anode.code * 2));\n                nodes.add(new ANode(anode.node.right, anode.code * 2 + 1));\n            }\n        }\n\n        return nodes.get(i-1).code == nodes.size();\n    }\n}\n\nclass ANode {  // Annotated Node\n    TreeNode node;\n    int code;\n    ANode(TreeNode node, int code) {\n        this.node = node;\n        this.code = code;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isCompleteTree(self, root):\n        nodes = [(root, 1)]\n        i = 0\n        while i < len(nodes):\n            node, v = nodes[i]\n            i += 1\n            if node:\n                nodes.append((node.left, 2*v))\n                nodes.append((node.right, 2*v+1))\n\n        return  nodes[-1][1] == len(nodes)"}]}
{"url": "https://leetcode-cn.com/problems/regions-cut-by-slashes", "source": [{"lang": "Java", "code": "class Solution {\n    public int regionsBySlashes(String[] grid) {\n        int N = grid.length;\n        DSU dsu = new DSU(4 * N * N);\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c) {\n                int root = 4 * (r * N + c);\n                char val = grid[r].charAt(c);\n                if (val != '\\\\') {\n                    dsu.union(root + 0, root + 1);\n                    dsu.union(root + 2, root + 3);\n                }\n                if (val != '/') {\n                    dsu.union(root + 0, root + 2);\n                    dsu.union(root + 1, root + 3);\n                }\n\n                // north south\n                if (r + 1 < N)\n                    dsu.union(root + 3, (root + 4 * N) + 0);\n                if (r - 1 >= 0)\n                    dsu.union(root + 0, (root - 4 * N) + 3);\n                // east west\n                if (c + 1 < N)\n                    dsu.union(root + 2, (root + 4) + 1);\n                if (c - 1 >= 0)\n                    dsu.union(root + 1, (root - 4) + 2);\n            }\n\n        int ans = 0;\n        for (int x = 0; x < 4 * N * N; ++x) {\n            if (dsu.find(x) == x)\n                ans++;\n        }\n\n        return ans;\n    }\n}\n\nclass DSU {\n    int[] parent;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}"}, {"lang": "Python", "code": "class DSU:\n    def __init__(self, N):\n        self.p = range(N)\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        self.p[xr] = yr\n\nclass Solution(object):\n    def regionsBySlashes(self, grid):\n        N = len(grid)\n        dsu = DSU(4 * N * N)\n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                root = 4 * (r*N + c)\n                if val in '/ ':\n                    dsu.union(root + 0, root + 1)\n                    dsu.union(root + 2, root + 3)\n                if val in '\\ ':\n                    dsu.union(root + 0, root + 2)\n                    dsu.union(root + 1, root + 3)\n\n                # north/south\n                if r+1 < N: dsu.union(root + 3, (root+4*N) + 0)\n                if r-1 >= 0: dsu.union(root + 0, (root-4*N) + 3)\n                # east/west\n                if c+1 < N: dsu.union(root + 2, (root+4) + 1)\n                if c-1 >= 0: dsu.union(root + 1, (root-4) + 2)\n\n        return sum(dsu.find(x) == x for x in xrange(4*N*N))"}]}
{"url": "https://leetcode-cn.com/problems/delete-columns-to-make-sorted-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-width-ramp", "source": [{"lang": "Java", "code": "class Solution {\n    public int maxWidthRamp(int[] A) {\n        int N = A.length;\n        Integer[] B = new Integer[N];\n        for (int i = 0; i < N; ++i)\n            B[i] = i;\n\n        Arrays.sort(B, (i, j) -> ((Integer) A[i]).compareTo(A[j]));\n\n        int ans = 0;\n        int m = N;\n        for (int i: B) {\n            ans = Math.max(ans, i - m);\n            m = Math.min(m, i);\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maxWidthRamp(self, A):\n        ans = 0\n        m = float('inf')\n        for i in sorted(range(len(A)), key = A.__getitem__):\n            ans = max(ans, i - m)\n            m = min(m, i)\n        return ans"}, {"lang": "Java", "code": "import java.awt.Point;\n\nclass Solution {\n    public int maxWidthRamp(int[] A) {\n        int N = A.length;\n\n        int ans = 0;\n        List<Point> candidates = new ArrayList();\n        candidates.add(new Point(A[N-1], N-1));\n\n        // candidates: i's decreasing, by increasing value of A[i]\n        for (int i = N-2; i >= 0; --i) {\n            // Find largest j in candidates with A[j] >= A[i]\n            int lo = 0, hi = candidates.size();\n            while (lo < hi) {\n                int mi = lo + (hi - lo) / 2;\n                if (candidates.get(mi).x < A[i])\n                    lo = mi + 1;\n                else\n                    hi = mi;\n            }\n\n            if (lo < candidates.size()) {\n                int j = candidates.get(lo).y;\n                ans = Math.max(ans, j - i);\n            } else {\n                candidates.add(new Point(A[i], i));\n            }\n        }\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def maxWidthRamp(self, A):\n        N = len(A)\n\n        ans = 0\n        candidates = [(A[N-1], N-1)]\n        # candidates: i's decreasing, by increasing value of A[i]\n        for i in xrange(N-2, -1, -1):\n            # Find largest j in candidates with A[j] >= A[i]\n            jx = bisect.bisect(candidates, (A[i],))\n            if jx < len(candidates):\n                ans = max(ans, candidates[jx][1] - i)\n            else:\n                candidates.append((A[i], i))\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/minimum-area-rectangle-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/least-operators-to-express-number", "source": []}
{"url": "https://leetcode-cn.com/problems/univalued-binary-tree", "source": [{"lang": "Java", "code": "class Solution {\n    List<Integer> vals;\n    public boolean isUnivalTree(TreeNode root) {\n        vals = new ArrayList();\n        dfs(root);\n        for (int v: vals)\n            if (v != vals.get(0))\n                return false;\n        return true;\n    }\n\n    public void dfs(TreeNode node) {\n        if (node != null) {\n            vals.add(node.val);\n            dfs(node.left);\n            dfs(node.right);\n        }\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isUnivalTree(self, root):\n        vals = []\n\n        def dfs(node):\n            if node:\n                vals.append(node.val)\n                dfs(node.left)\n                dfs(node.right)\n\n        dfs(root)\n        return len(set(vals)) == 1"}, {"lang": "Java", "code": "class Solution {\n    public boolean isUnivalTree(TreeNode root) {\n        boolean left_correct = (root.left == null ||\n                (root.val == root.left.val && isUnivalTree(root.left)));\n        boolean right_correct = (root.right == null ||\n                (root.val == root.right.val && isUnivalTree(root.right)));\n        return left_correct && right_correct;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isUnivalTree(self, root):\n        left_correct = (not root.left or root.val == root.left.val\n                and self.isUnivalTree(root.left))\n        right_correct = (not root.right or root.val == root.right.val\n                and self.isUnivalTree(root.right))\n        return left_correct and right_correct"}]}
{"url": "https://leetcode-cn.com/problems/vowel-spellchecker", "source": [{"lang": "Java", "code": "class Solution {\n    Set<String> words_perfect;\n    Map<String, String> words_cap;\n    Map<String, String> words_vow;\n\n    public String[] spellchecker(String[] wordlist, String[] queries) {\n        words_perfect = new HashSet();\n        words_cap = new HashMap();\n        words_vow = new HashMap();\n\n        for (String word: wordlist) {\n            words_perfect.add(word);\n\n            String wordlow = word.toLowerCase();\n            words_cap.putIfAbsent(wordlow, word);\n\n            String wordlowDV = devowel(wordlow);\n            words_vow.putIfAbsent(wordlowDV, word);\n        }\n\n        String[] ans = new String[queries.length];\n        int t = 0;\n        for (String query: queries)\n            ans[t++] = solve(query);\n        return ans;\n    }\n\n    public String solve(String query) {\n        if (words_perfect.contains(query))\n            return query;\n\n        String queryL = query.toLowerCase();\n        if (words_cap.containsKey(queryL))\n            return words_cap.get(queryL);\n\n        String queryLV = devowel(queryL);\n        if (words_vow.containsKey(queryLV))\n            return words_vow.get(queryLV);\n\n        return \"\";\n    }\n\n    public String devowel(String word) {\n        StringBuilder ans = new StringBuilder();\n        for (char c: word.toCharArray())\n            ans.append(isVowel(c) ? '*' : c);\n        return ans.toString();\n    }\n\n    public boolean isVowel(char c) {\n        return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def spellchecker(self, wordlist, queries):\n        def devowel(word):\n            return \"\".join('*' if c in 'aeiou' else c\n                           for c in word)\n\n        words_perfect = set(wordlist)\n        words_cap = {}\n        words_vow = {}\n\n        for word in wordlist:\n            wordlow = word.lower()\n            words_cap.setdefault(wordlow, word)\n            words_vow.setdefault(devowel(wordlow), word)\n\n        def solve(query):\n            if query in words_perfect:\n                return query\n\n            queryL = query.lower()\n            if queryL in words_cap:\n                return words_cap[queryL]\n\n            queryLV = devowel(queryL)\n            if queryLV in words_vow:\n                return words_vow[queryLV]\n            return \"\"\n\n        return map(solve, queries)"}]}
{"url": "https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-tree-cameras", "source": []}
{"url": "https://leetcode-cn.com/problems/pancake-sorting", "source": [{"lang": "Java", "code": "class Solution {\n    public List<Integer> pancakeSort(int[] A) {\n        List<Integer> ans = new ArrayList();\n        int N = A.length;\n\n        Integer[] B = new Integer[N];\n        for (int i = 0; i < N; ++i)\n            B[i] = i+1;\n        Arrays.sort(B, (i, j) -> A[j-1] - A[i-1]);\n\n        for (int i: B) {\n            for (int f: ans)\n                if (i <= f)\n                    i = f+1 - i;\n            ans.add(i);\n            ans.add(N--);\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def pancakeSort(self, A):\n        ans = []\n\n        N = len(A)\n        B = sorted(range(1, N+1), key = lambda i: -A[i-1])\n        for i in B:\n            for f in ans:\n                if i <= f:\n                    i = f+1 - i\n            ans.extend([i, N])\n            N -= 1\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/powerful-integers", "source": [{"lang": "Java", "code": "class Solution { \n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\n        Set<Integer> seen = new HashSet();\n        for (int i = 0; i < 18 && Math.pow(x, i) <= bound; ++i)\n            for (int j = 0; j < 18 && Math.pow(y, j) <= bound; ++j) {\n                int v = (int) Math.pow(x, i) + (int) Math.pow(y, j);\n                if (v <= bound)\n                    seen.add(v);\n            }\n\n        return new ArrayList(seen);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object): \n    def powerfulIntegers(self, x, y, bound):\n        ans = set()\n        # 2**18 > bound\n        for i in xrange(18):\n            for j in xrange(18):\n                v = x**i + y**j\n                if v <= bound:\n                    ans.add(v)\n        return list(ans)"}]}
{"url": "https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/equal-rational-numbers", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean isRationalEqual(String S, String T) {\n        Fraction f1 = convert(S);\n        Fraction f2 = convert(T);\n        return f1.n == f2.n && f1.d == f2.d;\n    }\n\n    public Fraction convert(String S) {\n        int state = 0; //whole, decimal, repeating\n        Fraction ans = new Fraction(0, 1);\n        int decimal_size = 0;\n\n        for (String part: S.split(\"[.()]\")) {\n            state++;\n            if (part.isEmpty()) continue;\n            long x = Long.valueOf(part);\n            int sz = part.length();\n\n            if (state == 1) { // whole\n                 ans.iadd(new Fraction(x, 1));\n            } else if (state == 2) { // decimal\n                 ans.iadd(new Fraction(x, (long) Math.pow(10, sz)));\n                 decimal_size = sz;\n            } else { // repeating\n                 long denom = (long) Math.pow(10, decimal_size);\n                 denom *= (long) (Math.pow(10, sz) - 1);\n                 ans.iadd(new Fraction(x, denom));\n            }\n        }\n        return ans;\n    }\n}\n\nclass Fraction {\n    long n, d;\n    Fraction(long n, long d) {\n        long g = gcd(n, d);\n        this.n = n / g;\n        this.d = d / g;\n    }\n\n    public void iadd(Fraction other) {\n        long numerator = this.n * other.d + this.d * other.n;\n        long denominator = this.d * other.d;\n        long g = Fraction.gcd(numerator, denominator);\n        this.n = numerator / g;\n        this.d = denominator / g;\n    }\n\n    static long gcd(long x, long y) {\n        return x != 0 ? gcd(y % x, x) : y;\n    }\n}"}, {"lang": "Python", "code": "from fractions import Fraction\n\nclass Solution(object):\n    def isRationalEqual(self, S, T):\n        def convert(S):\n            if '.' not in S:\n                return Fraction(int(S), 1)\n            i = S.index('.')\n            ans = Fraction(int(S[:i]), 1)\n            S = S[i+1:]\n            if '(' not in S:\n                if S:\n                    ans += Fraction(int(S), 10 ** len(S))\n                return ans\n\n            i = S.index('(')\n            if i:\n                ans += Fraction(int(S[:i]), 10 ** i)\n            S = S[i+1:-1]\n            j = len(S)\n            ans += Fraction(int(S), 10**i * (10**j - 1))\n            return ans\n\n        return convert(S) == convert(T)"}]}
{"url": "https://leetcode-cn.com/problems/k-closest-points-to-origin", "source": []}
{"url": "https://leetcode-cn.com/problems/subarray-sums-divisible-by-k", "source": []}
{"url": "https://leetcode-cn.com/problems/odd-even-jump", "source": []}
{"url": "https://leetcode-cn.com/problems/largest-perimeter-triangle", "source": [{"lang": "Java", "code": "class Solution {\n    public int largestPerimeter(int[] A) {\n        Arrays.sort(A);\n        for (int i = A.length - 3; i >= 0; --i)\n            if (A[i] + A[i+1] > A[i+2])\n                return A[i] + A[i+1] + A[i+2];\n        return 0;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def largestPerimeter(self, A):\n        A.sort()\n        for i in xrange(len(A) - 3, -1, -1):\n            if A[i] + A[i+1] > A[i+2]:\n                return A[i] + A[i+1] + A[i+2]\n        return 0"}]}
{"url": "https://leetcode-cn.com/problems/squares-of-a-sorted-array", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] sortedSquares(int[] A) {\n        int N = A.length;\n        int[] ans = new int[N];\n        for (int i = 0; i < N; ++i)\n            ans[i] = A[i] * A[i];\n\n        Arrays.sort(ans);\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def sortedSquares(self, A):\n        return sorted(x*x for x in A)"}, {"lang": "Java", "code": "class Solution {\n    public int[] sortedSquares(int[] A) {\n        int N = A.length;\n        int j = 0;\n        while (j < N && A[j] < 0)\n            j++;\n        int i = j-1;\n\n        int[] ans = new int[N];\n        int t = 0;\n\n        while (i >= 0 && j < N) {\n            if (A[i] * A[i] < A[j] * A[j]) {\n                ans[t++] = A[i] * A[i];\n                i--;\n            } else {\n                ans[t++] = A[j] * A[j];\n                j++;\n            }\n        }\n\n        while (i >= 0) {\n            ans[t++] = A[i] * A[i];\n            i--;\n        }\n        while (j < N) {\n            ans[t++] = A[j] * A[j];\n            j++;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def sortedSquares(self, A):\n        N = len(A)\n        # i, j: negative, positive parts\n        j = 0\n        while j < N and A[j] < 0:\n            j += 1\n        i = j - 1\n\n        ans = []\n        while 0 <= i and j < N:\n            if A[i]**2 < A[j]**2:\n                ans.append(A[i]**2)\n                i -= 1\n            else:\n                ans.append(A[j]**2)\n                j += 1\n\n        while i >= 0:\n            ans.append(A[i]**2)\n            i -= 1\n        while j < N:\n            ans.append(A[j]**2)\n            j += 1\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/longest-turbulent-subarray", "source": []}
{"url": "https://leetcode-cn.com/problems/distribute-coins-in-binary-tree", "source": [{"lang": "Java", "code": "class Solution {\n    int ans;\n    public int distributeCoins(TreeNode root) {\n        ans = 0;\n        dfs(root);\n        return ans;\n    }\n\n    public int dfs(TreeNode node) {\n        if (node == null) return 0;\n        int L = dfs(node.left);\n        int R = dfs(node.right);\n        ans += Math.abs(L) + Math.abs(R);\n        return node.val + L + R - 1;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def distributeCoins(self, root):\n        self.ans = 0\n\n        def dfs(node):\n            if not node: return 0\n            L, R = dfs(node.left), dfs(node.right)\n            self.ans += abs(L) + abs(R)\n            return node.val + L + R - 1\n\n        dfs(root)\n        return self.ans"}]}
{"url": "https://leetcode-cn.com/problems/unique-paths-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/time-based-key-value-store", "source": [{"lang": "Java", "code": "import javafx.util.Pair;\n\nclass TimeMap {\n    Map<String, List<Pair<Integer, String>>> M;\n\n    public TimeMap() {\n        M = new HashMap();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        if (!M.containsKey(key))\n            M.put(key, new ArrayList<Pair<Integer, String>>());\n\n        M.get(key).add(new Pair(timestamp, value));\n    }\n\n    public String get(String key, int timestamp) {\n        if (!M.containsKey(key)) return \"\";\n\n        List<Pair<Integer, String>> A = M.get(key);\n        int i = Collections.binarySearch(A, new Pair<Integer, String>(timestamp, \"{\"),\n                (a, b) -> Integer.compare(a.getKey(), b.getKey()));\n\n        if (i >= 0)\n            return A.get(i).getValue();\n        else if (i == -1)\n            return \"\";\n        else\n            return A.get(-i-2).getValue();\n    }\n}"}, {"lang": "Python", "code": "class TimeMap(object):\n    def __init__(self):\n        self.M = collections.defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        self.M[key].append((timestamp, value))\n\n    def get(self, key, timestamp):\n        A = self.M.get(key, None)\n        if A is None: return \"\"\n        i = bisect.bisect(A, (timestamp, chr(127)))\n        return A[i-1][1] if i else \"\""}, {"lang": "Java", "code": "class TimeMap {\n    Map<String, TreeMap<Integer, String>> M;\n\n    public TimeMap() {\n        M = new HashMap();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        if (!M.containsKey(key))\n            M.put(key, new TreeMap());\n\n        M.get(key).put(timestamp, value);\n    }\n\n    public String get(String key, int timestamp) {\n        if (!M.containsKey(key)) return \"\";\n\n        TreeMap<Integer, String> tree = M.get(key);\n        Integer t = tree.floorKey(timestamp);\n        return t != null ? tree.get(t) : \"\";\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/triples-with-bitwise-and-equal-to-zero", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-cost-for-tickets", "source": []}
{"url": "https://leetcode-cn.com/problems/string-without-aaa-or-bbb", "source": []}
{"url": "https://leetcode-cn.com/problems/sum-of-even-numbers-after-queries", "source": [{"lang": "Java", "code": "class Solution {\n    public int[] sumEvenAfterQueries(int[] A, int[][] queries) {\n        int S = 0;\n        for (int x: A)\n            if (x % 2 == 0)\n                S += x;\n\n        int[] ans = new int[queries.length];\n\n        for (int i = 0; i < queries.length; ++i) {\n            int val = queries[i][0], index = queries[i][1];\n            if (A[index] % 2 == 0) S -= A[index];\n            A[index] += val;\n            if (A[index] % 2 == 0) S += A[index];\n            ans[i] = S;\n        }\n\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def sumEvenAfterQueries(self, A, queries):\n        S = sum(x for x in A if x % 2 == 0)\n        ans = []\n\n        for x, k in queries:\n            if A[k] % 2 == 0: S -= A[k]\n            A[k] += x\n            if A[k] % 2 == 0: S += A[k]\n            ans.append(S)\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/interval-list-intersections", "source": [{"lang": "Java", "code": "class Solution {\n    public Interval[] intervalIntersection(Interval[] A, Interval[] B) {\n        List<Interval> ans = new ArrayList();\n        int i = 0, j = 0;\n\n        while (i < A.length && j < B.length) {\n            // Let's check if A[i] intersects B[j].\n            // lo - the startpoint of the intersection\n            // hi - the endpoint of the intersection\n            int lo = Math.max(A[i].start, B[j].start);\n            int hi = Math.min(A[i].end, B[j].end);\n            if (lo <= hi)\n                ans.add(new Interval(lo, hi));\n\n            // Remove the interval with the smallest endpoint\n            if (A[i].end < B[j].end)\n                i++;\n            else\n                j++;\n        }\n\n        return ans.toArray(new Interval[ans.size()]);\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def intervalIntersection(self, A, B):\n        ans = []\n        i = j = 0\n\n        while i < len(A) and j < len(B):\n            # Let's check if A[i] intersects B[j].\n            # lo - the startpoint of the intersection\n            # hi - the endpoint of the intersection\n            lo = max(A[i].start, B[j].start)\n            hi = min(A[i].end, B[j].end)\n            if lo <= hi:\n                ans.append(Interval(lo, hi))\n\n            # Remove the interval with the smallest endpoint\n            if A[i].end < B[j].end:\n                i += 1\n            else:\n                j += 1\n\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/smallest-string-starting-from-leaf", "source": []}
{"url": "https://leetcode-cn.com/problems/add-to-array-form-of-integer", "source": [{"lang": "Java", "code": "class Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int N = A.length;\n        int cur = K;\n        List<Integer> ans = new ArrayList();\n\n        int i = N;\n        while (--i >= 0 || cur > 0) {\n            if (i >= 0)\n                cur += A[i];\n            ans.add(cur % 10);\n            cur /= 10;\n        }\n\n        Collections.reverse(ans);\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def addToArrayForm(self, A, K):\n        A[-1] += K\n        for i in xrange(len(A) - 1, -1, -1):\n            carry, A[i] = divmod(A[i], 10)\n            if i: A[i-1] += carry\n        if carry:\n            A = map(int, str(carry)) + A\n        return A"}]}
{"url": "https://leetcode-cn.com/problems/satisfiability-of-equality-equations", "source": [{"lang": "Java", "code": "class Solution {\n    public boolean equationsPossible(String[] equations) {\n        ArrayList<Integer>[] graph = new ArrayList[26];\n        for (int i = 0; i < 26; ++i)\n            graph[i] = new ArrayList();\n\n        for (String eqn: equations) {\n            if (eqn.charAt(1) == '=') {\n                int x = eqn.charAt(0) - 'a';\n                int y = eqn.charAt(3) - 'a';\n                graph[x].add(y);\n                graph[y].add(x);\n            }\n        }\n\n        int[] color = new int[26];\n        int t = 0;\n        for (int start = 0; start < 26; ++start) {\n            if (color[start] == 0) {\n                t++;\n                Stack<Integer> stack = new Stack();\n                stack.push(start);\n                while (!stack.isEmpty()) {\n                    int node = stack.pop();\n                    for (int nei: graph[node]) {\n                        if (color[nei] == 0) {\n                            color[nei] = t;\n                            stack.push(nei);\n                        }\n                    }\n                }\n            }\n        }\n\n        for (String eqn: equations) {\n            if (eqn.charAt(1) == '!') {\n                int x = eqn.charAt(0) - 'a';\n                int y = eqn.charAt(3) - 'a';\n                if (x == y || color[x] != 0 && color[x] == color[y])\n                    return false;\n            }\n        }\n\n        return true;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def equationsPossible(self, equations):\n        graph = [[] for _ in xrange(26)]\n\n        for eqn in equations:\n            if eqn[1] == '=':\n                x = ord(eqn[0]) - ord('a')\n                y = ord(eqn[3]) - ord('a')\n                graph[x].append(y)\n                graph[y].append(x)\n\n        color = [None] * 26\n        t = 0\n        for start in xrange(26):\n            if color[start] is None:\n                t += 1\n                stack = [start]\n                while stack:\n                    node = stack.pop()\n                    for nei in graph[node]:\n                        if color[nei] is None:\n                            color[nei] = t\n                            stack.append(nei)\n\n        for eqn in equations:\n            if eqn[1] == '!':\n                x = ord(eqn[0]) - ord('a')\n                y = ord(eqn[3]) - ord('a')\n                if x == y: return False # lee\n                if color[x] is not None and color[x] == color[y]:\n                    return False\n        return True"}]}
{"url": "https://leetcode-cn.com/problems/broken-calculator", "source": []}
{"url": "https://leetcode-cn.com/problems/subarrays-with-k-different-integers", "source": []}
{"url": "https://leetcode-cn.com/problems/cousins-in-binary-tree", "source": [{"lang": "Java", "code": "class Solution {\n    Map<Integer, Integer> depth;\n    Map<Integer, TreeNode> parent;\n\n    public boolean isCousins(TreeNode root, int x, int y) {\n        depth = new HashMap();\n        parent = new HashMap();\n        dfs(root, null);\n        return (depth.get(x) == depth.get(y) && parent.get(x) != parent.get(y));\n    }\n\n    public void dfs(TreeNode node, TreeNode par) {\n        if (node != null) {\n            depth.put(node.val, par != null ? 1 + depth.get(par.val) : 0);\n            parent.put(node.val, par);\n            dfs(node.left, node);\n            dfs(node.right, node);\n        }\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isCousins(self, root, x, y):\n        parent = {}\n        depth = {}\n        def dfs(node, par = None):\n            if node:\n                depth[node.val] = 1 + depth[par.val] if par else 0\n                parent[node.val] = par\n                dfs(node.left, node)\n                dfs(node.right, node)\n\n        dfs(root)\n        return depth[x] == depth[y] and parent[x] != parent[y]"}]}
{"url": "https://leetcode-cn.com/problems/rotting-oranges", "source": [{"lang": "Java", "code": "class Solution {\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n\n    public int orangesRotting(int[][] grid) {\n        int R = grid.length, C = grid[0].length;\n\n        // queue : all starting cells with rotten oranges\n        Queue<Integer> queue = new ArrayDeque();\n        Map<Integer, Integer> depth = new HashMap();\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c)\n                if (grid[r][c] == 2) {\n                    int code = r * C + c;\n                    queue.add(code);\n                    depth.put(code, 0);\n                }\n\n        int ans = 0;\n        while (!queue.isEmpty()) {\n            int code = queue.remove();\n            int r = code / C, c = code % C;\n            for (int k = 0; k < 4; ++k) {\n                int nr = r + dr[k];\n                int nc = c + dc[k];\n                if (0 <= nr && nr < R && 0 <= nc && nc < C && grid[nr][nc] == 1) {\n                    grid[nr][nc] = 2;\n                    int ncode = nr * C + nc;\n                    queue.add(ncode);\n                    depth.put(ncode, depth.get(code) + 1);\n                    ans = depth.get(ncode);\n                }\n            }\n        }\n\n        for (int[] row: grid)\n            for (int v: row)\n                if (v == 1)\n                    return -1;\n        return ans;\n\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def orangesRotting(self, grid):\n        R, C = len(grid), len(grid[0])\n\n        # queue - all starting cells with rotting oranges\n        queue = collections.deque()\n        for r, row in enumerate(A):\n            for c, val in enumerate(row):\n                if val == 2:\n                    queue.append((r, c, 0))\n\n        def nei***ors(r, c):\n            for nr, nc in ((r-1,c),(r,c-1),(r+1,c),(r,c+1)):\n                if 0 <= nr < R and 0 <= nc < C:\n                    yield nr, nc\n\n        d = 0\n        while queue:\n            r, c, d = queue.popleft()\n            for nr, nc in nei***ors(r, c):\n                if A[nr][nc] == 1:\n                    A[nr][nc] = 2\n                    queue.append((nr, nc, d+1))\n\n        if any(1 in row for row in A):\n            return -1\n        return d"}]}
{"url": "https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-squareful-arrays", "source": [{"lang": "Java", "code": "class Solution {\n    Map<Integer, Integer> count;\n    Map<Integer, List<Integer>> graph;\n    public int numSquarefulPerms(int[] A) {\n        int N = A.length;\n        count = new HashMap();\n        graph = new HashMap();\n\n        // count.get(v) : 数组 A 中值为 v 的节点数量\n        for (int x: A)\n            count.put(x, count.getOrDefault(x, 0) + 1);\n\n        // graph.get(v) : 在 A 中的值 w 满足 v + w 是完全平方数\n        //                (ie., \"vw\" is an edge)\n        for (int x: count.keySet())\n            graph.put(x, new ArrayList());\n\n        for (int x: count.keySet())\n            for (int y: count.keySet()) {\n                int r = (int) (Math.sqrt(x + y) + 0.5);\n                if (r * r == x + y)\n                    graph.get(x).add(y);\n            }\n\n        // 增加从 x 开始的可行路径数量\n        int ans = 0;\n        for (int x: count.keySet())\n            ans += dfs(x, N - 1);\n        return ans;\n    }\n\n    public int dfs(int x, int todo) {\n        count.put(x, count.get(x) - 1);\n        int ans = 1;  \n        if (todo != 0) {\n            ans = 0;\n            for (int y: graph.get(x)) if (count.get(y) != 0) {\n                ans += dfs(y, todo - 1);\n            }\n        }\n        count.put(x, count.get(x) + 1);\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def numSquarefulPerms(self, A):\n        N = len(A)\n        count = collections.Counter(A)\n\n        graph = {x: [] for x in count}\n        for x in count:\n            for y in count:\n                if int((x+y)**.5 + 0.5) ** 2 == x+y:\n                    graph[x].append(y)\n\n        def dfs(x, todo):\n            count[x] -= 1\n            if todo == 0:\n                ans = 1\n            else:\n                ans = 0\n                for y in graph[x]:\n                    if count[y]:\n                        ans += dfs(y, todo - 1)\n            count[x] += 1\n            return ans\n\n        return sum(dfs(x, len(A) - 1) for x in count)"}, {"lang": "Java", "code": "class Solution {\n    int N;\n    Map<Integer, List<Integer>> graph;\n    Integer[][] memo;\n\n    public int numSquarefulPerms(int[] A) {\n        N = A.length;\n        graph = new HashMap();\n        memo = new Integer[N][1 << N];\n\n        for (int i = 0; i < N; ++i)\n            graph.put(i, new ArrayList());\n\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j) {\n                int r = (int) (Math.sqrt(A[i] + A[j]) + 0.5);\n                if (r * r == A[i] + A[j]) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n            }\n\n\n        int[] factorial = new int[20];\n        factorial[0] = 1;\n        for (int i = 1; i < 20; ++i)\n            factorial[i] = i * factorial[i-1];\n\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            ans += dfs(i, 1 << i);\n\n        Map<Integer, Integer> count = new HashMap();\n        for (int x: A)\n            count.put(x, count.getOrDefault(x, 0) + 1);\n        for (int v: count.values())\n            ans /= factorial[v];\n\n        return ans;\n    }\n\n    public int dfs(int node, int visited) {\n        if (visited == (1 << N) - 1)\n            return 1;\n        if (memo[node][visited] != null)\n            return memo[node][visited];\n\n        int ans = 0;\n        for (int nei: graph.get(node))\n            if (((visited >> nei) & 1) == 0)\n                ans += dfs(nei, visited | (1 << nei));\n        memo[node][visited] = ans;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "from functools import lru_cache\n\nclass Solution:\n    def numSquarefulPerms(self, A):\n        N = len(A)\n\n        def edge(x, y):\n            r = math.sqrt(x+y)\n            return int(r + 0.5) ** 2 == x+y\n\n        graph = [[] for _ in range(len(A))]\n        for i, x in enumerate(A):\n            for j in range(i):\n                if edge(x, A[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # find num of hamiltonian paths in graph\n\n        @lru_cache(None)\n        def dfs(node, visited):\n            if visited == (1 << N) - 1:\n                return 1\n\n            ans = 0\n            for nei in graph[node]:\n                if (visited >> nei) & 1 == 0:\n                    ans += dfs(nei, visited | (1 << nei))\n            return ans\n\n        ans = sum(dfs(i, 1<<i) for i in range(N))\n        count = collections.Counter(A)\n        for v in count.values():\n            ans //= math.factorial(v)\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/find-the-town-judge", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-binary-tree-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/available-captures-for-rook", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-cost-to-merge-stones", "source": []}
{"url": "https://leetcode-cn.com/problems/grid-illumination", "source": []}
{"url": "https://leetcode-cn.com/problems/find-common-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/check-if-word-is-valid-after-substitutions", "source": []}
{"url": "https://leetcode-cn.com/problems/max-consecutive-ones-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations", "source": []}
{"url": "https://leetcode-cn.com/problems/clumsy-factorial", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-domino-rotations-for-equal-row", "source": []}
{"url": "https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/complement-of-base-10-integer", "source": []}
{"url": "https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60", "source": []}
{"url": "https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days", "source": []}
{"url": "https://leetcode-cn.com/problems/numbers-with-repeated-digits", "source": []}
{"url": "https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/best-sightseeing-pair", "source": []}
{"url": "https://leetcode-cn.com/problems/smallest-integer-divisible-by-k", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-string-with-substrings-representing-1-to-n", "source": []}
{"url": "https://leetcode-cn.com/problems/convert-to-base-2", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-prefix-divisible-by-5", "source": []}
{"url": "https://leetcode-cn.com/problems/next-greater-node-in-linked-list", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-enclaves", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-outermost-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers", "source": []}
{"url": "https://leetcode-cn.com/problems/camelcase-matching", "source": []}
{"url": "https://leetcode-cn.com/problems/video-stitching", "source": []}
{"url": "https://leetcode-cn.com/problems/divisor-game", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-arithmetic-sequence", "source": []}
{"url": "https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal", "source": []}
{"url": "https://leetcode-cn.com/problems/two-city-scheduling", "source": []}
{"url": "https://leetcode-cn.com/problems/matrix-cells-in-distance-order", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-sum-of-two-non-overlapping-subarrays", "source": []}
{"url": "https://leetcode-cn.com/problems/stream-of-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/moving-stones-until-consecutive", "source": []}
{"url": "https://leetcode-cn.com/problems/coloring-a-border", "source": []}
{"url": "https://leetcode-cn.com/problems/uncrossed-lines", "source": []}
{"url": "https://leetcode-cn.com/problems/escape-a-large-maze", "source": []}
{"url": "https://leetcode-cn.com/problems/valid-boomerang", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon", "source": []}
{"url": "https://leetcode-cn.com/problems/moving-stones-until-consecutive-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/robot-bounded-in-circle", "source": []}
{"url": "https://leetcode-cn.com/problems/flower-planting-with-no-adjacent", "source": []}
{"url": "https://leetcode-cn.com/problems/partition-array-for-maximum-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-duplicate-substring", "source": []}
{"url": "https://leetcode-cn.com/problems/last-stone-weight", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-string-chain", "source": []}
{"url": "https://leetcode-cn.com/problems/last-stone-weight-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/height-checker", "source": []}
{"url": "https://leetcode-cn.com/problems/grumpy-bookstore-owner", "source": []}
{"url": "https://leetcode-cn.com/problems/previous-permutation-with-one-swap", "source": []}
{"url": "https://leetcode-cn.com/problems/distant-barcodes", "source": []}
{"url": "https://leetcode-cn.com/problems/greatest-common-divisor-of-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/flip-columns-for-maximum-number-of-equal-rows", "source": []}
{"url": "https://leetcode-cn.com/problems/adding-two-negabinary-numbers", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target", "source": []}
{"url": "https://leetcode-cn.com/problems/occurrences-after-bigram", "source": []}
{"url": "https://leetcode-cn.com/problems/letter-tile-possibilities", "source": []}
{"url": "https://leetcode-cn.com/problems/insufficient-nodes-in-root-to-leaf-paths", "source": []}
{"url": "https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/duplicate-zeros", "source": []}
{"url": "https://leetcode-cn.com/problems/largest-values-from-labels", "source": []}
{"url": "https://leetcode-cn.com/problems/shortest-path-in-binary-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/shortest-common-supersequence", "source": []}
{"url": "https://leetcode-cn.com/problems/statistics-from-a-large-sample", "source": []}
{"url": "https://leetcode-cn.com/problems/car-pooling", "source": []}
{"url": "https://leetcode-cn.com/problems/find-in-mountain-array", "source": []}
{"url": "https://leetcode-cn.com/problems/brace-expansion-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/distribute-candies-to-people", "source": []}
{"url": "https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/filling-bookcase-shelves", "source": []}
{"url": "https://leetcode-cn.com/problems/parsing-a-boolean-expression", "source": []}
{"url": "https://leetcode-cn.com/problems/defanging-an-ip-address", "source": []}
{"url": "https://leetcode-cn.com/problems/corporate-flight-bookings", "source": []}
{"url": "https://leetcode-cn.com/problems/delete-nodes-and-return-forest", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/relative-sort-array", "source": []}
{"url": "https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-well-performing-interval", "source": []}
{"url": "https://leetcode-cn.com/problems/smallest-sufficient-team", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs", "source": []}
{"url": "https://leetcode-cn.com/problems/shortest-path-with-alternating-colors", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-of-absolute-value-expression", "source": []}
{"url": "https://leetcode-cn.com/problems/n-th-tribonacci-number", "source": []}
{"url": "https://leetcode-cn.com/problems/alphabet-board-path", "source": []}
{"url": "https://leetcode-cn.com/problems/largest-1-bordered-square", "source": []}
{"url": "https://leetcode-cn.com/problems/stone-game-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-common-subsequence", "source": []}
{"url": "https://leetcode-cn.com/problems/decrease-elements-to-make-array-zigzag", "source": []}
{"url": "https://leetcode-cn.com/problems/binary-tree-coloring-game", "source": []}
{"url": "https://leetcode-cn.com/problems/snapshot-array", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-chunked-palindrome-decomposition", "source": []}
{"url": "https://leetcode-cn.com/problems/day-of-the-year", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/swap-for-longest-repeated-character-substring", "source": []}
{"url": "https://leetcode-cn.com/problems/online-majority-element-in-subarray", "source": []}
{"url": "https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/as-far-from-land-as-possible", "source": []}
{"url": "https://leetcode-cn.com/problems/last-substring-in-lexicographical-order", "source": []}
{"url": "https://leetcode-cn.com/problems/invalid-transactions", "source": []}
{"url": "https://leetcode-cn.com/problems/compare-strings-by-frequency-of-the-smallest-character", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list", "source": []}
{"url": "https://leetcode-cn.com/problems/dinner-plate-stacks", "source": []}
{"url": "https://leetcode-cn.com/problems/prime-arrangements", "source": []}
{"url": "https://leetcode-cn.com/problems/can-make-palindrome-from-substring", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle", "source": []}
{"url": "https://leetcode-cn.com/problems/distance-between-bus-stops", "source": []}
{"url": "https://leetcode-cn.com/problems/day-of-the-week", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion", "source": []}
{"url": "https://leetcode-cn.com/problems/make-array-strictly-increasing", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-number-of-balloons", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/k-concatenation-maximum-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/critical-connections-in-a-network", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-absolute-difference", "source": []}
{"url": "https://leetcode-cn.com/problems/ugly-number-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/smallest-string-with-swaps", "source": []}
{"url": "https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies", "source": []}
{"url": "https://leetcode-cn.com/problems/design-skiplist", "source": []}
{"url": "https://leetcode-cn.com/problems/unique-number-of-occurrences", "source": []}
{"url": "https://leetcode-cn.com/problems/get-equal-substrings-within-budget", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-moves-to-reach-target-with-rotations", "source": []}
{"url": "https://leetcode-cn.com/problems/play-with-chips", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference", "source": []}
{"url": "https://leetcode-cn.com/problems/path-with-maximum-gold", "source": []}
{"url": "https://leetcode-cn.com/problems/count-vowels-permutation", "source": []}
{"url": "https://leetcode-cn.com/problems/split-a-string-in-balanced-strings", "source": []}
{"url": "https://leetcode-cn.com/problems/queens-that-can-attack-the-king", "source": []}
{"url": "https://leetcode-cn.com/problems/dice-roll-simulation", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-equal-frequency", "source": []}
{"url": "https://leetcode-cn.com/problems/airplane-seat-assignment-probability", "source": []}
{"url": "https://leetcode-cn.com/problems/check-if-it-is-a-straight-line", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem", "source": []}
{"url": "https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling", "source": []}
{"url": "https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation", "source": []}
{"url": "https://leetcode-cn.com/problems/circular-permutation-in-binary-representation", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-swaps-to-make-strings-equal", "source": []}
{"url": "https://leetcode-cn.com/problems/count-number-of-nice-subarrays", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses", "source": []}
{"url": "https://leetcode-cn.com/problems/check-if-it-is-a-good-array", "source": []}
{"url": "https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/reconstruct-a-2-row-binary-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-closed-islands", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-score-words-formed-by-letters", "source": []}
{"url": "https://leetcode-cn.com/problems/shift-2d-grid", "source": []}
{"url": "https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/greatest-sum-divisible-by-three", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-moves-to-move-a-box-to-their-target-location", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-time-visiting-all-points", "source": []}
{"url": "https://leetcode-cn.com/problems/count-servers-that-communicate", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int countServers(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<int> count_m(m), count_n(n);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    ++count_m[i];\n                    ++count_n[j];\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1 && (count_m[i] > 1 || count_n[j] > 1)) {\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python", "code": "class Solution:\n    def countServers(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        count_m, count_n = [0] * m, [0] * n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    count_m[i] += 1\n                    count_n[j] += 1\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1 and (count_m[i] > 1 or count_n[j] > 1):\n                    ans += 1\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/search-suggestions-system", "source": [{"lang": "C++", "code": "struct Trie {\n    unordered_map<char, Trie*> child;\n    priority_queue<string> words;\n};\n\nclass Solution {\nprivate:\n    void addWord(Trie* root, const string& word) {\n        Trie* cur = root;\n        for (const char& ch: word) {\n            if (!cur->child.count(ch)) {\n                cur->child[ch] = new Trie();\n            }\n            cur = cur->child[ch];\n            cur->words.push(word);\n            if (cur->words.size() > 3) {\n                cur->words.pop();\n            }\n        }\n    }\n    \npublic:\n    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {\n        Trie* root = new Trie();\n        for (const string& word: products) {\n            addWord(root, word);\n        }\n        \n        vector<vector<string>> ans;\n        Trie* cur = root;\n        bool flag = false;\n        for (const char& ch: searchWord) {\n            if (flag || !cur->child.count(ch)) {\n                ans.emplace_back();\n                flag = true;\n            }\n            else {\n                cur = cur->child[ch];\n                vector<string> selects;\n                while (!cur->words.empty()) {\n                    selects.push_back(cur->words.top());\n                    cur->words.pop();\n                }\n                reverse(selects.begin(), selects.end());\n                ans.push_back(move(selects));\n            }\n        }\n        \n        return ans;\n    }\n};"}, {"lang": "Python", "code": "class Trie:\n    def __init__(self):\n        self.child = dict()\n        self.words = list()\n\nclass Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        def addWord(root, word):\n            cur = root\n            for ch in word:\n                if ch not in cur.child:\n                    cur.child[ch] = Trie()\n                cur = cur.child[ch]\n                cur.words.append(word)\n                cur.words.sort()\n                if len(cur.words) > 3:\n                    cur.words.pop()\n\n        root = Trie()\n        for word in products:\n            addWord(root, word)\n        \n        ans = list()\n        cur = root\n        flag = False\n        for ch in searchWord:\n            if flag or ch not in cur.child:\n                ans.append(list())\n                flag = True\n            else:\n                cur = cur.child[ch]\n                ans.append(cur.words)\n\n        return ans"}, {"lang": "C++", "code": "class Solution {\npublic:\n    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {\n        sort(products.begin(), products.end());\n        string query;\n        auto iter_last = products.begin();\n        vector<vector<string>> ans;\n        for (char ch: searchWord) {\n            query += ch;\n            auto iter_find = lower_bound(iter_last, products.end(), query);\n            vector<string> selects;\n            for (int i = 0; i < 3; ++i) {\n                if (iter_find + i < products.end() && (*(iter_find + i)).find(query) == 0) {\n                    selects.push_back(*(iter_find + i));\n                }\n            }\n            ans.push_back(move(selects));\n            iter_last = iter_find;\n        }\n        return ans;\n    }\n};"}, {"lang": "Python", "code": "class Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n        query = \"\"\n        iter_last = 0\n        ans = list()\n        for ch in searchWord:\n            query += ch\n            iter_find = bisect.bisect_left(products, query, iter_last)\n            ans.append([s for s in products[iter_find : iter_find + 3] if s.startswith(query)])\n            iter_last = iter_find\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps", "source": [{"lang": "C++", "code": "f[i][j] = f[i - 1][j - 1] + f[i - 1][j] + f[i - 1][j + 1]\nf[0][0] = 1"}, {"lang": "Python", "code": ""}, {"lang": "C++", "code": "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(arrLen, steps + 1)\n        f = [[0] * arrLen for _ in range(steps + 1)]\n        f[0][0] = 1\n        for i in range(1, steps + 1):\n            for j in range(arrLen):\n                for k in [-1, 0, 1]:\n                    if 0 <= j - k < arrLen:\n                        f[i][j] += f[i - 1][j - k]\n        return f[steps][0] % (10**9 + 7)"}, {"lang": "Python", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    bool checkwin(unordered_set<int>& S, vector<vector<int>>& wins) {\n        for (auto win: wins) {\n            bool flag = true;\n            for (auto pos: win) {\n                if (!S.count(pos)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    string tictactoe(vector<vector<int>>& moves) {\n        vector<vector<int>> wins = {\n            {0, 1, 2},\n            {3, 4, 5},\n            {6, 7, 8},\n            {0, 3, 6},\n            {1, 4, 7},\n            {2, 5, 8},\n            {0, 4, 8},\n            {2, 4, 6}\n        };\n\n        unordered_set<int> A, B;\n        for (int i = 0; i < moves.size(); ++i) {\n            int pos = moves[i][0] * 3 + moves[i][1];\n            if (i % 2 == 0) {\n                A.insert(pos);\n                if (checkwin(A, wins)) {\n                    return \"A\";\n                }\n            }\n            else {\n                B.insert(pos);\n                if (checkwin(B, wins)) {\n                    return \"B\";\n                }\n            }\n        }\n\n        return (moves.size() == 9 ? \"Draw\" : \"Pending\");\n    }\n};"}, {"lang": "Python", "code": "class Solution:\n    def tictactoe(self, moves: List[List[int]]) -> str:\n        wins = [\n            [(0, 0), (0, 1), (0, 2)],\n            [(1, 0), (1, 1), (1, 2)],\n            [(2, 0), (2, 1), (2, 2)],\n            [(0, 0), (1, 0), (2, 0)],\n            [(0, 1), (1, 1), (2, 1)],\n            [(0, 2), (1, 2), (2, 2)],\n            [(0, 0), (1, 1), (2, 2)],\n            [(0, 2), (1, 1), (2, 0)],\n        ]\n\n        def checkwin(S):\n            for win in wins:\n                flag = True\n                for pos in win:\n                    if pos not in S:\n                        flag = False\n                        break\n                if flag:\n                    return True\n            return False\n\n        A, B = set(), set()\n        for i, (x, y) in enumerate(moves):\n            if i % 2 == 0:\n                A.add((x, y))\n                if checkwin(A):\n                    return \"A\"\n            else:\n                B.add((x, y))\n                if checkwin(B):\n                    return \"B\"\n        \n        return \"Draw\" if len(moves) == 9 else \"Pending\""}]}
{"url": "https://leetcode-cn.com/problems/number-of-burgers-with-no-waste-of-ingredients", "source": []}
{"url": "https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones", "source": []}
{"url": "https://leetcode-cn.com/problems/palindrome-partitioning-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer", "source": []}
{"url": "https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    vector<vector<int>> groupThePeople(vector<int>& groupSizes) {\n        unordered_map<int, vector<int>> groups;\n        for (int i = 0; i < groupSizes.size(); ++i) {\n            groups[groupSizes[i]].push_back(i);\n        }\n\n        vector<vector<int>> ans;\n        for (auto group = groups.begin(); group != groups.end(); ++group) {\n            const int& gsize = group->first;\n            vector<int>& users = group->second;\n            for (auto iter = users.begin(); iter != users.end(); iter = next(iter, gsize)) {\n                vector<int> dummy(iter, next(iter, gsize));\n                ans.push_back(dummy);\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "C++", "code": "// C++17 Standard\nclass Solution {\npublic:\n    vector<vector<int>> groupThePeople(vector<int>& groupSizes) {\n        unordered_map<int, vector<int>> groups;\n        for (int i = 0; i < groupSizes.size(); ++i) {\n            groups[groupSizes[i]].push_back(i);\n        }\n\n        vector<vector<int>> ans;\n        for (auto& [gsize, users]: groups) {\n            for (auto iter = users.begin(); iter != users.end(); iter = next(iter, gsize)) {\n                ans.emplace_back(iter, next(iter, gsize));\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python", "code": "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        groups = collections.defaultdict(list)\n        for i, _id in enumerate(groupSizes):\n            groups[_id].append(i)\n        \n        ans = list()\n        for gsize, users in groups.items():\n            for it in range(0, len(users), gsize):\n                ans.append(users[it : it + gsize])\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/iterator-for-combination", "source": [{"lang": "C++", "code": "a b c"}, {"lang": "Python3", "code": "a b c     =>     a b d     =>     a b e\n    ^                ^\n    d                e"}]}
{"url": "https://leetcode-cn.com/problems/element-appearing-more-than-25-in-sorted-array", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-covered-intervals", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        int ans = n;\n        for (int i = 0; i < intervals.size(); ++i) {\n            for (int j = 0; j < intervals.size(); ++j) {\n                if (i != j && intervals[j][0] <= intervals[i][0] && intervals[i][1] <= intervals[j][1]) {\n                    --ans;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        ans = n\n        for i in range(n):\n            for j in range(n):\n                if i != j and intervals[j][0] <= intervals[i][0] and intervals[i][1] <= intervals[j][1]:\n                    ans -= 1\n                    break\n        return ans"}, {"lang": "C++", "code": "class Solution {\npublic:\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& u, const vector<int>& v) {\n            return u[0] < v[0] || (u[0] == v[0] && u[1] > v[1]);\n        });\n        int ans = n;\n        int rmax = intervals[0][1];\n        for (int i = 1; i < n; ++i) {\n            if (intervals[i][1] <= rmax) {\n                --ans;\n            }\n            else {\n                rmax = max(rmax, intervals[i][1]);\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        intervals.sort(key=lambda u: (u[0], -u[1]))\n        ans, rmax = n, intervals[0][1]\n        for i in range(1, n):\n            if intervals[i][1] <= rmax:\n                ans -= 1\n            else:\n                rmax = max(rmax, intervals[i][1])\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/minimum-falling-path-sum-ii", "source": []}
{"url": "https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        ListNode* cur = head;\n        int ans = 0;\n        while (cur != nullptr) {\n            ans = ans * 2 + cur->val;\n            cur = cur->next;\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def getDecimalValue(self, head: ListNode) -> int:\n        cur = head\n        ans = 0\n        while cur:\n            ans = ans * 2 + cur.val\n            cur = cur.next\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/sequential-digits", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    vector<int> sequentialDigits(int low, int high) {\n        vector<int> ans;\n        for (int i = 1; i <= 9; ++i) {\n            int num = i;\n            for (int j = i + 1; j <= 9; ++j) {\n                num = num * 10 + j;\n                if (num >= low && num <= high) {\n                    ans.push_back(num);\n                }\n            }\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\n        ans = list()\n        for i in range(1, 10):\n            num = i\n            for j in range(i + 1, 10):\n                num = num * 10 + j\n                if low <= num <= high:\n                    ans.append(num)\n        return sorted(ans)"}]}
{"url": "https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold", "source": []}
{"url": "https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination", "source": [{"lang": "C++", "code": "struct Nagato {\n    int x, y;\n    int rest;\n    Nagato(int _x, int _y, int _r): x(_x), y(_y), rest(_r) {}\n};\n\nclass Solution {\nprivate:\n    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\npublic:\n    int shortestPath(vector<vector<int>>& grid, int k) {\n        int m = grid.size(), n = grid[0].size();\n        if (m == 1 && n == 1) {\n            return 0;\n        }\n\n        k = min(k, m + n - 3);\n        bool visited[m][n][k + 1];\n        memset(visited, false, sizeof(visited));\n        queue<Nagato> q;\n        q.emplace(0, 0, k);\n        visited[0][0][k] = true;\n\n        for (int step = 1; q.size() > 0; ++step) {\n            int cnt = q.size();\n            for (int _ = 0; _ < cnt; ++_) {\n                Nagato cur = q.front();\n                q.pop();\n                for (int i = 0; i < 4; ++i) {\n                    int nx = cur.x + dirs[i][0];\n                    int ny = cur.y + dirs[i][1];\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                        if (grid[nx][ny] == 0 && !visited[nx][ny][cur.rest]) {\n                            if (nx == m - 1 && ny == n - 1) {\n                                return step;\n                            }\n                            q.emplace(nx, ny, cur.rest);\n                            visited[nx][ny][cur.rest] = true;\n                        }\n                        else if (grid[nx][ny] == 1 && cur.rest > 0 && !visited[nx][ny][cur.rest - 1]) {\n                            q.emplace(nx, ny, cur.rest - 1);\n                            visited[nx][ny][cur.rest - 1] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 1:\n            return 0\n        \n        k = min(k, m + n - 3)\n        visited = set([(0, 0, k)])\n        q = collections.deque([(0, 0, k)])\n\n        step = 0\n        while len(q) > 0:\n            step += 1\n            cnt = len(q)\n            for _ in range(cnt):\n                x, y, rest = q.popleft()\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n:\n                        if grid[nx][ny] == 0 and (nx, ny, rest) not in visited:\n                            if nx == m - 1 and ny == n - 1:\n                                return step\n                            q.append((nx, ny, rest))\n                            visited.add((nx, ny, rest))\n                        elif grid[nx][ny] == 1 and rest > 0 and (nx, ny, rest - 1) not in visited:\n                            q.append((nx, ny, rest - 1))\n                            visited.add((nx, ny, rest - 1))\n        return -1"}]}
{"url": "https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int findNumbers(vector<int>& nums) {\n        int ans = 0;\n        for (int num: nums) {\n            if (to_string(num).size() % 2 == 0) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "C++17", "code": "class Solution {\npublic:\n    int findNumbers(vector<int>& nums) {\n        return accumulate(nums.begin(), nums.end(), 0, [](int ans, int num) {\n            return ans + (to_string(num).size() % 2 == 0);\n        });\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def findNumbers(self, nums: List[int]) -> int:\n        return sum(1 for num in nums if len(str(num)) % 2 == 0)"}, {"lang": "C++", "code": "class Solution {\npublic:\n    int findNumbers(vector<int>& nums) {\n        int ans = 0;\n        for (int num: nums) {\n            if ((int)(log10(num) + 1) % 2 == 0) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "C++17", "code": "class Solution {\npublic:\n    int findNumbers(vector<int>& nums) {\n        return accumulate(nums.begin(), nums.end(), 0, [](int ans, int num) {\n            return ans + ((int)(log10(num) + 1) % 2 == 0);\n        });\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def findNumbers(self, nums: List[int]) -> int:\n        return sum(1 for num in nums if int(math.log10(num) + 1) % 2 == 0)"}]}
{"url": "https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {\n        int n = s.size();\n        unordered_map<string, int> occ;\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            unordered_set<char> exist;\n            string cur;\n            for (int j = i; j < min(n, i + maxSize); ++j) {\n                exist.insert(s[j]);\n                if (exist.size() > maxLetters) {\n                    break;\n                }\n                cur += s[j];\n                if (j - i + 1 >= minSize) {\n                    ++occ[cur];\n                    ans = max(ans, occ[cur]);\n                }\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        occ = collections.defaultdict(int)\n        ans = 0\n        for i in range(n):\n            exist = set()\n            cur = \"\"\n            for j in range(i, min(n, i + maxSize)):\n                exist.add(s[j])\n                if len(exist) > maxLetters:\n                    break\n                cur += s[j]\n                if j - i + 1 >= minSize:\n                    occ[cur] += 1\n                    ans = max(ans, occ[cur])\n        return ans"}, {"lang": "C++", "code": "class Solution {\npublic:\n    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {\n        int n = s.size();\n        unordered_map<string, int> occ;\n        int ans = 0;\n        for (int i = 0; i < n - minSize + 1; ++i) {\n            string cur = s.substr(i, minSize);\n            unordered_set<char> exist(cur.begin(), cur.end());\n            if (exist.size() <= maxLetters) {\n                string cur = s.substr(i, minSize);\n                ++occ[cur];\n                ans = max(ans, occ[cur]);\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        occ = collections.defaultdict(int)\n        ans = 0\n        for i in range(n - minSize + 1):\n            cur = s[i : i + minSize]\n            exist = set(cur)\n            if len(exist) <= maxLetters:\n                occ[cur] += 1\n                ans = max(ans, occ[cur])\n        return ans"}, {"lang": "C++", "code": "using LL = long long;\n\nclass Solution {\nprivate:\n    static constexpr int mod = 1000000007;\n\npublic:\n    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {\n        int n = s.size();\n        unordered_map<int, int> occ;\n        unordered_map<char, int> exist;\n        int ans = 0, exist_cnt = 0;\n        int rabin = 0, base = 26, base_mul = base;\n        \n        for (int i = 0; i < minSize - 1; ++i) {\n            ++exist[s[i]];\n            if (exist[s[i]] == 1) {\n                ++exist_cnt;\n            }\n            rabin = ((LL)rabin * base + (s[i] - 97)) % mod;\n            base_mul = (LL)base_mul * base % mod;\n        }\n\n        for (int i = minSize - 1; i < n; ++i) {\n            ++exist[s[i]];\n            if (exist[s[i]] == 1) {\n                ++exist_cnt;\n            }\n            rabin = ((LL)rabin * base + (s[i] - 97)) % mod;\n            if (i >= minSize) {\n                --exist[s[i - minSize]];\n                if (exist[s[i - minSize]] == 0) {\n                    --exist_cnt;\n                }\n                rabin = (rabin - (LL)base_mul * (s[i - minSize] - 97) % mod + mod) % mod;\n            }\n            if (exist_cnt <= maxLetters) {\n                ++occ[rabin];\n                ans = max(ans, occ[rabin]);\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        occ = collections.defaultdict(int)\n        exist = collections.defaultdict(int)\n        mod = 1e9 + 7\n        ans, exist_cnt = 0, 0\n        rabin, base, base_mul = 0, 26, 26\n\n        for i in range(minSize - 1):\n            exist[s[i]] += 1\n            if exist[s[i]] == 1:\n                exist_cnt += 1\n            rabin = (rabin * base + (ord(s[i]) - 97)) % mod\n            base_mul = base_mul * base % mod\n\n        for i in range(minSize - 1, n):\n            exist[s[i]] += 1\n            if exist[s[i]] == 1:\n                exist_cnt += 1\n            rabin = (rabin * base + (ord(s[i]) - 97)) % mod\n            if i >= minSize:\n                exist[s[i - minSize]] -= 1\n                if exist[s[i - minSize]] == 0:\n                    exist_cnt -= 1\n                rabin = (rabin - base_mul * (ord(s[i - minSize]) - 97) % mod + mod) % mod\n            if exist_cnt <= maxLetters:\n                occ[rabin] += 1\n                ans = max(ans, occ[rabin])\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/maximum-candies-you-can-get-from-boxes", "source": []}
{"url": "https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side", "source": []}
{"url": "https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-paths-with-max-score", "source": [{"lang": "C++", "code": "for i = n - 1 to 1\n    for j = n - 1 to 1\n        // some codes..."}, {"lang": "Python3", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/deepest-leaves-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero", "source": []}
{"url": "https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees", "source": []}
{"url": "https://leetcode-cn.com/problems/jump-game-iii", "source": []}
{"url": "https://leetcode-cn.com/problems/verbal-arithmetic-puzzle", "source": [{"lang": "C++", "code": "  SEND\n+ MORE\n-------\n MONEY"}, {"lang": "Python3", "code": ""}, {"lang": "C++", "code": "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        used, carry = [False] * 10, [0] * 10\n        lead_zero, rep = dict(), dict()\n\n        for word in words:\n            if len(word) > len(result):\n                return False\n            for ch in word:\n                rep[ch] = -1\n                lead_zero[ch] = max(lead_zero.get(ch, 0), 0)\n            if len(word) > 1:\n                lead_zero[word[0]] = 1\n        for ch in result:\n            rep[ch] = -1\n            lead_zero[ch] = max(lead_zero.get(ch, 0), 0)\n        if len(result) > 1:\n            lead_zero[result[0]] = 1\n        \n        def dfs(pos, iden, length):\n            if pos == length:\n                return carry[pos] == 0\n            elif iden < len(words):\n                sz = len(words[iden])\n                if sz < pos or rep[words[iden][sz - pos - 1]] != -1:\n                    return dfs(pos, iden + 1, length)\n                else:\n                    ch = words[iden][sz - pos - 1]\n                    for i in range(lead_zero[ch], 10):\n                        if not used[i]:\n                            used[i], rep[ch] = True, i\n                            check = dfs(pos, iden + 1, length)\n                            used[i], rep[ch] = False, -1\n                            if check:\n                                return True\n                    return False\n            else:\n                left = carry[pos] + sum(rep[word[len(word) - pos - 1]] for word in words if len(word) > pos)\n                carry[pos + 1], left = left // 10, left % 10\n                ch = result[len(result) - pos - 1]\n                if rep[ch] == left:\n                    return dfs(pos + 1, 0, length)\n                elif rep[ch] == -1 and not used[left] and not (lead_zero[ch] == 1 and left == 0):\n                    used[left], rep[ch] = True, left\n                    check = dfs(pos + 1, 0, length)\n                    used[left], rep[ch] = False, -1\n                    return check\n                else:\n                    return False\n\n        return dfs(0, 0, len(result))"}, {"lang": "Python3", "code": "SEND  =             S * 1000 + E * 100 + N * 10 + D\nMORE  =             M * 1000 + O * 100 + R * 10 + E\nMONEY = M * 10000 + O * 1000 + N * 100 + E * 10 + Y"}]}
{"url": "https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    string freqAlphabets(string s) {\n        string ans;\n        for (int i = 0; i < s.size(); ++i) {\n            if (i + 2 < s.size() && s[i + 2] == '#') {\n                ans += char((s[i] - '0') * 10 + (s[i + 1] - '1') + 'a');\n                i += 2;\n            }\n            else {\n                ans += char(s[i] - '1' + 'a');\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def freqAlphabets(self, s: str) -> str:\n        def get(st):\n            return chr(int(st) + 96)\n\n        i, ans = 0, \"\"\n        while i < len(s):\n            if i + 2 < len(s) and s[i + 2] == '#':\n                ans += get(s[i : i + 2])\n                i += 2\n            else:\n                ans += get(s[i])\n            i += 1\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/xor-queries-of-a-subarray", "source": [{"lang": "C++", "code": "pre[0] = 0\npre[i] = arr[0] ^ arr[1] ^ ... ^ arr[i - 1]"}, {"lang": "Python3", "code": "pre[Li] ^ pre[Ri + 1] = (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[0] ^ ... ^ arr[Ri])\n                      = (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[Li] ^ ... ^ arr[Ri]) （异或运算的结合律）\n                      = 0 ^ (arr[Li] ^ ... ^ arr[Ri]) （异或运算的逆运算，即 a ^ a = 0）\n                      = arr[Li] ^ ... ^ arr[Ri]"}]}
{"url": "https://leetcode-cn.com/problems/get-watched-videos-by-your-friends", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome", "source": []}
{"url": "https://leetcode-cn.com/problems/decompress-run-length-encoded-list", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    vector<int> decompressRLElist(vector<int>& nums) {\n        vector<int> ans;\n        for (int i = 0; i < nums.size(); i += 2) {\n            for (int j = 0; j < nums[i]; ++j) {\n                ans.push_back(nums[i + 1]);\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def decompressRLElist(self, nums: List[int]) -> List[int]:\n        ans = list()\n        for i in range(0, len(nums), 2):\n            ans.extend([nums[i + 1]] * nums[i])\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/matrix-block-sum", "source": [{"lang": "C++", "code": "sum = P[i + K + 1][j + K + 1] - P[i - K][j + K + 1] - P[i + K + 1][j - K] + P[i - K][j - K]"}, {"lang": "Python3", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent", "source": []}
{"url": "https://leetcode-cn.com/problems/distinct-echo-substrings", "source": [{"lang": "C++", "code": "class Solution {\npublic:\n    int distinctEchoSubstrings(string text) {\n        int n = text.size();\n        unordered_set<string_view> seen;\n        string_view text_v(text);\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int l = j - i;\n                if (j * 2 - i <= n && text_v.substr(i, l) == text_v.substr(j, l) && !seen.count(text_v.substr(i, l))) {\n                    ++ans;\n                    seen.insert(text_v.substr(i, l));\n                }\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        seen = set()\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if j * 2 - i <= n and text[i:j] == text[j:j*2-i] and text[i:j] not in seen:\n                    ans += 1\n                    seen.add(text[i:j])\n        return ans"}, {"lang": "C++", "code": "using LL = long long;\n\nclass Solution {\nprivate:\n    constexpr static int mod = (int)1e9 + 7;\n    \npublic:\n    int gethash(const vector<int>& pre, const vector<int>& mul, int l, int r) {\n        return (pre[r + 1] - (LL)pre[l] * mul[r - l + 1] % mod + mod) % mod;\n    }\n    \n    int distinctEchoSubstrings(string text) {\n        int n = text.size();\n        \n        int base = 31;\n        vector<int> pre(n + 1), mul(n + 1);\n        pre[0] = 0;\n        mul[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            pre[i] = ((LL)pre[i - 1] * base + text[i - 1]) % mod;\n            mul[i] = (LL)mul[i - 1] * base % mod;\n        }\n        \n        unordered_set<int> seen[n];\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int l = j - i;\n                if (j + l <= n) {\n                    int hash_left = gethash(pre, mul, i, j - 1);\n                    if (!seen[l - 1].count(hash_left) && hash_left == gethash(pre, mul, j, j + l - 1)) {\n                        ++ans;\n                        seen[l - 1].insert(hash_left);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n\n        mod, base = 10**9 + 7, 31\n        pre, mul = [0] * (n + 1), [1] + [0] * n\n        for i in range(1, n + 1):\n            pre[i] = (pre[i - 1] * base + ord(text[i - 1])) % mod\n            mul[i] = mul[i - 1] * base % mod\n        \n        def get_hash(l, r):\n            return (pre[r + 1] - pre[l] * mul[r - l + 1] % mod + mod) % mod\n\n        seen = {x: set() for x in range(n)}\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                l = j - i\n                if j + l <= n:\n                    hash_left = get_hash(i, j - 1)\n                    if hash_left not in seen[l - 1] and hash_left == get_hash(j, j + l - 1):\n                        ans += 1\n                        seen[l - 1].add(hash_left)\n        return ans"}]}
{"url": "https://leetcode-cn.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-flips-to-make-a-or-b-equal-to-c", "source": []}
{"url": "https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected", "source": [{"lang": "C++", "code": "class Solution {\nprivate:\n    vector<vector<int>> edges;\n    vector<bool> used;\n\npublic:\n    void dfs(int u) {\n        used[u] = true;\n        for (int v: edges[u]) {\n            if (!used[v]) {\n                dfs(v);\n            }\n        }\n    }\n    \n    int makeConnected(int n, vector<vector<int>>& connections) {\n        if (connections.size() < n - 1) {\n            return -1;\n        }\n\n        edges.resize(n);\n        for (auto&& c: connections) {\n            edges[c[0]].push_back(c[1]);\n            edges[c[1]].push_back(c[0]);\n        }\n        used.resize(n);\n\n        int part = 0;\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                ++part;\n                dfs(i);\n            }\n        }\n        \n        return part - 1;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n        \n        edges = {x: list() for x in range(n)}\n        for c0, c1 in connections:\n            edges[c0].append(c1)\n            edges[c1].append(c0)\n        used = set()\n\n        def dfs(u):\n            used.add(u)\n            for v in edges[u]:\n                if v not in used:\n                    dfs(v)\n        \n        part = 0\n        for i in range(n):\n            if i not in used:\n                part += 1\n                dfs(i)\n        \n        return part - 1"}, {"lang": "C++", "code": "class Solution {\nprivate:\n    vector<int> fa;\n\npublic:\n    int findset(int x) {\n        return x == fa[x] ? x : fa[x] = findset(fa[x]);\n    }\n\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        if (connections.size() < n - 1) {\n            return -1;\n        }\n\n        fa.resize(n);\n        iota(fa.begin(), fa.end(), 0);\n        \n        int part = n;\n        for (auto&& c: connections) {\n            int p = findset(c[0]), q = findset(c[1]);\n            if (p != q) {\n                --part;\n                fa[p] = q;\n            }\n        }\n\n        return part - 1;\n    }\n};"}, {"lang": "C++17", "code": "class Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        if (connections.size() < n - 1) {\n            return -1;\n        }\n\n        vector<int> fa(n);\n        iota(fa.begin(), fa.end(), 0);\n        \n        function<int(int)> findset = [&](int x) {return x == fa[x] ? x : fa[x] = findset(fa[x]);};\n\n        int part = n;\n        for (auto&& c: connections) {\n            int p = findset(c[0]), q = findset(c[1]);\n            if (p != q) {\n                --part;\n                fa[p] = q;\n            }\n        }\n\n        return part - 1;\n    }\n};"}, {"lang": "Python3", "code": "class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n        \n        fa = [x for x in range(n)]\n\n        def findset(x):\n            if x != fa[x]:\n                fa[x] = findset(fa[x])\n            return fa[x]\n        \n        part = n\n        for c0, c1 in connections:\n            p, q = findset(c0), findset(c1)\n            if p != q:\n                part -= 1\n                fa[p] = q\n        \n        return part - 1"}]}
{"url": "https://leetcode-cn.com/problems/minimum-distance-to-type-a-word-using-two-fingers", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-69-number", "source": []}
{"url": "https://leetcode-cn.com/problems/print-words-vertically", "source": []}
{"url": "https://leetcode-cn.com/problems/delete-leaves-with-a-given-value", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-number-of-taps-to-open-to-water-a-garden", "source": []}
{"url": "https://leetcode-cn.com/problems/break-a-palindrome", "source": []}
{"url": "https://leetcode-cn.com/problems/sort-the-matrix-diagonally", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-subarray-to-maximize-array-value", "source": []}
{"url": "https://leetcode-cn.com/problems/rank-transform-of-an-array", "source": []}
{"url": "https://leetcode-cn.com/problems/remove-palindromic-subsequences", "source": []}
{"url": "https://leetcode-cn.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance", "source": []}
{"url": "https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance", "source": []}
{"url": "https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule", "source": []}
{"url": "https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree", "source": []}
{"url": "https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix", "source": []}
{"url": "https://leetcode-cn.com/problems/reduce-array-size-to-the-half", "source": []}
{"url": "https://leetcode-cn.com/problems/jump-game-v", "source": []}
{"url": "https://leetcode-cn.com/problems/guess-numbers", "source": []}
{"url": "https://leetcode-cn.com/problems/deep-dark-fraction", "source": []}
{"url": "https://leetcode-cn.com/problems/programmable-robot", "source": []}
{"url": "https://leetcode-cn.com/problems/broken-board-dominoes", "source": []}
{"url": "https://leetcode-cn.com/problems/coin-bonus", "source": []}
{"url": "https://leetcode-cn.com/problems/distribute-candies-to-people", "source": []}
{"url": "https://leetcode-cn.com/problems/two-sum", "source": []}
{"url": "https://leetcode-cn.com/problems/add-two-numbers", "source": [{"lang": "Java", "code": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummyHead;\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        carry = sum / 10;\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry > 0) {\n        curr.next = new ListNode(carry);\n    }\n    return dummyHead.next;\n}"}]}
{"url": "https://leetcode-cn.com/problems/longest-substring-without-repeating-characters", "source": []}
{"url": "https://leetcode-cn.com/problems/median-of-two-sorted-arrays", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-palindromic-substring", "source": []}
{"url": "https://leetcode-cn.com/problems/zigzag-conversion", "source": []}
{"url": "https://leetcode-cn.com/problems/reverse-integer", "source": [{"lang": "C++", "code": "//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;"}, {"lang": "Java", "code": ""}]}
{"url": "https://leetcode-cn.com/problems/string-to-integer-atoi", "source": []}
{"url": "https://leetcode-cn.com/problems/palindrome-number", "source": [{"lang": "C#", "code": "public class Solution {\n    public bool IsPalindrome(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if(x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while(x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n}"}]}
{"url": "https://leetcode-cn.com/problems/regular-expression-matching", "source": [{"lang": "Python", "code": "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])"}, {"lang": "Java", "code": "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isMatch(self, text, pattern):\n        if not pattern:\n            return not text\n\n        first_match = bool(text) and pattern[0] in {text[0], '.'}\n\n        if len(pattern) >= 2 and pattern[1] == '*':\n            return (self.isMatch(text, pattern[2:]) or\n                    first_match and self.isMatch(text[1:], pattern))\n        else:\n            return first_match and self.isMatch(text[1:], pattern[1:])"}, {"lang": "Java", "code": "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isMatch(self, text, pattern):\n        memo = {}\n        def dp(i, j):\n            if (i, j) not in memo:\n                if j == len(pattern):\n                    ans = i == len(text)\n                else:\n                    first_match = i < len(text) and pattern[j] in {text[i], '.'}\n                    if j+1 < len(pattern) and pattern[j+1] == '*':\n                        ans = dp(i, j+2) or first_match and dp(i+1, j)\n                    else:\n                        ans = first_match and dp(i+1, j+1)\n\n                memo[i, j] = ans\n            return memo[i, j]\n\n        return dp(0, 0)"}, {"lang": "Java", "code": "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"}, {"lang": "Python", "code": "class Solution(object):\n    def isMatch(self, text, pattern):\n        dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)]\n\n        dp[-1][-1] = True\n        for i in range(len(text), -1, -1):\n            for j in range(len(pattern) - 1, -1, -1):\n                first_match = i < len(text) and pattern[j] in {text[i], '.'}\n                if j+1 < len(pattern) and pattern[j+1] == '*':\n                    dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]\n                else:\n                    dp[i][j] = first_match and dp[i+1][j+1]\n\n        return dp[0][0]"}]}
{"url": "https://leetcode-cn.com/problems/container-with-most-water", "source": [{"lang": "Java", "code": "public class Solution {\n    public int maxArea(int[] height) {\n        int maxarea = 0;\n        for (int i = 0; i < height.length; i++)\n            for (int j = i + 1; j < height.length; j++)\n                maxarea = Math.max(maxarea, Math.min(height[i], height[j]) * (j - i));\n        return maxarea;\n    }\n}"}, {"lang": "Java", "code": "1 8 6 2 5 4 8 3 7"}]}
{"url": "https://leetcode-cn.com/problems/integer-to-roman", "source": []}
{"url": "https://leetcode-cn.com/problems/roman-to-integer", "source": []}
{"url": "https://leetcode-cn.com/problems/longest-common-prefix", "source": []}
{"url": "https://leetcode-cn.com/problems/3sum", "source": []}
{"url": "https://leetcode-cn.com/problems/3sum-closest", "source": []}
